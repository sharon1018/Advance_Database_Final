[{"package_name": "Deep Learning Specialization ", "week_data": [{"description": "Be able to explain the major trends driving the rise of deep learning, and understand where and how it is applied today.  ", "video": ["Welcome", "What is a neural network?", "Supervised Learning with Neural Networks", "Why is Deep Learning taking off?", "About this Course", "Frequently Asked Questions", "Course Resources", "How to use Discussion Forums", "Geoffrey Hinton interview", "Introduction to deep learning"], "title": "Introduction to deep learning"}, {"description": "Learn to set up a machine learning problem with a neural network mindset. Learn to use vectorization to speed up your models. ", "video": ["Binary Classification", "Logistic Regression", "Logistic Regression Cost Function", "Gradient Descent", "Derivatives", "More Derivative Examples", "Computation graph", "Derivatives with a Computation Graph", "Logistic Regression Gradient Descent", "Gradient Descent on m Examples", "Vectorization", "More Vectorization Examples", "Vectorizing Logistic Regression", "Vectorizing Logistic Regression's Gradient Output", "Broadcasting in Python", "A note on python/numpy vectors", "Quick tour of Jupyter/iPython Notebooks", "Explanation of logistic regression cost function (optional)", "Deep Learning Honor Code", "Programming Assignment FAQ", "Python Basics with numpy (optional)", "Python Basics with numpy (optional)", "Logistic Regression with a Neural Network mindset", "Pieter Abbeel interview", "Neural Network Basics", "Logistic Regression with a Neural Network mindset"], "title": "Neural Networks Basics"}, {"description": "Learn to build a neural network with one hidden layer, using forward propagation and backpropagation. ", "video": ["Neural Networks Overview", "Neural Network Representation", "Computing a Neural Network's Output", "Vectorizing across multiple examples", "Explanation for Vectorized Implementation", "Activation functions", "Why do you need non-linear activation functions?", "Derivatives of activation functions", "Gradient descent for Neural Networks", "Backpropagation intuition (optional)", "Random Initialization", "Planar data classification with a hidden layer", "Ian Goodfellow interview", "Shallow Neural Networks", "Planar data classification with a hidden layer"], "title": "Shallow neural networks"}, {"description": "Understand the key computations underlying deep learning, use them to build and train deep neural networks, and apply it to computer vision. ", "video": ["Deep L-layer neural network", "Forward Propagation in a Deep Network", "Getting your matrix dimensions right", "Why deep representations?", "Building blocks of deep neural networks", "Forward and Backward Propagation", "Parameters vs Hyperparameters", "What does this have to do with the brain?", "Building your Deep Neural Network: Step by Step", "Deep Neural Network - Application", "Key concepts on Deep Neural Networks", "Building your deep neural network: Step by Step", "Deep Neural Network Application"], "title": "Deep Neural Networks"}], "teach_by": [{"department": null, "name": "Andrew Ng"}, {"department": null, "name": "Head Teaching Assistant - Kian Katanforoosh"}, {"department": null, "name": "Teaching Assistant - Younes Bensouda Mourri"}], "course_info": "About this course: If you want to break into cutting-edge AI, this course will help you do so. Deep learning engineers are highly sought after, and mastering deep learning will give you numerous new career opportunities. Deep learning is also a new \"superpower\" that will let you build AI systems that just weren't possible a few years ago. \n\nIn this course, you will learn the foundations of deep learning. When you finish this class, you will:\n- Understand the major technology trends driving Deep Learning\n- Be able to build, train and apply fully connected deep neural networks \n- Know how to implement efficient (vectorized) neural networks \n- Understand the key parameters in a neural network's architecture \n\nThis course also teaches you how Deep Learning actually works, rather than presenting only a cursory or surface-level description. So after completing it, you will be able to apply deep learning to a your own applications. If you are looking for a job in AI, after this course you will also be able to answer basic interview questions. \n\nThis is the first course of the Deep Learning Specialization.", "level": "Intermediate", "rating": "4.9", "package_num": "1", "target_audience": "Who is this class for: Prerequisites: \n\nExpected:\n- Programming: Basic Python programming skills, with the capability to work effectively with data structures.  \n\nRecommended:\n- Mathematics: Matrix vector operations and notation.\n- Machine Learning: Understanding how to frame a machine learning problem, including how data is represented will be beneficial. If you have taken my Machine Learning Course here, you have much more than the needed level of knowledge. ", "created_by": "deeplearning.ai", "title": "Neural Networks and Deep Learning"}, {"package_name": "Deep Learning Specialization ", "week_data": [{"description": "Learn to implement the foundational layers of CNNs (pooling, convolutions) and to stack them properly in a deep network to solve multi-class image classification problems.", "video": ["Computer Vision", "Edge Detection Example", "More Edge Detection", "Padding", "Strided Convolutions", "Convolutions Over Volume", "One Layer of a Convolutional Network", "Simple Convolutional Network Example", "Pooling Layers", "CNN Example", "Why Convolutions?", "Convolutional Model: step by step", "Convolutional Model: application", "The basics of ConvNets", "Convolutional Model: step by step", "Convolutional model: application"], "title": "Foundations of Convolutional Neural Networks"}, {"description": "Learn about the practical tricks and methods used in deep CNNs straight from the research papers. ", "video": ["Why look at case studies?", "Classic Networks", "ResNets", "Why ResNets Work", "Networks in Networks and 1x1 Convolutions", "Inception Network Motivation", "Inception Network", "Using Open-Source Implementation", "Transfer Learning", "Data Augmentation", "State of Computer Vision", "Keras Tutorial - The Happy House (not graded)", "Residual Networks", "Deep convolutional models", "Residual Networks"], "title": "Deep convolutional models: case studies"}, {"description": "Learn how to apply your knowledge of CNNs to one of the toughest but hottest field of computer vision: Object detection.", "video": ["Object Localization", "Landmark Detection", "Object Detection", "Convolutional Implementation of Sliding Windows", "Bounding Box Predictions", "Intersection Over Union", "Non-max Suppression", "Anchor Boxes", "YOLO Algorithm", "(Optional) Region Proposals", "Car detection with YOLOv2", "Detection algorithms", "Car detection with YOLOv2"], "title": "Object detection"}, {"description": "Discover how CNNs can be applied to multiple fields, including art generation and face recognition. Implement your own algorithm to generate art and recognize faces!", "video": ["What is face recognition?", "One Shot Learning", "Siamese Network", "Triplet Loss", "Face Verification and Binary Classification", "What is neural style transfer?", "What are deep ConvNets learning?", "Cost Function", "Content Cost Function", "Style Cost Function", "1D and 3D Generalizations", "Art generation with Neural Style Transfer", "Face Recognition for the Happy House", "Special applications: Face recognition & Neural style transfer", "Art generation with Neural Style Transfer", "Face Recognition for the Happy House"], "title": "Special applications: Face recognition & Neural style transfer"}], "teach_by": [{"department": null, "name": "Andrew Ng"}, {"department": null, "name": "Head Teaching Assistant - Kian Katanforoosh"}, {"department": null, "name": "Teaching Assistant - Younes Bensouda Mourri"}], "course_info": "About this course: This course will teach you how to build convolutional neural networks and apply it to image data. Thanks to deep learning, computer vision is working far better than just two years ago, and this is enabling numerous exciting applications ranging from safe autonomous driving, to accurate face recognition, to automatic reading of radiology images. \n\nYou will:\n- Understand how to build a convolutional neural network, including recent variations such as residual networks.\n- Know how to apply convolutional networks to visual detection and recognition tasks.\n- Know to use neural style transfer to generate art.\n- Be able to apply these algorithms to a variety of image, video, and other 2D or 3D data.\n\nThis is the fourth course of the Deep Learning Specialization.", "level": "Intermediate", "rating": "4.8", "package_num": "4", "target_audience": "Who is this class for: - Learners that took the first two courses of the specialization. The third course is recommended. \n- Anyone that already has a solid understanding of densely connected neural networks, and wants to learn convolutional neural networks or work with image data.", "created_by": "deeplearning.ai", "title": "Convolutional Neural Networks"}, {"package_name": "Deep Learning Specialization ", "week_data": [{"description": "", "video": ["Train / Dev / Test sets", "Bias / Variance", "Basic Recipe for Machine Learning", "Regularization", "Why regularization reduces overfitting?", "Dropout Regularization", "Understanding Dropout", "Other regularization methods", "Normalizing inputs", "Vanishing / Exploding gradients", "Weight Initialization for Deep Networks", "Numerical approximation of gradients", "Gradient checking", "Gradient Checking Implementation Notes", "Initialization", "Regularization", "Gradient Checking", "Yoshua Bengio interview", "Practical aspects of deep learning", "Initialization", "Regularization", "Gradient Checking"], "title": "Practical aspects of Deep Learning"}, {"description": "", "video": ["Mini-batch gradient descent", "Understanding mini-batch gradient descent", "Exponentially weighted averages", "Understanding exponentially weighted averages", "Bias correction in exponentially weighted averages", "Gradient descent with momentum", "RMSprop", "Adam optimization algorithm", "Learning rate decay", "The problem of local optima", "Optimization", "Yuanqing Lin interview", "Optimization algorithms", "Optimization"], "title": "Optimization algorithms"}, {"description": "", "video": ["Tuning process", "Using an appropriate scale to pick hyperparameters", "Hyperparameters tuning in practice: Pandas vs. Caviar", "Normalizing activations in a network", "Fitting Batch Norm into a neural network", "Why does Batch Norm work?", "Batch Norm at test time", "Softmax Regression", "Training a softmax classifier", "Deep learning frameworks", "TensorFlow", "Tensorflow", "Hyperparameter tuning, Batch Normalization, Programming Frameworks", "Tensorflow"], "title": "Hyperparameter tuning, Batch Normalization and Programming Frameworks"}], "teach_by": [{"department": null, "name": "Andrew Ng"}, {"department": null, "name": "Head Teaching Assistant - Kian Katanforoosh"}, {"department": null, "name": "Teaching Assistant - Younes Bensouda Mourri"}], "course_info": "About this course: This course will teach you the \"magic\" of getting deep learning to work well. Rather than the deep learning process being a black box, you will understand what drives performance, and be able to more systematically get good results. You will also learn TensorFlow. \n\nAfter 3 weeks, you will: \n- Understand industry best-practices for building deep learning applications. \n- Be able to effectively use the common neural network \"tricks\", including initialization, L2 and dropout regularization, Batch normalization, gradient checking, \n- Be able to implement and apply a variety of optimization algorithms, such as mini-batch gradient descent, Momentum, RMSprop and Adam, and check for their convergence. \n- Understand new best-practices for the deep learning era of how to set up train/dev/test sets and analyze bias/variance\n- Be able to implement a neural network in TensorFlow. \n\nThis is the second course of the Deep Learning Specialization.", "level": "Beginner", "rating": "4.9", "package_num": "2", "target_audience": "Who is this class for: This class is for:\n- Learners that took the first course of the specialization: \"Neural Networks and Deep Learning\"\n- Anyone that already understands fully-connected neural networks, and wants to learn the practical aspects of making them work well. ", "created_by": "deeplearning.ai", "title": "Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization"}, {"package_name": null, "week_data": [{"description": "Welcome to Algorithms, Part I.", "video": ["Welcome to Algorithms, Part I", "Lecture Slides", "Course Introduction"], "title": "Course Introduction"}, {"description": "We illustrate our basic approach to developing and analyzing algorithms by considering the dynamic connectivity problem. We introduce the union−find data type and consider several implementations (quick find, quick union, weighted quick union, and weighted quick union with path compression). Finally, we apply the union−find data type to the percolation problem from physical chemistry.", "video": ["Overview", "Lecture Slides", "Dynamic Connectivity", "Quick Find", "Quick Union", "Quick-Union Improvements", "Union−Find Applications", "Interview Questions: Union–Find (ungraded)", "Percolation"], "title": "Union−Find"}, {"description": "The basis of our approach for analyzing the performance of algorithms is the scientific method. We begin by performing computational experiments to measure the running times of our programs. We use these measurements to develop hypotheses about performance. Next, we create mathematical models to explain their behavior. Finally, we consider analyzing the memory usage of our Java programs.", "video": ["Lecture Slides", "Analysis of Algorithms Introduction", "Observations", "Mathematical Models", "Order-of-Growth Classifications", "Theory of Algorithms", "Memory", "Interview Questions: Analysis of Algorithms (ungraded)"], "title": "Analysis of Algorithms"}, {"description": "We consider two fundamental data types for storing collections of objects: the stack and the queue. We implement each using either a singly-linked list or a resizing array. We introduce two advanced Java features—generics and iterators—that simplify client code. Finally, we consider various applications of stacks and queues ranging from parsing arithmetic expressions to simulating queueing systems.", "video": ["Overview", "Lecture Slides", "Stacks", "Resizing Arrays", "Queues", "Generics", "Iterators", "Stack and Queue Applications (optional)", "Interview Questions: Stacks and Queues (ungraded)", "Deques and Randomized Queues"], "title": "Stacks and Queues"}, {"description": "We introduce the sorting problem and Java's Comparable interface. We study two elementary sorting methods (selection sort and insertion sort) and a variation of one of them (shellsort). We also consider two algorithms for uniformly shuffling an array. We conclude with an application of sorting to computing the convex hull via the Graham scan algorithm.", "video": ["Lecture Slides", "Sorting Introduction", "Selection Sort", "Insertion Sort", "Shellsort", "Shuffling", "Convex Hull", "Interview Questions: Elementary Sorts (ungraded)"], "title": "Elementary Sorts"}, {"description": "We study the mergesort algorithm and show that it guarantees to sort any array of n items with at most n lg n compares. We also consider a nonrecursive, bottom-up version. We prove that any compare-based sorting algorithm must make at least  n lg n compares in the worst case. We discuss using different orderings for the objects that we are sorting and the related concept of stability.", "video": ["Overview", "Lecture Slides", "Mergesort", "Bottom-up Mergesort", "Sorting Complexity", "Comparators", "Stability", "Interview Questions: Mergesort (ungraded)", "Collinear Points"], "title": "Mergesort"}, {"description": "We introduce and implement the randomized quicksort algorithm and analyze its performance. We also consider randomized quickselect, a quicksort variant which finds the kth smallest item in linear time. Finally, we consider 3-way quicksort, a variant of quicksort that works especially well in the presence of duplicate keys.", "video": ["Lecture Slides", "Quicksort", "Selection", "Duplicate Keys", "System Sorts", "Interview Questions: Quicksort (ungraded)"], "title": "Quicksort"}, {"description": "We introduce the priority queue data type and an efficient implementation using the binary heap data structure. This implementation also leads to an efficient sorting algorithm known as heapsort. We conclude with an applications of priority queues where we simulate the motion of n particles subject to the laws of elastic collision. ", "video": ["Overview", "Lecture Slides", "APIs and Elementary Implementations", "Binary Heaps", "Heapsort", "Event-Driven Simulation (optional)", "Interview Questions: Priority Queues (ungraded)", "8 Puzzle"], "title": "Priority Queues"}, {"description": "We define an API for symbol tables (also known as associative arrays, maps, or dictionaries) and describe two elementary implementations using a sorted array (binary search) and an unordered list (sequential search). When the keys are Comparable, we define an extended API that includes the additional methods min, max floor, ceiling, rank, and select. To develop an efficient implementation of this API, we study the binary search tree data structure and analyze its performance.", "video": ["Lecture Slides", "Symbol Table API", "Elementary Implementations", "Ordered Operations", "Binary Search Trees", "Ordered Operations in BSTs", "Deletion in BSTs", "Interview Questions: Elementary Symbol Tables (ungraded)"], "title": "Elementary Symbol Tables"}, {"description": "In this lecture, our goal is to develop a symbol table with guaranteed logarithmic performance for search and insert (and many other operations). We begin with 2−3 trees, which are easy to analyze but hard to implement. Next, we consider red−black binary search trees, which we view as a novel way to implement 2−3 trees as binary search trees. Finally, we introduce B-trees, a generalization of 2−3 trees that are widely used to implement file systems.", "video": ["Overview", "Lecture Slides", "2−3 Search Trees", "Red-Black BSTs", "B-Trees (optional)", "Interview Questions: Balanced Search Trees (ungraded)"], "title": "Balanced Search Trees"}, {"description": "We start with 1d and 2d range searching, where the goal is to find all points in a given 1d or 2d interval. To accomplish this, we consider kd-trees, a natural generalization of BSTs when the keys are points in the plane (or higher dimensions). We also consider intersection problems, where the goal is to find all intersections among a set of line segments or rectangles.", "video": ["Lecture Slides", "1d Range Search", "Line Segment Intersection", "Kd-Trees", "Interval Search Trees", "Rectangle Intersection", "Kd-Trees"], "title": "Geometric Applications of BSTs"}, {"description": "We begin by describing the desirable properties of hash function and how to implement them in Java, including a fundamental tenet known as the uniform hashing assumption that underlies the potential success of a hashing application. Then, we consider two strategies for implementing hash tables—separate chaining and linear probing. Both strategies yield constant-time performance for search and insert under the uniform hashing assumption. ", "video": ["Overview", "Lecture Slides", "Hash Tables", "Separate Chaining", "Linear Probing", "Hash Table Context", "Interview Questions: Hash Tables (ungraded)"], "title": "Hash Tables"}, {"description": "We consider various applications of symbol tables including sets, dictionary clients, indexing clients, and sparse vectors.", "video": ["Lecture Slides", "Symbol Table Applications: Sets (optional)", "Symbol Table Applications: Dictionary Clients (optional)", "Symbol Table Applications: Indexing Clients (optional)", "Symbol Table Applications: Sparse Vectors (optional)"], "title": "Symbol Table Applications"}], "teach_by": [{"department": "Computer Science", "name": "Kevin Wayne"}, {"department": "Computer Science", "name": "Robert Sedgewick"}], "course_info": "About this course: This course covers the essential information that every serious programmer needs to know about algorithms and data structures, with emphasis on applications and scientific performance analysis of Java implementations. Part I covers elementary data structures, sorting, and searching algorithms. Part II focuses on graph- and string-processing algorithms.", "level": "Intermediate", "rating": "4.9", "package_num": null, "target_audience": null, "created_by": "Princeton University", "title": "Algorithms, Part I"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "Welcome to the first module of Data Structures and Algorithms! Here we will provide an overview of where algorithms and data structures are used (hint: everywhere) and walk you through a few sample programming challenges. The programming challenges represent an important (and often the most difficult!) part of this specialization because the only way to fully understand an algorithm is to implement it. Writing correct and efficient programs is hard; please don’t be surprised if they don’t work as you planned—our first programs did not work either! We will help you on your journey through the specialization by showing how to implement your first programming challenges. We will also introduce testing techniques that will help increase your chances of passing assignments on your first attempt. In case your program does not work as intended, we will show how to fix it, even if you don’t yet know which test your implementation is failing on.", "video": ["Welcome!", "Overview", "Available Programming Languages", "Solving the Problem (screencast)", "What's Up Next?", "Solving Programming Assignments", "Solving the Problem: Improving the Naive Solution, Testing, Debugging", "Solving the Problem: Improving the Naive Solution, Testing, Debugging", "Stress Testing: the [Almost] Silver Bullet for Debugging", "Stress Test - Implementation", "Stress Test - Find the Test and Debug", "Stress Test - More Testing, Submit and Pass!", "FAQ on Programming Assignments", "Solving Programming Assignments", "Acknowledgements", "A plus B", "Maximum Pairwise Product"], "title": "Welcome"}, {"description": "In this module you will learn that programs based on efficient algorithms can solve the same problem billions of times faster than programs based on naïve algorithms. You will learn how to estimate the running time and memory of an algorithm without even implementing it. Armed with this knowledge, you will be able to compare various algorithms, select the most efficient ones, and finally implement them as our programming challenges!", "video": ["Why Study Algorithms?", "Coming Up", "Problem Overview", "Naive Algorithm", "Efficient Algorithm", "Resources", "Problem Overview and Naive Algorithm", "Efficient Algorithm", "Resources", "Computing Runtimes", "Asymptotic Notation", "Big-O Notation", "Using Big-O", "Resources", "Course Overview", "Logarithms", "Big-O", "Growth rate", "Programming Assignment 1: Introduction"], "title": "Introduction"}, {"description": "In this module you will learn about seemingly naïve yet powerful class of algorithms called greedy algorithms. After you will learn the key idea behind the greedy algorithms, you may feel that they represent the algorithmic Swiss army knife that can be applied to solve nearly all programming challenges in this course. But be warned: with a few exceptions that we will cover, this intuitive idea rarely works in practice! For this reason, it is important to prove that a greedy algorithm always produces an optimal solution before using this algorithm. In the end of this module, we will test your intuition and taste for greedy algorithms by offering several programming challenges.", "video": ["Largest Number", "Car Fueling", "Car Fueling - Implementation and Analysis", "Main Ingredients of Greedy Algorithms", "Celebration Party Problem", "Efficient Algorithm for Grouping Children", "Analysis and Implementation of the Efficient Algorithm", "Long Hike", "Fractional Knapsack - Implementation, Analysis and Optimization", "Review of Greedy Algorithms", "Resources", "Greedy Algorithms", "Fractional Knapsack", "Programming Assignment 2: Greedy Algorithms"], "title": "Greedy Algorithms"}, {"description": "In this module you will learn about a powerful algorithmic technique called Divide and Conquer. Based on this technique, you will see how to search huge databases millions of times faster than using naïve linear search. You will even learn that the standard way to multiply numbers (that you learned in the grade school) is far from the being the fastest! We will then apply the divide-and-conquer technique to design two efficient algorithms (merge sort and quick sort) for sorting huge lists, a problem that finds many applications in practice. Finally, we will show that these two algorithms are optimal, that is, no algorithm can sort faster!", "video": ["Intro", "Linear Search", "Binary Search", "Binary Search Runtime", "Resources", "Problem Overview and Naïve Solution", "Naïve Divide and Conquer Algorithm", "Faster Divide and Conquer Algorithm", "Resources", "What is the Master Theorem?", "Proof of the Master Theorem", "Resources", "Problem Overview", "Selection Sort", "Merge Sort", "Lower Bound for Comparison Based Sorting", "Non-Comparison Based Sorting Algorithms", "Resources", "Overview", "Algorithm", "Random Pivot", "Running Time Analysis (optional)", "Equal Elements", "Final Remarks", "Resources", "Linear Search and Binary Search", "Polynomial Multiplication", "Master Theorem", "Sorting", "Quick Sort", "Programming Assignment 3: Divide and Conquer"], "title": "Divide-and-Conquer"}, {"description": "In this final module of the course you will learn about the powerful algorithmic technique for solving many optimization problems called Dynamic Programming. It turned out that dynamic programming can solve many problems that evade all attempts to solve them using greedy or divide-and-conquer strategy. There are countless applications of dynamic programming in practice: from maximizing the advertisement revenue of a TV station, to search for similar Internet pages, to gene finding (the problem where biologists need to find the minimum number of mutations to transform one gene into another). You will learn how the same idea helps to automatically make spelling corrections and to show the differences between two versions of the same text. ", "video": ["Change Problem", "Resources", "The Alignment Game", "Computing Edit Distance", "Reconstructing an Optimal Alignment", "Resources", "Problem Overview", "Knapsack with Repetitions", "Knapsack without Repetitions", "Final Remarks", "Resources", "Problem Overview", "Subproblems", "Algorithm", "Reconstructing a Solution", "Change Money", "Edit Distance", "Knapsack", "Maximum Value of an Arithmetic Expression", "Programming Assignment 4: Dynamic Programming"], "title": "Dynamic Programming"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}, {"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science and Engineering / Department of Mathematics", "name": "Daniel M Kane"}], "course_info": "About this course: The course covers basic algorithmic techniques and ideas for computational problems arising frequently in practical applications: sorting and searching, divide and conquer, greedy algorithms, dynamic programming. We will learn a lot of theory: how to sort data and how it helps for searching; how to break a large problem into pieces and solve them recursively; when it makes sense to proceed greedily; how dynamic programming is used in genomic studies. You will practice solving computational problems, designing new algorithms, and implementing solutions efficiently (so that they run in less than a second).", "level": "Intermediate", "rating": "4.6", "package_num": "1", "target_audience": "Who is this class for: Programmers with basic experience looking to understand the practical and conceptual underpinnings of algorithms, with the goal of becoming more effective software engineers. Computer science students and researchers as well as interdisciplinary students (studying electrical engineering, mathematics, bioinformatics, etc.) aiming to get more\nprofound understanding of algorithms and hands-on experience implementing them and applying for real-world problems. Applicants who want to prepare for an interview in a high-tech company.", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Algorithmic Toolbox"}, {"package_name": "Deep Learning Specialization ", "week_data": [], "teach_by": [{"department": null, "name": "Andrew Ng"}, {"department": null, "name": "Head Teaching Assistant - Kian Katanforoosh"}, {"department": null, "name": "Teaching Assistant - Younes Bensouda Mourri"}], "course_info": "About this course: This course will teach you how to build models for natural language, audio, and other sequence data. Thanks to deep learning, sequence algorithms are working far better than just two years ago, and this is enabling numerous exciting applications in speech recognition, music synthesis, chatbots, machine translation, natural language understanding, and many others. \n\nYou will:\n- Understand how to build and train Recurrent Neural Networks (RNNs), and commonly-used variants such as GRUs and LSTMs.\n- Be able to apply sequence models to natural language problems, including text synthesis. \n- Be able to apply sequence models to audio applications, including speech recognition and music synthesis.\n\nThis is the fifth and final course of the Deep Learning Specialization.", "level": "Intermediate", "rating": null, "package_num": "5", "target_audience": "Who is this class for: - Learners that took course one, two, and four of the specialization. Course three is also recommended.\n- Anyone that already has a solid understanding of learning with neural networks, including convolutional networks, and wants to learn how to develop recurrent neural networks. ", "created_by": "deeplearning.ai", "title": "Sequence Models"}, {"package_name": "Algorithms Specialization ", "week_data": [{"description": "Introduction; \"big-oh\" notation and asymptotic analysis.", "video": ["Welcome and Week 1 Overview", "Overview, Resources, and Policies", "Lecture slides", "Why Study Algorithms?", "Integer Multiplication", "Karatsuba Multiplication", "About the Course", "Merge Sort: Motivation and Example", "Merge Sort: Pseudocode", "Merge Sort: Analysis", "Guiding Principles for Analysis of Algorithms", "The Gist", "Big-Oh Notation", "Basic Examples", "Big Omega and Theta", "Additional Examples [Review - Optional]", "Problem Set #1", "Programming Assignment #1"], "title": "Week 1"}, {"description": "Divide-and-conquer basics; the master method for analyzing divide and conquer algorithms.", "video": ["Week 2 Overview", "O(n log n) Algorithm for Counting Inversions I", "O(n log n) Algorithm for Counting Inversions II", "Strassen's Subcubic Matrix Multiplication Algorithm", "O(n log n) Algorithm for Closest Pair I [Advanced - Optional]", "O(n log n) Algorithm for Closest Pair II [Advanced - Optional]", "Motivation", "Formal Statement", "Examples", "Proof I", "Interpretation of the 3 Cases", "Proof II", "Optional Theory Problems (Batch #1)", "Problem Set #2", "Programming Assignment #2"], "title": "Week 2"}, {"description": "The QuickSort algorithm and its analysis; probability review.", "video": ["Week 3 Overview", "Quicksort: Overview", "Partitioning Around a Pivot", "Correctness of Quicksort [Review - Optional]", "Choosing a Good Pivot", "Analysis I: A Decomposition Principle", "Analysis II: The Key Insight", "Analysis III: Final Calculations", "Probability Review I", "Probability Review II", "Problem Set #3", "Programming Assignment #3"], "title": "Week 3"}, {"description": "\nLinear-time selection; graphs, cuts, and the contraction algorithm.", "video": ["Week 4 Overview", "Randomized Selection - Algorithm", "Randomized Selection -  Analysis", "Deterministic Selection - Algorithm [Advanced - Optional]", "Deterministic Selection - Analysis I [Advanced - Optional]", "Deterministic Selection - Analysis II [Advanced - Optional]", "Omega(n log n) Lower Bound for Comparison-Based Sorting [Advanced - Optional]", "Graphs and Minimum Cuts", "Graph Representations", "Random Contraction Algorithm", "Analysis of Contraction Algorithm", "Counting Minimum Cuts", "Optional Theory Problems (Batch #2)", "Info and FAQ for final exam", "Problem Set #4", "Programming Assignment #4", "Final Exam"], "title": "Week 4"}], "teach_by": [{"department": "Computer Science", "name": "Tim Roughgarden"}], "course_info": "About this course: The primary topics in this part of the specialization are: asymptotic (\"Big-oh\") notation, sorting and searching, divide and conquer (master method, integer and matrix multiplication, closest pair), and randomized algorithms (QuickSort, contraction algorithm for min cuts).", "level": "Intermediate", "rating": "4.8", "package_num": "1", "target_audience": "Who is this class for: Learners with at least a little bit of programming experience who want to learn the essentials of algorithms.  In a University computer science curriculum, this course is typically taken in the third year.", "created_by": "Stanford University", "title": "Divide and Conquer, Sorting and Searching, and Randomized Algorithms"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "Understand the structure of this class, explore Python as a calculator", "video": ["Introduction", "CodeSkulptor", "Arithmetic Expressions", "Practice Exercises for Expressions (optional)", "Variables", "Saving in CodeSkulptor", "Practice Exercises for Variables and Assignments (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "\"We want... a shrubbery!\"", "Quiz 0"], "title": "Week 0 - Statements, expressions, variables "}, {"description": "Learn the basic constructs of Python programming, create a program that plays a variant of Rock-Paper-Scissors", "video": ["Functions", "Visualizing Functions", "More Operations", "Practice Exercises for Functions (optional)", "Logic and Comparisons", "Conditionals", "Programming Tips - 1", "Practice Exercises for Logic and Conditionals (optional)", "Mini-project Video", "Mini-project Description", "Practice Mini-project: Mystical Octosphere (optional)", "Code Clinic Tips", "Quiz 1", "Rock-paper-scissors-lizard-Spock"], "title": "Week 1 - Functions, logic, conditionals"}, {"description": "Learn the basics of event-driven programming, understand difference between local and global variables, create an interactive program that plays a simple guessing game", "video": ["Event-Driven Programming", "Local vs. Global Variables", "SimpleGUI", "Practice Exercises for Interactive Applications (optional)", "Buttons", "Input Fields", "Visualizing Events", "Programming Tips - 2", "Practice Exercises for Button and Input Fields (optional)", "Mini-project Video", "Mini-project Description", "Practice Mini-project: Magical Octosphere Reloaded (optional)", "Code Clinic Tips", "Quiz 2a", "Quiz 2b", "\"Guess the Number!\""], "title": "Week 2 - Event-driven programming, local/global variables"}, {"description": "Create a canvas in Python, learn how to draw on the canvas, create a digital stopwatch", "video": ["Canvas and Drawing", "String Processing", "Interactive Drawing", "Practice Exercises for Drawing (optional)", "Timers", "Visualizing Drawing and Timers", "Programming Tips - 3", "Practice Exercises for Timers (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Quiz 3a", "Quiz 3b", "Stopwatch: The Game"], "title": "Week 3 - Canvas, drawing, timers"}, {"description": "Learn the basics of lists in Python, model moving objects in Python, recreate the classic arcade game \"Pong\"", "video": ["Lists", "Keyboard Input", "Motion", "Collisions and Reflections", "Practice Exercises for Lists (optional)", "Velocity Control", "Visualizing Lists and Mutation", "Programming Tips - 4", "Practice Exercises for Keyboard (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Quiz 4a", "Quiz 4b", "Pong"], "title": "Week 4 - Lists, keyboard input, the basics of modeling motion"}], "teach_by": [{"department": "Department of Computer Science ", "name": "John Greiner"}, {"department": "Computer Science", "name": "Stephen Wong"}, {"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science", "name": "Joe Warren"}], "course_info": "About this course: This two-part course is designed to help students with very little or no computing background learn the basics of building simple interactive applications. Our language of choice, Python, is an easy-to learn, high-level computer language that is used in many of the computational courses offered on Coursera. To make learning Python easy, we have developed a new browser-based programming environment that makes developing interactive applications in Python simple. These applications will involve windows whose contents are graphical and respond to buttons, the keyboard and the mouse.\n\nIn part 1 of this course, we will introduce the basic elements of programming (such as expressions, conditionals, and functions) and then use these elements to create simple interactive applications such as a digital stopwatch.  Part 1 of this class will culminate in building a version of the classic arcade game \"Pong\".", "level": null, "rating": "4.8", "package_num": "1", "target_audience": "Who is this class for: Recommended Background - A knowledge of high school mathematics is required. The class is designed for students with no prior programming experience.", "created_by": "Rice University", "title": "An Introduction to Interactive Programming in Python (Part 1)"}, {"package_name": null, "week_data": [{"description": "Welcome to Algorithms, Part II.", "video": ["Welcome to Algorithms, Part II", "Lecture Slides", "Course Introduction"], "title": "Introduction  "}, {"description": "We define an undirected graph API and consider the adjacency-matrix and adjacency-lists representations. We introduce two classic algorithms for searching a graph—depth-first search and breadth-first search. We also consider the problem of computing connected components and conclude with related problems and applications.", "video": ["Overview", "Lecture Slides", "Introduction to Graphs", "Graph API", "Depth-First Search", "Breadth-First Search", "Connected Components", "Graph Challenges", "Interview Questions: Undirected Graphs (ungraded)"], "title": "Undirected Graphs"}, {"description": "In this lecture we study directed graphs. We begin with depth-first search and breadth-first search in digraphs and describe applications ranging from garbage collection to web crawling. Next, we introduce a depth-first search based algorithm for computing the topological order of an acyclic digraph. Finally, we implement the Kosaraju−Sharir algorithm for computing the strong components of a digraph.", "video": ["Lecture Slides", "Introduction to Digraphs", "Digraph API", "Digraph Search", "Topological Sort ", "Strong Components", "Interview Questions: Directed Graphs (ungraded)", "WordNet"], "title": "Directed Graphs"}, {"description": "In this lecture we study the minimum spanning tree problem. We begin by considering a generic greedy algorithm for the problem. Next, we consider and implement two classic algorithm for the problem—Kruskal's algorithm and Prim's algorithm. We conclude with some applications and open problems.", "video": ["Overview", "Lecture Slides", "Introduction to MSTs", "Greedy Algorithm", "Edge-Weighted Graph API", "Kruskal's Algorithm", "Prim's Algorithm", "MST Context", "Interview Questions: Minimum Spanning Trees (ungraded)"], "title": "Minimum Spanning Trees"}, {"description": "In this lecture we study shortest-paths problems. We begin by analyzing some basic properties of shortest paths and a generic algorithm for the problem. We introduce and analyze Dijkstra's algorithm for shortest-paths problems with nonnegative weights. Next, we consider an even faster algorithm for DAGs, which works even if the weights are negative. We conclude with the Bellman−Ford−Moore algorithm for edge-weighted digraphs with no negative cycles. We also consider applications ranging from content-aware fill to arbitrage.", "video": ["Lecture Slides", "Shortest Paths APIs", "Shortest Path Properties", "Dijkstra's Algorithm", "Edge-Weighted DAGs", "Negative Weights", "Interview Questions: Shortest Paths (ungraded)", "Seam Carving"], "title": "Shortest Paths"}, {"description": "In this lecture we introduce the maximum flow and minimum cut problems. We begin with the Ford−Fulkerson algorithm. To analyze its correctness, we establish the maxflow−mincut theorem. Next, we consider an efficient implementation of the Ford−Fulkerson algorithm, using the shortest augmenting path rule. Finally, we consider applications, including bipartite matching and baseball elimination.", "video": ["Overview", "Lecture Slides", "Introduction to Maxflow", "Ford–Fulkerson Algorithm", "Maxflow–Mincut Theorem", "Running Time Analysis", "Java Implementation", "Maxflow Applications", "Interview Questions: Maximum Flow (ungraded)", "Baseball Elimination"], "title": "Maximum Flow and Minimum Cut"}, {"description": "In this lecture we consider specialized sorting algorithms for strings and related objects. We begin with a subroutine to sort integers in a small range. We then consider two classic radix sorting algorithms—LSD and MSD radix sorts. Next, we consider an especially efficient variant, which is a hybrid of MSD radix sort and quicksort known as 3-way radix quicksort. We conclude with suffix sorting and related applications.", "video": ["Lecture Slides", "Strings in Java", "Key-Indexed Counting", "LSD Radix Sort", "MSD Radix Sort", "3-way Radix Quicksort", "Suffix Arrays", "Interview Questions: Radix Sorts (ungraded)"], "title": "Radix Sorts"}, {"description": "In this lecture we consider specialized algorithms for symbol tables with string keys. Our goal is a data structure that is as fast as hashing and even more flexible than binary search trees. We begin with multiway tries; next we consider ternary search tries. Finally, we consider character-based operations, including prefix match and longest prefix, and related applications.", "video": ["Overview", "Lecture Slides", "R-way Tries", "Ternary Search Tries", "Character-Based Operations", "Interview Questions: Tries (ungraded)"], "title": "Tries"}, {"description": "In this lecture we consider algorithms for searching for a substring in a piece of text. We begin with a brute-force algorithm, whose running time is quadratic in the worst case. Next, we consider the ingenious Knuth−Morris−Pratt algorithm whose running time is guaranteed to be linear in the worst case. Then, we introduce the Boyer−Moore algorithm, whose running time is sublinear on typical inputs. Finally, we consider the Rabin−Karp fingerprint algorithm, which uses hashing in a clever way to solve the substring search and related problems.", "video": ["Lecture Slides", "Introduction to Substring Search", "Brute-Force Substring Search", "Knuth–Morris–Pratt", "Boyer–Moore", "Rabin–Karp", "Interview Questions: Substring Search (ungraded)", "Boggle"], "title": "Substring Search"}, {"description": "A regular expression is a method for specifying a set of strings. Our topic for this lecture is the famous grep algorithm that determines whether a given text contains any substring from the set. We examine an efficient implementation that makes use of our digraph reachability implementation from Week 1.", "video": ["Overview", "Lecture Slides", "Regular Expressions", "REs and NFAs", "NFA Simulation", "NFA Construction", "Regular Expression Applications", "Interview Questions: Regular Expressions (ungraded)"], "title": "Regular Expressions"}, {"description": "We study and implement several classic data compression schemes, including run-length coding, Huffman compression, and LZW compression. We develop efficient implementations from first principles using a Java library for manipulating binary data that we developed for this purpose, based on priority queue and symbol table implementations from earlier lectures.", "video": ["Lecture Slides", "Introduction to Data Compression", "Run-Length Coding", "Huffman Compression", "LZW Compression", "Interview Questions: Data Compression (ungraded)", "Burrows–Wheeler"], "title": "Data Compression"}, {"description": "Our lectures this week are centered on the idea of problem-solving models like maxflow and shortest path, where a new problem can be formulated as an instance of one of those problems, and then solved with a classic and efficient algorithm. To complete the course, we describe the classic unsolved problem from theoretical computer science that is centered on the concept of algorithm efficiency and guides us in the search for efficient solutions to difficult problems. ", "video": ["Overview", "Lecture Slides", "Introduction to Reductions", "Designing Algorithms", "Establishing Lower Bounds", "Classifying Problems", "Interview Questions: Reductions (ungraded)"], "title": "Reductions"}, {"description": "The quintessential problem-solving model is known as linear programming, and the simplex method for solving it is one of the most widely used algorithms. In this lecture, we given an overview of this central topic in operations research and describe its relationship to algorithms that we have considered.", "video": ["Lecture Slides", "Brewer's Problem", "Simplex Algorithm", "Simplex Implementations", "Linear Programming Reductions", "Interview Questions: Linear Programming (ungraded)"], "title": "Linear Programming (optional)"}, {"description": "Is there a universal problem-solving model to which all problems that we would like to solve reduce and for which we know an efficient algorithm? You may be surprised to learn that we do no know the answer to this question. In this lecture we introduce the complexity classes P, NP, and NP-complete, pose the famous P = NP question, and consider implications in the context of algorithms that we have treated in this course.", "video": ["Lecture Slides", "Introduction to Intractability", "Search Problems", "P vs. NP", "Classifying Problems", "NP-Completeness", "Coping with Intractability ", "Interview Questions: Intractability (ungraded)"], "title": "Intractability"}], "teach_by": [{"department": "Computer Science", "name": "Robert Sedgewick"}, {"department": "Computer Science", "name": "Kevin Wayne"}], "course_info": "About this course: This course covers the essential information that every serious programmer needs to know about algorithms and data structures, with emphasis on applications and scientific performance analysis of Java implementations. Part I covers elementary data structures, sorting, and searching algorithms. Part II focuses on graph- and string-processing algorithms.", "level": "Intermediate", "rating": "4.9", "package_num": null, "target_audience": "Who is this class for: While this course was originally designed for first- and second-year undergraduates, it is appropriate not only for college students but also for professionals. Two-thirds of our learners are college graduates working in industry.", "created_by": "Princeton University", "title": "Algorithms, Part II"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "In this module, you will learn about the basic data structures used throughout the rest of this course.  We start this module by looking in detail at the fundamental building blocks: arrays and linked lists. From there, we build up two important data structures: stacks and queues. Next, we look at trees: examples of how they’re used in Computer Science, how they’re implemented, and the various ways they can be traversed. Once you’ve completed this module, you will be able to implement any of these data structures, as well as have a solid understanding of the costs of the operations, as well as the tradeoffs involved in using each data structure.", "video": ["Welcome", "Arrays", "Singly-Linked Lists", "Doubly-Linked Lists", "Slides and External References", "Stacks", "Queues", "Slides and External References", "Trees", "Tree Traversal", "Slides and External References", "Basic Data Structures", "Available Programming Languages", "FAQ on Programming Assignments", "Acknowledgements", "Programming Assignment 1: Basic Data Structures"], "title": "Basic Data Structures"}, {"description": "In this module, we discuss Dynamic Arrays: a way of using arrays when it is unknown ahead-of-time how many elements will be needed. Here, we also discuss amortized analysis: a method of determining the amortized cost of an operation over a sequence of operations. Amortized analysis is very often used to analyse performance of algorithms when the straightforward analysis produces unsatisfactory results, but amortized analysis helps to show that the algorithm is actually efficient. It is used both for Dynamic Arrays analysis and will also be used in the end of this course to analyze Splay trees.", "video": ["Dynamic Arrays", "Amortized Analysis: Aggregate Method", "Amortized Analysis: Banker's Method", "Amortized Analysis: Physicist's Method", "Amortized Analysis: Summary", "Slides and External References", "Dynamic Arrays and Amortized Analysis"], "title": "Dynamic Arrays and Amortized Analysis"}, {"description": "We start this module by considering priority queues which are used to efficiently schedule jobs, either in the context of a computer operating system or in real life, to sort huge files, which is the most important building block for any Big Data processing algorithm, and to efficiently compute shortest paths in graphs, which is a topic we will cover in our next course. For this reason, priority queues have built-in implementations in many programming languages, including C++, Java, and Python. We will see that these implementations are based on a beautiful idea of storing a complete binary tree in an array that allows to implement all priority queue methods in just few lines of code. We will then switch to disjoint sets data structure that is used, for example, in dynamic graph connectivity and image processing. We will see again how simple and natural ideas lead to an implementation that is both easy to code and very efficient. By completing this module, you will be able to implement both these data structures efficiently from scratch.", "video": ["Introduction", "Naive Implementations of Priority Queues", "Slides", "Binary Trees", "Tree Height Remark", "Basic Operations", "Complete Binary Trees", "Pseudocode", "Slides and External References", "Heap Sort", "Building a Heap", "Final Remarks", "Slides and External References", "Overview", "Naive Implementations", "Slides and External References", "Trees for Disjoint Sets", "Union by Rank", "Path Compression", "Analysis (Optional)", "Slides and External References", "Priority Queues and Disjoint Sets", "Priority Queues: Quiz", "Quiz: Disjoint Sets", "Programming Assignment 2: Priority Queues and Disjoint Sets "], "title": "Priority Queues and Disjoint Sets"}, {"description": "In this module you will learn about very powerful and widely used technique called hashing. Its applications include implementation of programming languages, file systems, pattern search, distributed key-value storage and many more. You will learn how to implement data structures to store and modify sets of objects and mappings from one type of objects to another one. You will see that naive implementations either consume huge amount of memory or are slow, and then you will learn to implement hash tables that use linear memory and work in O(1) on average! In the end, you will learn how hash functions are used in modern disrtibuted systems and how they are used to optimize storage of services like Dropbox, Google Drive and Yandex Disk!", "video": ["Applications of Hashing", "Analysing Service Access Logs", "Direct Addressing", "List-based Mapping", "Hash Functions", "Chaining Scheme", "Chaining Implementation and Analysis", "Hash Tables", "Slides and External References", "Phone Book Problem", "Phone Book Problem - Continued", "Universal Family", "Hashing Integers", "Proof: Upper Bound for Chain Length (Optional)", "Proof: Universal Family for Integers (Optional)", "Hashing Strings", "Hashing Strings - Cardinality Fix", "Slides and External References", "Search Pattern in Text", "Rabin-Karp's Algorithm", "Optimization: Precomputation", "Optimization: Implementation and Analysis", "Slides and External References", "Instant Uploads and Storage Optimization in Dropbox", "Distributed Hash Tables", "Slides and External References", "Hashing", "Hash Tables and Hash Functions", "Programming Assignment 3: Hash Tables"], "title": "Hash Tables"}, {"description": "In this module we study binary search trees, which are a data structure for doing searches on dynamically changing ordered sets. You will learn about many of the difficulties in accomplishing this task and the ways in which we can overcome them. In order to do this you will need to learn the basic structure of binary search trees, how to insert and delete without destroying this structure, and how to ensure that the tree remains balanced.", "video": ["Introduction", "Search Trees", "Basic Operations", "Balance", "Slides and External References", "AVL Trees", "AVL Tree Implementation", "Split and Merge", "Slides and External References", "Binary Search Trees"], "title": "Binary Search Trees"}, {"description": "In this module we continue studying binary search trees. We study a few non-trivial applications. We then study the new kind of balanced search trees - Splay Trees. They adapt to the queries dynamically and are optimal in many ways.", "video": ["Applications", "Slides and External References", "Splay Trees: Introduction", "Splay Trees: Implementation", "(Optional) Splay Trees: Analysis", "Slides and External References", "Splay Trees", "Programming Assignment 4: Binary Search Trees"], "title": "Binary Search Trees 2"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Department of Computer Science and Engineering / Department of Mathematics", "name": "Daniel M Kane"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}], "course_info": "About this course: A good algorithm usually comes together with a set of good data structures that allow the algorithm to manipulate the data efficiently. In this course, we consider the common data structures that are used in various computational problems. You will learn how these data structures are implemented in different programming languages and will practice implementing them in our programming assignments. This will help you to understand what is going on inside a particular built-in implementation of a data structure and what to expect from it. You will also learn typical use cases for these data structures.\n\nA few examples of questions that we are going to cover in this class are the following:\n1. What is a good strategy of resizing a dynamic array?\n2. How priority queues are implemented in C++, Java, and Python?\n3. How to implement a hash table so that the amortized running time of all operations is O(1) on average?\n4. What are good strategies to keep a binary tree balanced? \n\nYou will also learn how services like Dropbox manage to upload some large files instantly and to save a lot of storage space!", "level": "Intermediate", "rating": "4.6", "package_num": "2", "target_audience": "Who is this class for: Programmers with basic experience looking to understand the practical and conceptual underpinnings of algorithms, with the goal of becoming more effective software engineers. Computer science students and researchers as well as interdisciplinary students (studying electrical engineering, mathematics, bioinformatics, etc.) aiming to get more\nprofound understanding of algorithms and hands-on experience\nimplementing them and applying for real-world problems. Applicants who\nwant to prepare for an interview in a high-tech company.", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Data Structures"}, {"package_name": null, "week_data": [{"description": "Course introduction and overview, the roles of abstraction and implementation in systems design, the road ahead.", "video": ["Module 0: Introduction Roadmap", "Unit 0.0: Introduction ", "Unit 0.1: The Road Ahead", "Unit 0.2: From Nand to Hack", "Unit 0.3: From Hack to Tetris", "Unit 0.4: Project 0 Overview", "Project 0"], "title": "Introduction"}, {"description": "We will start with a brief introduction of Boolean algebra, and learn how Boolean functions can be physically implemented using logic gates. We will then learn how to specify gates and chips using a Hardware Description Language (HDL), and how to simulate the behaviour of the resulting chip specifications using a hardware simulator. This background will set the stage for Project 1, in which you will build, simulate, and test 15 elementary logic gates. The chipset that you will build this module will be later used to construct the computer's Arithmetic Logic Unit (ALU) and memory system. This will be done in modules 2 and 3, respectively.", "video": ["Module 1: Boolean Functions and Gate Logic Roadmap", "Unit 1.1: Boolean Logic", "Unit 1.2: Boolean Functions Synthesis", "Unit 1.3: Logic Gates", "Unit 1.4: Hardware Description Language", "Unit 1.5: Hardware Simulation", "Unit 1.6: Multi-Bit Buses", "Unit 1.7: Project 1 Overview", "Unit 1.8: Perspectives ", "Project 1"], "title": "Boolean Functions and Gate Logic"}, {"description": "General Course Information", "video": ["Course Overview", "Textbook", "FAQ", "Promo Video"], "title": "General Course Information"}, {"description": "Using the chipset that we've built in the previous module, we will now proceed to build a family of adders -- chips designed to add numbers. We will then take a big step forward and build an Arithmetic Logic Unit. The ALU, which is designed to perform a whole set of arithmetic and logical operations, is the computer's calculating brain. Later in the course we will use this ALU as the centerpiece chip from which we will build the computer's Central Processing Unit, or CPU. Since all these chips operate on binary numbers (0's and 1's), we will start this module with a general overview of binary arithmetic, and only then delve into building the ALU.", "video": ["Module 2: Boolean Arithmetic and the ALU Roadmap", "Unit 2.1: Binary Numbers", "Unit 2.2: Binary Addition", "Unit 2.3: Negative Numbers", "Unit 2.4: Arithmetic Logic Unit", "Unit 2.5: Project 2 Overview", "Unit 2.6: Perspectives", "Project 2"], "title": "Boolean Arithmetic and the ALU"}, {"description": "Having built the computer's ALU, this module we turn to building the computer's main memory unit, also known as Random Access Memory, or RAM. This will be done gradually, going bottom-up from elementary flip-flop gates to one-bit registers to n-bit registers to a family of RAM chips. Unlike the computer's processing chips, which are based on combinational logic, the computer's memory logic requires a clock-based sequential logic. We will start with an overview of this theoretical background, and then move on to build our memory chipset.", "video": ["Module 3: Memory Roadmap", "Unit 3.1: Sequential Logic", "Unit 3.2: Flip Flops", "Unit 3.3: Memory Units", "Unit 3.4: Counters", "Unit 3.5: Project 3 Overview", "Unit 3.6: Perspectives", "Project 3"], "title": "Memory"}, {"description": "A critically important aspect of building a new computer system is designing the low-level machine language, or instruction set, with which the computer can be instructed to do various things. As it turns out, this can be done before the computer itself is actually built. For example, we can write a Java program that emulates the yet-to-be-built computer, and then use it to emulate the execution of programs written in the new machine language. Such experiments can give us a good appreciation of the bare bone \"look and feel\" of the new computer, and lead to decisions that may well change and improve both the hardware and the language designs. Taking a similar approach, in this module we assume that the Hack computer and machine language have been built, and write some low-level programs using the Hack machine language. We will then use a supplied CPU Emulator (a computer program) to test and execute our programs. This experience will give you a taste of low-level programming, as well as a solid hands-on overview of the Hack computer platform.", "video": ["Module 4: Machine Language Roadmap", "Unit 4.1: Machine Languages: Overview", "Unit 4.2: Machine Languages: Elements ", "Unit 4.3: The Hack Computer and Machine Language", "Unit 4.4: Hack Language Specification", "Unit 4.5: Input / Output", "Unit 4.6: Hack Programming, Part 1", "Unit 4.7: Hack Programming, Part 2", "Unit 4.8: Hack Programming, Part 3 ", "Unit 4.9: Project 4 Overview ", "Unit 4.10: Perspectives ", "Project 4"], "title": "Machine Language"}, {"description": "Let's recap the last four modules: we've built some elementary logic gates (module 1), and then used them to build an ALU (module 2) and a RAM (module 3). We then played with low-level programming (module 4), assuming that the overall computer is actually available. In this module we assemble all these building blocks into a general-purpose 16-bit computer called Hack. We will start by building the Hack Central Processing Unit (CPU), and we will then integrate the CPU with the RAM, creating a full-blown computer system capable of executing programs written in the Hack machine language.", "video": ["Module 5: Computer Architecture Roadmap", "Unit 5.1: Von Neumann Architechture ", "Unit 5.2: The Fetch-Execute Cycle", "Unit 5.3: Central Processing Unit ", "Unit 5.4: The Hack Computer", "Unit 5.5: Project 5 Overview ", "Unit 5.6: Perspectives ", "Project 5"], "title": "Computer Architecture"}, {"description": "Every computer has a binary machine language, in which instructions are written as series of 0's and 1's, and a symbolic machine language, also known as assembly language, in which instructions are expressed using human-friendly mnemonics. Both languages do exactly the same thing, and are completely equivalent. But, writing programs in assembly is far easier and safer then writing in binary. In order to enjoy this luxury, someone has to translate our symbolic programs into binary code that can execute as-is on the target computer. This translation service is done by an agent called assembler. The assembler can be either a person who carries out the translation manually, or a computer program that automates the process. In this module and final project in the course we learn how to build an assembler. In particular, we'll develop the capability of translating symbolic Hack programs into binary code that can be executed as-is on the Hack platform. Each one of you can choose to accomplish this feat in two different ways: you can either implement an assembler using a high-level language, or you can simulate the assembler's operation using paper and pencil. In both cases we give detailed guidelines about how to carry out your work.", "video": ["Module 6: Assembler Roadmap", "Unit 6.1: Assembly Languages and Assemblers", "Unit 6.2: The Hack Assembly Language", "Unit 6.3: The Assembly Process - Handling Instructions", "Unit 6.4: The Assembly Process - Handling Symbols", "Unit 6.5: Developing a Hack Assembler", "Unit 6.6: Project 6 Overview: Programming Option", "Unit 6.6B: Project 6 Overview: Without Programming", "Unit 6.7: Perspectives", "Project 6"], "title": "Assembler"}], "teach_by": [{"department": "Computer Science", "name": "Shimon Schocken"}, {"department": "Computer Science and Engineering", "name": "Noam  Nisan"}], "course_info": "About this course: What you’ll achieve:\nIn this project-centered course* you will build a modern computer system, from the ground up. We’ll divide this fascinating journey into six hands-on projects that will take you from constructing elementary logic gates all the way through creating a fully functioning general purpose computer. In the process, you will learn - in the most direct and constructive way - how computers work, and how they are designed.\n\nWhat you’ll need:\nThis is a self-contained course: all the knowledge necessary to succeed in the course and build the computer system will be given as part of the learning experience. Therefore, we assume no previous computer science or engineering knowledge, and all learners are welcome aboard. You will need no physical materials, since you will build the computer on your own PC, using a software-based hardware simulator, just like real computers are designed by computer engineers in the field. The hardware simulator, as well as other software tools, will be supplied freely after you enroll in the course.\n\nCourse format:\nThe course consists of six modules, each comprising a series of video lectures, and a project. You will need about 2-3 hours to watch each module's lectures, and about 5-10 hours to complete each one of the six projects. The course can be completed in six weeks, but you are welcome to take it at your own pace. You can watch a TED talk about this course by Googling \"nand2tetris TED talk\".\n\n*About Project-Centered Courses: Project-centered courses are designed to help you complete a personally meaningful real-world project, with your instructor and a community of learners with similar goals providing guidance and suggestions along the way. By actively applying new concepts as you learn, you’ll master the course content more efficiently; you’ll also get a head start on using the skills you gain to make positive changes in your life and career. When you complete the course, you’ll have a finished project that you’ll be proud to use and share.", "level": null, "rating": "4.9", "package_num": null, "target_audience": null, "created_by": "Hebrew University of Jerusalem", "title": "Build a Modern Computer from First Principles: From Nand to Tetris (Project-Centered Course)"}, {"package_name": null, "week_data": [{"description": "This module introduces a powerful process for solving any programming problem—the Seven Steps. You will learn how to approach a programming problem methodically, so you can formulate an algorithm that is specific and correct. You will work through examples with sequences of numbers and graphical patterns to develop the skill of algorithm development.", "video": ["Why You Should Learn to Program", "Overview of the Seven Steps", "Algorithms", "Step 1: Work an Example Yourself", "Step 2: Write Down What You Just Did", "Step 3: Generalize Your Steps", "Step 4: Test Your Algorithm", "Testing an Algorithm for a Numerical Sequence", "Steps 1–4", "A Pattern of Squares", "A Pattern of Squares", "Testing a Pattern of Squares", "Drawing a Rectangle", "Closest Point", "Generalizing Closest Point", "Algorithm Practice", "Next Steps", "Algorithms"], "title": "Introduction"}, {"description": "In this module, you will learn to read code—this means you will be able to execute a piece of code by hand, and clearly illustrate what each statement does and what the state of the program is. Understanding how to read code is the only way to be sure you can write correct code. By the end of this module, you will be able to read and understand code with functions, conditional statements, iteration, and other fundamental techniques.", "video": ["Why You Should Learn to Read Code", "Declaring a Variable", "Assigning a Variable", "Declaring and Assigning a Variable", "Expressions with Common Operators", "Examples of Expressions", "Variables and Expressions", "Using Functions for Abstraction", "Anatomy of a Function", "How to Evaluate a Function", "Execution of Function Calls", "Scope", "Functions", "Printing", "Printing Example", "Printing", "Conditional Statements", "Logical Operators", "If/Else", "Execution of If/Else", "Switch/Case", "Execution of Switch/Case", "Conditional Statements", "Loops for Repetition", "While Loops", "While Loops", "While Loops", "Do/While Loops", "Shorthand", "For Loops", "Equivalent For and While Loops", "Execution of Nested Loops", "Continue and Break", "Execution of Continue", "Loops", "Higher-level Meaning", "Reading Code"], "title": "Reading Code"}, {"description": "Everything is a number to a computer, but types determine the size and interpretation of numbers. In this module you will learn about types beyond integers, both their conceptual representations, and their hardware representations in binary. You will learn basic data types, \"non-number\" types, and complex, custom types, as well as some important caveats, so you will avoid type-related programming mistakes.", "video": ["Introduction to Types", "Converting between Decimal and Binary", "Looking under the Hood", "Decimal, Hex, and Binary", "Basic Data Types", "char", "int", "float and double", "Printing redux", "Types and Formatted Output", "Basic Data Types", "Expressions Have Types", "Type Conversion", "Casting", "Type Conversion", "Overflow and Underflow", "Expressions Have Types", "\"Non-numbers\"", "Strings", "Images", "Sound and Video", "Everything Is a Number", "\"Non-numbers\"", "Structs", "Struct for a Rectangle", "Typedef", "Uses of Typedef", "Enumerated Types", "Enumerated Types", "Complex, Custom Data Types", "Types"], "title": "Types"}, {"description": "You have learned a lot about designing algorithms and the programming concepts that will help you implement them. For this project, you will develop and test your own algorithm for sorting data. This module will reinforce the importance of being specific when you write an algorithm and provide an opportunity for you to do so yourself, for a very common computational task: sorting.", "video": ["Importance of Writing a Specific Algorithm", "Sample PB&J Algorithm with Feedback", "Introduction to Sorting", "Writing a Sorting Algorithm"], "title": "Project"}], "teach_by": [{"department": "Electrical and Computer Engineering", "name": "Andrew D. Hilton"}, {"department": "Electrical and Computer Engineering/Mechanical Engineering", "name": "Genevieve M. Lipp"}, {"department": "Computer Science, Cornell University", "name": "Anne Bracy"}], "course_info": "About this course: Programming is an increasingly important skill, whether you aspire to a career in software development, or in other fields. This course is the first in the specialization Introduction to Programming in C, but its lessons extend to any language you might want to learn. This is because programming is fundamentally about figuring out how to solve a class of problems and writing the algorithm, a clear set of steps to solve any problem in its class. This course will introduce you to a powerful problem-solving process—the Seven Steps—which you can use to solve any programming problem. In this course, you will learn how to develop an algorithm, then progress to reading code and understanding how programming concepts relate to algorithms.", "level": "Beginner", "rating": "4.7", "package_num": null, "target_audience": "Who is this class for: This course is for learners who have an interest in learning how to program, for people with no programming experience or for people with some experience who would like to gain solid fundamentals and a deeper understanding of how to program effectively.", "created_by": "Duke University", "title": "Programming Fundamentals"}, {"package_name": "Cloud Computing Specialization ", "week_data": [{"description": "This course is oriented towards learners with similar backgrounds as juniors and seniors in a CS undergraduate curriculum. Since learners come from various backgrounds, it is critical you view this lecture AND pass the prerequisite test. This will ensure you have many of the assumed prerequisite pieces of knowledge required to enjoy this course. ", "video": ["Orientation Overview", "Introduction to Cloud Computing Concepts, Part 1", "Syllabus", "About the Discussion Forums", "Orientation Quiz", "Orientation Towards Cloud Computing Concepts: Some Basic Computer Science Fundamentals", "Instructions for Taking the Prerequisite Quiz", "Prerequisite Quiz", "Getting to Know Your Classmates ", "Course Learning Community and Social Media", "Week 1 Overview", "Week 1 Introduction", "1.1. Why Clouds?", "1.2. What is a Cloud?", "1.3. Introduction to Clouds: History", "1.4. Introduction to Clouds: What's New in Today's Clouds", "1.5. Introduction to Clouds: New Aspects of Clouds", "1.6. Introduction to Clouds: Economics of Clouds", "2.1. A cloud IS a distributed system", "2.2. What is a distributed system?", "3.1. MapReduce Paradigm", "3.2. MapReduce Examples", "3.3. MapReduce Scheduling", "3.4. MapReduce Fault-Tolerance", "Interview with Sumeet Singh", "Homework 1 Instructions", "Homework 1 Discussion", "Programming Assignment Instructions", "Homework 1"], "title": "Week 1: Orientation, Introduction to Clouds, MapReduce "}, {"description": "Lesson 1: This module teaches how the multicast problem is solved by using epidemic/gossip protocols. It also teaches analysis of such protocols. Lesson 2: This module covers the design of failure detectors, a key component in any distributed system. Membership protocols, which use failure detectors as components, are also covered. Lesson 3: This module covers Grid computing, an important precursor to cloud computing.", "video": ["Week 2 Overview", "Week 2 Introduction", "1.1. Multicast Problem", "1.2. The Gossip Protocol", "1.3. Gossip Analysis", "1.4. Gossip Implementations", "2.1.  What is Group Membership List?", "2.2. Failure Detectors", "2.3. Gossip-Style Membership", "2.4. Which is the best failure detector?", "2.5. Another Probabilistic Failure Detector", "2.6. Dissemination and suspicion", "3.1. Grid Applications", "3.2. Grid Infrastucture", "Interview with William Gropp", "Homework 2 Instructions", "Homework 2 Discussion ", "Homework 2"], "title": "Week 2: Gossip, Membership, and Grids"}, {"description": "P2P systems: This module teaches the detailed design of two classes of peer to peer systems: (a) popular ones including Napster, Gnutella, FastTrack, and BitTorrent; and (b) efficient ones including distributed hash tables (Chord, Pastry, and Kelips). Besides focusing on design, the module also analyzes these systems in detail.", "video": ["Week 3 Overview", "Week 3 Introduction", "1. P2P Systems Introduction", "2. Napster", "3. Gnutella", "4. FastTrack and BitTorrent", "5. Chord", "6. Failures in Chord", "7. Pastry", "8. Kelips", "Blue Waters Supercomputer", "Homework 3 Instructions", "Homework 3 Discussion", "Homework 3"], "title": "Week 3: P2P Systems"}, {"description": "Lesson 1: This module motivates and teaches the design of key-value/NoSQL storage/database systems. We cover the design of two major industry systems: Apache Cassandra and HBase. We also cover the famous CAP theorem.  Lesson 2: Distributed systems are asynchronous, which makes clocks at different machines hard to synchronize. This module first covers various clock synchronization algorithms, and then covers ways of tagging events with causal timestamps that avoid synchronizing clocks. These classical algorithms were invented decades ago, yet are used widely in today’s cloud systems.", "video": ["Week 4 Overview", "Week 4 Introduction", "1.1. Why Key-Value/NOSQL?", "1.2. Cassandra", "1.3. The Mystery of X-The Cap Theorem", "1.4. The Consistency Spectrum", "1.5. HBase", "2.1. Introduction and Basics", "2.2. Cristian's Algorithm", "2.3. NTP", "2.4. Lamport Timestamps", "2.5. Vector Clocks", "Interview with Marcos Aguilera", "Optional: Lamport Timestamps (Ukulele Version)", "Homework 4 Instructions", "Homework 4 Discussion ", "Homework 4"], "title": "Week 4: Key-Value Stores, Time, and Ordering"}, {"description": "Lesson 1: This module covers how to calculate a distributed snapshot, leveraging causality again to circumvent the synchronization problem. Lesson 2: This lecture teaches how to order multicasts in any distributed system. Algorithms for assigning timestamp tags to multicasts using various flavors of ordering – FIFO, Causal, and Total – are covered. The module also covers virtual synchrony, a paradigm that combines reliable multicasts with membership views.  Lesson 3: Consensus is one of the most important problems in a distributed system, enabling multiple machines to agree. This module uses Paxos, one of the most popular consensus solutions used in the industry today. Paxos is not perfect because consensus cannot be solved completely – an optional lecture presents the famous FLP proof of impossibility of consensus. ", "video": ["Week 5 Overview", "Week 5 Introduction", "1.1. What is Global Snapshot?", "1.2. Global Snapshot Algorithm", "1.3. Consistent Cuts", "1.4. Safety and Liveness", "2.1. Multicast Ordering", "2.2. Implementing Multicast Ordering 1", "2.3. Implementing Multicast Ordering 2", "2.4. Reliable Multicast", "2.5. Virtual Synchrony", "3.1. The Consensus Problem", "3.2. Consensus In Synchronous Systems", "3.3. Paxos, Simply", "3.4. The FLP Proof  [OPTIONAL]", "Interview with Tushar Chandra", "Homework 5 Instructions", "Homework 5 Discussion", "Conclusion to Cloud Computing Concepts, Part 1", "Final Exam Instructions", "Final Exam Discussion", "Final Reflection ", "Homework 5", "Gossip Protocol", "Final Exam"], "title": "Week 5: Classical Distributed Algorithms"}], "teach_by": [{"department": "Department of Computer Science", "name": "Indranil Gupta"}], "course_info": "About this course: Cloud computing systems today, whether open-source or used inside companies, are built using a common set of core techniques, algorithms, and design philosophies – all centered around distributed systems. Learn about such fundamental distributed computing \"concepts\" for cloud computing.\n \nSome of these concepts include: clouds, MapReduce, key-value/NoSQL stores, classical distributed algorithms, widely-used distributed algorithms, scalability, trending areas, and much, much more! \n \nKnow how these systems work from the inside out. Get your hands dirty using these concepts with provided homework exercises. In the programming assignments, implement some of these concepts in template code (programs) provided in the C++ programming language. Prior experience with C++ is required.\n \nThe course also features interviews with leading researchers and managers, from both industry and academia.", "level": "Beginner", "rating": "4.5", "package_num": "1", "target_audience": "Who is this class for: Who this class is for: This course is intended for students with similar backgrounds as junior or senior undergraduates in computer science. This course will teach you basic algorithmic and design concepts for distributed systems, as used in today’s cloud systems. Much of the course, including quizzes, is conceptual and not programming oriented. The programming assignment assumes some knowledge of C++ (if you have only Java experience, you should be able to pick up C++ quickly may suffice), and allow you to write distributed algorithms in an emulated distributed system on your own machine. To ensure you have the necessary prerequisites, you need to take the prerequisite quiz and achieve a high passing score (at least 90%, preferably 100%). Based on prior student experiences, the Linux/Unix environment may work better for the programming assignments than Windows. \n \nWho this class is NOT for: This course is NOT intended for those: (1) wishing to get a high level overview of cloud computing (you can use Wikipedia for that); (2) wishing to do detailed programming in a real cloud (the Cloud Capstone and Cloud Applications MOOCs provide you that); (3) who are averse to theoretical and algorithmic concepts; (4) with little or no prior programming experience in C++ or Java; (5) who expect to see industry-quality code in programming assignments (these are play programming assignments focused on allowing you to implement concepts you learn from lectures, and are not intended for immediate deployment); (6) those not familiar with setting up IDEs/compilers, etc., especially for C++; or (7) those who want to rush through lectures and/or videos and attempt quizzes in haste (quizzes are hard, so make sure you view lectures completely and comprehensively before attempting quizzes).\n", "created_by": "University of Illinois at Urbana-Champaign", "title": "Cloud Computing Concepts, Part 1"}, {"package_name": null, "week_data": [{"description": "In this module we look at images and videos as 2-dimensional (2D) and 3-dimensional (3D) signals, and discuss their analog/digital dichotomy. We will also see how the characteristics of an image changes depending on its placement over the electromagnetic spectrum, and how this knowledge can be leveraged in several applications.  ", "video": ["Welcome Class!", "Grading Policy", "Further Reading", "About Us", "Analog v.s. Digital Signals ", "Image and Video Signals ", "Electromagnetic Spectrum ", "Download the slides", "Homework 1"], "title": "Introduction to Image and Video Processing"}, {"description": "In this module we introduce the fundamentals of 2D signals and systems. Topics include complex exponential signals, linear space-invariant systems, 2D convolution, and filtering in the spatial domain.  ", "video": ["MATLAB", "Use of MATLAB for Programming Assignments", "In This Module... ", "2D and 3D Discrete Signals ", "Complex Exponential Signals ", "Linear Shift-Invariant Systems ", "2D Convolution ", "Filtering in the Spatial Domain ", "Download the slides", "Homework 2"], "title": "Signals and Systems"}, {"description": "In this module we look at 2D signals in the frequency domain. Topics include: 2D Fourier transform, sampling, discrete Fourier transform, and filtering in the frequency domain.", "video": ["In this Module...", "2D Fourier Transform ", "Sampling ", "Discrete Fourier Transform ", "Filtering in the Frequency Domain ", "Change of Sampling Rate ", "Download the slides", "Homework 3"], "title": "Fourier Transform and Sampling"}, {"description": "In this module we cover two important topics, motion estimation and color representation and processing. Topics include: applications of motion estimation, phase correlation, block matching, spatio-temporal gradient methods, and fundamentals of color image processing", "video": ["In This Module...", "Applications of Motion Estimation ", "Phase Correlation ", "Block Matching", "Spatio-Temporal Gradient Methods ", "Fundamentals of Color Image Processing", "Download the slides", "Homework 4"], "title": "Motion Estimation"}, {"description": "In this module we cover the important topic of image and video enhancement, i.e., the problem of improving the appearance or usefulness of an image or video. Topics include: point-wise intensity transformation, histogram processing, linear and non-linear noise smoothing, sharpening, homomorphic filtering, pseudo-coloring, and video enhancement.", "video": ["In This Module...", "Introduction ", "Point-wise Intensity Transformations ", "Histogram Processing", "Linear Noise Smoothing ", "Non-linear Noise Smoothing ", "Sharpening ", "Homomorhpic Filtering ", "Pseudo Coloring ", "Video Enhancement ", "Download the slides", "Homework 5"], "title": "Image Enhancement"}, {"description": "In this module we study the problem of image and video recovery. Topics include: introduction to image and video recovery, image restoration, matrix-vector notation for images, inverse filtering, constrained least squares (CLS), set-theoretic restoration approaches, iterative restoration algorithms, and spatially adaptive algorithms. ", "video": ["In This Module...", "Examples of Image and Video Recovery ", "Image Restoration ", "Matrix-Vector Notation for Images ", "Inverse Filtering ", "Constrained Least Squares ", "Set-Theoretic Restoration Approaches ", "Iterative Restoration Algorithms ", "Iterative Least-Squares and Constrained Least-Squares ", "Spatially Adaptive Algorithms", "Download the Slides", "Homework 6"], "title": "Image Recovery: Part 1"}, {"description": "In this module we look at the problem of image and video recovery from a stochastic perspective. Topics include: Wiener restoration filter, Wiener noise smoothing filter, maximum likelihood and maximum a posteriori estimation, and Bayesian restoration algorithms. ", "video": ["In This Module...", "Wiener Restoration Filter ", "Wiener v.s. Constrained Least-Squares Restoration Filter ", "Wiener Noise Smoothing Filter ", "Bayesian Restoration Algorithms", "Maximum Likelihood and Maximum A Posteriori Estimation", "Other Restoration Applications", "Download the Slides", "Homework 7"], "title": "Image Recovery : Part 2"}, {"description": "In this module we introduce the problem of image and video compression with a focus on lossless compression. Topics include: elements of information theory, Huffman coding, run-length coding and fax, arithmetic coding, dictionary techniques, and predictive coding. ", "video": ["In This Module...", "Introduction ", "Elements of Information Theory - Part I ", "Elements of Information Theory - Part II ", "Huffman Coding ", "Run-Length Coding and Fax ", "Arithmetic Coding ", "Dictionary Techniques ", "Predictive Coding ", "Download the Slides", "Homework 8"], "title": "Lossless Compression"}, {"description": "In this module we cover fundamental approaches towards lossy image compression. Topics include: scalar and vector quantization, differential pulse-code modulation, fractal image compression, transform coding, JPEG, and subband image compression. ", "video": ["In This Module...", "Scalar Quantization ", "Vector Quantization ", "Differential Pulse-Code Modulation ", "Fractal Image Compression ", "Transform Coding ", "JPEG ", "Subband Image Compression ", "Download the Slides", "Homework 9"], "title": "Image Compression"}, {"description": "In this module we discus video compression with an emphasis on motion-compensated hybrid video encoding and video compression standards including H.261, H.263, H.264, H.265, MPEG-1, MPEG-2, and MPEG-4.", "video": ["In This Module...", "Motion-Compensated Hybrid Video Encoding ", "On Video Compression Standards ", "H.261, H.263, MPEG-1 and MPEG-2 ", "MPEG-4 ", "H.264 ", "H.265 ", "Download the Slides", "Homework 10"], "title": "Video Compression"}, {"description": "In this module we introduce the problem of image and video segmentation, and discuss various approaches for performing segmentation including methods based on intensity discontinuity and intensity similarity, watersheds and K-means algorithms, and other advanced methods. ", "video": ["In This Module...", "Methods Based on Intensity Discontinuity ", "Methods Based on Intensity Similarity ", "Watersheds and K-Means Algorithms ", "Advanced Methods ", "Download the Slides", "Homework 11"], "title": "Image and Video Segmentation"}, {"description": "In this module we introduce the notion of sparsity and discuss how this concept is being applied in image and video processing. Topics include: sparsity-promoting norms, matching pursuit algorithm, smooth reformulations, and an overview of the applications. ", "video": ["In This Module...", "Introduction ", "Sparsity-Promoting Norms ", "Matching Pursuit ", "Smooth Reformulations ", "Applications ", "Download the Slides", "Homework 12"], "title": "Sparsity"}], "teach_by": [{"department": "Department of Electrical Engineering and Computer Science", "name": "Aggelos K. Katsaggelos"}], "course_info": "About this course: In this class you will learn the basic principles and tools used to process images and videos, and how to apply them in solving practical problems of commercial and scientific interests.\n\nDigital images and videos are everywhere these days – in thousands of scientific (e.g., astronomical, bio-medical), consumer, industrial, and artistic applications. Moreover they come in a wide range of the electromagnetic spectrum - from visible light and infrared to gamma rays and beyond. The ability to process image and video signals is therefore an incredibly important skill to master for engineering/science students, software developers, and practicing scientists.   Digital image and video processing continues to enable the multimedia technology revolution we are experiencing today. Some important examples of image and video processing include the removal of degradations images suffer during acquisition (e.g., removing blur from a picture of a fast moving car), and the compression and transmission of images and videos (if you watch videos online, or share photos via a social media website, you use this everyday!), for economical storage and efficient transmission. \n\nThis course will cover the fundamentals of image and video processing.  We will provide a mathematical framework to describe and analyze images and videos as two- and three-dimensional signals in the spatial, spatio-temporal, and frequency domains. In this class not only will you learn the theory behind fundamental processing tasks including image/video enhancement, recovery, and compression - but you will also learn how to perform these key processing tasks in practice using state-of-the-art techniques and tools. We will introduce and use a wide variety of such tools – from optimization toolboxes to statistical techniques. Emphasis on the special role sparsity plays in modern image and video processing will also be given.  In all cases, example images and videos pertaining to specific application domains will be utilized.", "level": null, "rating": "4.6", "package_num": null, "target_audience": null, "created_by": "Northwestern University", "title": "Fundamentals of Digital Image and Video Processing"}, {"package_name": "Probabilistic Graphical Models  Specialization ", "week_data": [{"description": "This module provides an overall introduction to probabilistic graphical models, and defines a few of the key concepts that will be used later in the course.", "video": ["Welcome!", "Overview and Motivation", "Distributions", "Factors", "Basic Definitions"], "title": "Introduction and Overview"}, {"description": "In this module, we define the Bayesian network representation and its semantics. We also analyze the relationship between the graph structure and the independence properties of a distribution represented over that graph. Finally, we give some practical tips on how to model a real-world situation as a Bayesian network.", "video": ["Semantics & Factorization", "Reasoning Patterns", "Flow of Probabilistic Influence", "Conditional Independence", "Independencies in Bayesian Networks", "Naive Bayes", "Application - Medical Diagnosis", "Knowledge Engineering Example - SAMIAM", "Setting Up Your Programming Assignment Environment", "Installing Octave/MATLAB on Windows", "Installing Octave/MATLAB on Mac OS X (10.10 Yosemite and 10.9 Mavericks)", "Installing Octave/MATLAB on Mac OS X (10.8 Mountain Lion and Earlier)", "Installing Octave/MATLAB on GNU/Linux", "More Octave/MATLAB resources", "Basic Operations ", "Moving Data Around ", "Computing On Data ", "Plotting Data ", "Control Statements: for, while, if statements ", "Vectorization ", "Working on and Submitting Programming Exercises ", "Bayesian Network Fundamentals", "Bayesian Network Independencies", "Octave/Matlab installation", "Simple BN Knowledge Engineering"], "title": "Bayesian Network (Directed Models)"}, {"description": "In many cases, we need to model distributions that have a recurring structure. In this module, we describe representations for two such situations. One is temporal scenarios, where we want to model a probabilistic structure that holds constant over time; here, we use Hidden Markov Models, or, more generally, Dynamic Bayesian Networks. The other is aimed at scenarios that involve multiple similar entities, each of whose properties is governed by a similar model; here, we use Plate Models.", "video": ["Overview of Template Models", "Temporal Models - DBNs", "Temporal Models - HMMs", "Plate Models", "Template Models"], "title": "Template Models for Bayesian Networks"}, {"description": "A table-based representation of a CPD in a Bayesian network has a size that grows exponentially in the number of parents. There are a variety of other form of CPD that exploit some type of structure in the dependency model to allow for a much more compact representation. Here we describe a number of the ones most commonly used in practice.", "video": ["Overview: Structured CPDs", "Tree-Structured CPDs", "Independence of Causal Influence", "Continuous Variables", "Structured CPDs", "BNs for Genetic Inheritance", "BNs for Genetic Inheritance PA Quiz"], "title": "Structured CPDs for Bayesian Networks"}, {"description": "In this module, we describe Markov networks (also called Markov random fields): probabilistic graphical models based on an undirected graph representation. We discuss the representation of these models and their semantics. We also analyze the independence properties of distributions encoded by these graphs, and their relationship to the graph structure. We compare these independencies to those encoded by a Bayesian network, giving us some insight on which type of model is more suitable for which scenarios.", "video": ["Pairwise Markov Networks", "General Gibbs Distribution", "Conditional Random Fields", "Independencies in Markov Networks", "I-maps and perfect maps", "Log-Linear Models", "Shared Features in Log-Linear Models", "Markov Networks", "Independencies Revisited", "Markov Networks for OCR"], "title": "Markov Networks (Undirected Models)"}, {"description": "In this module, we discuss the task of decision making under uncertainty. We describe the framework of decision theory, including some aspects of utility functions. We then talk about how decision making scenarios can be encoded as a graphical model called an Influence Diagram, and how such models provide insight both into decision making and the value of information gathering.", "video": ["Maximum Expected Utility", "Utility Functions", "Value of Perfect Information", "Decision Theory", "Decision Making", "Decision Making PA Quiz"], "title": "Decision Making"}, {"description": "This module provides an overview of graphical model representations and some of the real-world considerations when modeling a scenario as a graphical model. It also includes the course final exam.", "video": ["Knowledge Engineering", "Representation Final Exam"], "title": "Knowledge Engineering & Summary"}], "teach_by": [{"department": "School of Engineering", "name": "Daphne Koller"}], "course_info": "About this course: Probabilistic graphical models (PGMs) are a rich framework for encoding probability distributions over complex domains: joint (multivariate) distributions over large numbers of random variables that interact with each other. These representations sit at the intersection of statistics and computer science, relying on concepts from probability theory, graph algorithms, machine learning, and more. They are the basis for the state-of-the-art methods in a wide variety of applications, such as medical diagnosis, image understanding, speech recognition, natural language processing, and many, many more. They are also a foundational tool in formulating many machine learning problems. \n\nThis course is the first in a sequence of three. It describes the two basic PGM representations: Bayesian Networks, which rely on a directed graph; and Markov networks, which use an undirected graph. The course discusses both the theoretical properties of these representations as well as their use in practice. The (highly recommended) honors track contains several hands-on assignments on how to represent some real-world problems. The course also presents some important extensions beyond the basic PGM representation, which allow more complex models to be encoded compactly.", "level": "Advanced", "rating": "4.7", "package_num": "1", "target_audience": null, "created_by": "Stanford University", "title": "Probabilistic Graphical Models 1: Representation"}, {"package_name": "Introduction to Discrete Mathematics for Computer Science Specialization ", "week_data": [{"description": "What is a proof? Why do we care about proofs? Are the boring long tedious arguments usually known as `mathematical proofs' really needed outside the tiny circle of useless theoreticians that pray something called `mathematical rigor'? In this course we will try to show that proofs can be simple, elegant, convincing, useful and (don't laugh) exciting. Later we will try to show different proof techniques and tools, but first of all we should break the barrier and see that yes, one can understand a proof  and one can enjoy the proof. We start with simple puzzles where one small remark can disclose \"what really happens there\" and then the proof becomes almost obvious.", "video": ["Proofs?", "Puzzle: Tile a Chessboard", "Proof by Example", "Impossibility Proof", "Impossibility Proof, II and Conclusion", "Slides", "One Example is Enough", "Splitting an Octagon", "Making Fun in Real Life: Tensegrities", "Know Your Rights", "Nobody Can Win All The Time: Nonexisting Examples", "Slides", "Acknowledgements", "Tiles, dominos, black and white, even and odd", "Puzzle: Two Congruent Parts", "Puzzle: Pluses, Minuses and Splitting"], "title": "Why proofs?"}, {"description": "One example is enough to prove an existential statement, but how to find an example? In many cases the search space is enormous. A computer may help, but some reasoning that narrows the search space, is important both for computer search and for \"bare hands\" work — how can this be done? What do we need to prove if we claim that our solution is optimal?  As usual, we'll practice solving many interactive puzzles. We'll show also some computer programs that help us to construct an example.", "video": ["Magic Squares", "Narrowing the Search", "Multiplicative Magic Squares", "More Puzzles", "Integer Linear Combinations", "Paths In a Graph", "Slides", "N Queens: Brute Force Search", "N Queens: Brute Force Solution Code", "N Queens: Backtracking: Example", "N Queens: Backtracking: Code", "N Queens: Backtracking Solution Code", "Puzzle: 16 Diagonals", "16 Diagonals", "Slides", "Warm-up", "Subset without x and 100-x", "Rooks on a Chessboard", "Knights on a Chessboard", "Bishops on a Chessboard", "Subset without x and 2x", "Slides", "Puzzle: Magic Square 3 times 3", "Puzzle: Different People Have Different Coins", "Puzzle: Free accomodation", "Is there...", "Puzzle: N Queens", "Number of Solutions for the 8 Queens Puzzle", "Maximum Number of Two-digit Integers", "Puzzle: Maximum Number of Rooks on a Chessboard", "Puzzle: Maximum Number of Knights on a Chessboard", "Puzzle: Maximum Number of Bishops on a Chessboard", "Puzzle: Subset without x and 2x"], "title": "How to Find an Example?"}, {"description": "We'll discover two powerful methods of defining objects, proving concepts, and implementing programs — recursion and induction. These two methods are heavily used, in particular, in algorithms — for analysing correctness and running time of algorithms as well as for implementing efficient solutions. You will see that induction is as simple as falling dominos, but allows to prove complex things by decomposing them and moving step by step. You will learn how famous Gauss unexpectedly solved his teacher's problem intended to keep him busy the whole lesson in just two minutes, and in the end you will be able to prove his formula using induction. You will be able to generalize scary arithmetic exercises and then solve them easily using induction.", "video": ["Recursion", "Coin Problem", "Hanoi Towers", "Slides", "Introduction, Lines and Triangles Problem", "Lines and Triangles: Proof by Induction", "Connecting Points", "Odd Points: Proof by Induction", "Sums of Numbers", "Bernoulli's Inequality", "Bernoulli's Inequality", "Coins Problem", "Cutting a Triangle", "Flawed Induction Proofs", "Alternating Sum", "Slides", "Largest Amount that Cannot Be Paid with 5- and 7-Coins", "Pay Any Large Amount with 5- and 7-Coins", "Puzzle: Hanoi Towers", "Number of Moves to Solve the Hanoi Towers Puzzle", "Puzzle: Two Cells of Opposite Colors", "Puzzle: Connect Points", "Induction"], "title": "Recursion and Induction"}, {"description": "We have already invoked mathematical logic when we discussed proofs by examples. This week we will turn mathematical logic full on. We will discuss its basic operations and rules. We will see how logic can play a crucial and indispensable role in proofs. We will discuss how to construct a negation to the statement and we will meet the notion of a counterexamples. We will see tricky and seemingly counterintuitive, but yet (an unintentional pun) logical aspects of mathematical logic. We will see one of the oldest approaches to proving statements: Reductio ad Absurdum. ", "video": ["Examples", "Counterexamples", "Basic Logic Constructs", "If-Then Generalization, Quantification", "Slides", "Reductio ad Absurdum", "Balls in Boxes", "Numbers in Tables", "Pigeonhole Principle", "An (-1,0,1) Antimagic Square", "Handshakes", "Slides", "Puzzle: Always Prime?", "Examples, Counterexamples and Logic", "Puzzle: Balls in Boxes", "Puzzle: Numbers in Boxes", "Puzzle: Numbers on the Chessboard", "Numbers in Boxes", "How to Pick Socks", "Pigeonhole Principle", "Puzzle: An (-1,0,1) Antimagic Square"], "title": "Logic"}, {"description": "\"There are things that never change\". Apart from being just a philosophical statement this phrase turns out to be an important idea that can actually help. In this module we will see how it can help in problem solving. \nThings that do not change are called invariants in mathematics. They form an important tool of proving with numerous applications, including estimating running time of algorithms. We will get some intuition of what they are, see how they can look like and get some practice in using them.", "video": ["Double Counting", "`Homework Assignment' Problem", "Slides", "Coffee with Milk", "Invariants", "More Coffee", "More Coffee", "Debugging Problem", "Slides", "Football Fans", "Termination", "Arthur’s Books", "Slides", "Even and Odd Numbers", "Summing up Digits", "Switching Signs", "Advanced Signs Switching", "Slides", "Puzzle: Sums of Rows and Columns", "'Homework Assignment' Problem", "'Homework Assignment' Problem 2", "Chess Tournaments", "Debugging Problem", "Merging Bank Accounts", "Puzzle: Arthur's Books", "Puzzle: Piece on a Chessboard", "Operations on Even and Odd Numbers", "Puzzle: Summing Up Digits", "Puzzle: Switching Signs", "Recolouring Chessboard"], "title": "Invariants"}, {"description": "In this module we consider a well known 15-puzzle where one needs to restore order among 15 square pieces in a square box. It turns out that the behavior of this puzzle is determined by mathematics: it is solvable if and only if the corresponding permutation is even. We learn the basic properties of even and odd permutations. The task is to write a program that determines whether a permutation is even or odd. There is also a much more difficult bonus task: to write a program that actually computes a solution (sequence of moves) for a given position assuming that this position is solvable.", "video": ["The Rules of 15-Puzzle", "Permutations", "Proof: The Difficult Part", "Mission Impossible", "Classify a Permutation as Even/Odd", "Bonus Track: Fast Classification", "Slides", "Project: The Task", "Even permutations", "Bonus Track: Finding The Sequence of Moves", "Bonus Track: Algorithm for 15-Puzzle", "Quiz Hint: Why Every Even Permutation Is Solvable", "Puzzle: 15", "Transpositions and Permutations", "Neighbor transpositions", "Is a permutation even?"], "title": "Solving a 15-Puzzle"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Computer Science Department", "name": "Vladimir Podolskii"}], "course_info": "About this course: There is a perceived barrier to mathematics: proofs. In this course we will try to convince you that this barrier is more frightening than prohibitive: most proofs are easy to understand if explained correctly, and often they are even fun. We provide an accompanied excursion in the “proof zoo” showing you examples of techniques of different kind applied to different topics.\n\nWe use some puzzles as examples, not because they are “practical”, but because discussing them we learn important reasoning and problem solving techniques that are useful. We hope you enjoy playing with the puzzles and inventing/understandings the proofs.\n\nAs prerequisites we assume only basic math (e.g., we expect you to know what is a square or how to add fractions), basic programming in python (functions, loops, recursion), common sense and curiosity. Our intended audience are all people that work or plan to work in IT, starting from motivated high school students.", "level": "Beginner", "rating": "4.6", "package_num": "1", "target_audience": "Who is this class for: Our intended audience are all people that work or plan to work in IT, starting from motivated high school students. Almost no math background is assumed. ", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "What is a Proof?"}, {"package_name": null, "week_data": [{"description": "In this module, you will understand the course content from a portfolio manager's viewpoint, the incentives for portfolio managers, types of hedge fund, and how to assess fund performance; Also, you will gain insight into market orders, the basic infrastructure of an exchange, and computational components of a hedge fund. ", "video": ["Introduction Video", "Course Overview ", "Consent Form", "Syllabus", "Course Resources", "Python Tutorials", "Key Terms and Support Resources", "Incentives of Portfolio Managers ", "Metrics for Assessing Fund Performance ", "Metrics for Assessing Fund Performance ", "Data Manipulation - Demo", "How Prices Move Up and Down ", "The Order Book ", "Hedge Funds and Arbitrage ", "Computing Inside a Hedge Fund ", "Interview: Paul Jiganti Part 1 ", "Interview: Paul Jiganti Part 2 ", "Interview: Paul Jiganti Part 3 ", "Get More from Georgia Tech", "Portfolio Management and Market Mechanics"], "title": "Portfolio Management and Market Mechanics"}, {"description": "In this module, you will learn how to value a company, and an overview of the theory Capital Assets Pricing Model (CAPM), its assumptions, implications and how you can apply it in fund management. Finally, you will learn to install QSTK Software. ", "video": ["Key Terms and Support Resources", "Intrinsic value: Value of future dividends ", "How and Why News Affects Prices ", "Fundamental Analysis of Company Value ", "Capital Assets Pricing Model ", "CAPM: What is Beta? ", "How Hedge Funds Use CAPM", "QSTK Installation Guide", "Installing QSTK on Windows ", "Installing QSTK on a Mac (no audio)", "Earn a Georgia Tech Badge/Certificate/CEUs", "Install QSTK"], "title": "Company Worth, Capital Assets Pricing Model and QSTK Software Overview"}, {"description": "In this module, you will learn how to work with financial data, create a portfolio and optimize a portfolio using Python with Numpy library as well as  QSTK and the Pandas library.", "video": ["Manipulating Data in Python with Numpy Part 1", "Manipulating Data in Python with Numpy Part 2 ", "Manipulating Data in Python with Numpy Part 3 ", "Manipulating Data in QSTK Part 1", "Manipulating Data in QSTK Part 2", "Interview with Sosnoff Part 1 ", "Interview with Sosnoff Part 2 ", "Interview with Sosnoff Part 3 ", "Assess and Optimize a Portfolio Overview Part 1 ", "Assess and Optimize a Portfolio Overview Part 2 ", "Practice Activity: Portfolio Optimization", "Assess and Optimize a Portfolio"], "title": "Manipulating Data in Python and QSTK"}, {"description": "In this module, you will learn about information may affect equity prices and company value, understand efficient market hypothesis and how event studies work; Also, you will learn about the inputs and outputs of a portfolio optimizer, correlation and covariance, Mean Variance Optimization, and the Efficient Frontier. ", "video": ["Research Papers and Event Profiler Tutorial", "Where Does Information Come From?", "3 Versions of Efficient Markets Hypothesis ", "Event Studies ", "Event Studies in QSTK ", "Optimization Overview ", "The Inputs and Outputs of a Portfolio Optimizer ", "The Importance of Correlation and Covariance ", "The Efficient Frontier ", "How Optimizers Work ", "Review Preparation", "Event Studies"], "title": "Efficient Markets Hypothesis and Event Studies, Portfolio Optimization and the Efficient Frontier"}, {"description": "We will go into more detail in this module about how to read an event study. We will also talk about the differences between actual and adjusted \nhistorical price data, and how to detect and fix wrong data. ", "video": ["Digging into Data", "Actual Vs Adjusted Price", "Data Sanity and Scrubbing ", "How Next Two Reviews Fit Together ", "Specification for This Module's Review", "Suggestions on Implementation of This Module's Review", "Build a Market Simulator"], "title": "Digging into Data"}, {"description": "In this module, you will learn the fundamental law of active portfolio management. We will recap CAPM, and extend it for portfolios. Finally, we're going to look at ways that we can leverage the capital assets \npricing model to manage, maybe even reduce market risk. ", "video": ["Thought Experiment: Coin Flipping ", "The Fundamental Law Part 1 ", "The Fundamental Law Part 2 ", "CAPM Recap, Overview for Portfolios ", "Using CAPM to Reduce Risk ", "How to Assess an Event Study ", "Review Overview ", "Event Study into Simulator"], "title": "The Fundamental Law, CAPM for Portfolios"}, {"description": "In this module, we will dive deeper into a few examples of information feeds, and learn about technical analysis, and look at a few example technical indicators. Finally, we are going to learn about Bollinger Bands. ", "video": ["Example Info Sources ", "Intro to Technical Analysis  ", "Example Indicators", "Bollinger Bands", "Implement Bollinger Bands"], "title": "Information Feeds and Technical Analysis"}, {"description": "In this module, we're going to learn about another measure of a fund performance called Jensen's Alpha, and dig deeper into back testing. We will also take a sneak peek at machine learning. ", "video": ["Jensen's Alpha ", "More About Back Testing ", "Brief Introduction to Machine Learning", "Where to go from here", "Event Study with Bollinger Bands", "Bollinger Band-based trading"], "title": "Jensen's Alpha, Back Testing and Machine Learning"}], "teach_by": [{"department": "School of Interactive Computing", "name": "Dr. Tucker Balch"}], "course_info": "About this course: Why do the prices of some companies’ stocks seem to move up and down together while others move separately? What does portfolio “diversification” really mean and how important is it? What should the price of a stock be? How can we discover and exploit the relationships between equity prices automatically? We’ll examine these questions, and others, from a computational point of view. You will learn many of the principles and algorithms that hedge funds and investment professionals use to maximize return and reduce risk in equity portfolios.", "level": null, "rating": "4.4", "package_num": null, "target_audience": null, "created_by": "Georgia Institute of Technology", "title": "Computational Investing, Part I"}, {"package_name": "Functional Programming in Scala Specialization ", "week_data": [{"description": "Get up and running with Scala on your computer. Complete an example assignment to familiarize yourself with our unique way of submitting assignments. In this week, we'll bridge the gap between data parallelism in the shared memory scenario (learned in the Parallel Programming course, prerequisite) and the distributed scenario. We'll look at important concerns that arise in distributed systems, like latency and failure. We'll go on to cover the basics of Spark, a functionally-oriented framework for big data processing in Scala. We'll end the first week by exercising what we learned about Spark by immediately getting our hands dirty analyzing a real-world data set.", "video": ["Tools setup", "Eclipse tutorial", "Intellij IDEA Tutorial", "Sbt tutorial", "Submitting solutions", "Example", "Introduction, Logistics, What You'll Learn", "Data-Parallel to Distributed Data-Parallel", "Latency", "RDDs, Spark's Distributed Collection", "RDDs: Transformation and Actions", "Evaluation in Spark: Unlike Scala Collections!", "Cluster Topology Matters!", "Wikipedia", "Wikipedia"], "title": "Getting Started + Spark Basics"}, {"description": "This week, we'll look at a special kind of RDD called pair RDDs. With this specialized kind of RDD in hand, we'll cover essential operations on large data sets, such as reductions and joins.", "video": ["Reduction Operations", "Pair RDDs", "Transformations and Actions on Pair RDDs", "Joins", "StackOverflow (2 week long assignment)", "StackOverflow (2 week long assignment)"], "title": "Reduction Operations & Distributed Key-Value Pairs"}, {"description": "This week we'll look at some of the performance implications of using operations like joins. Is it possible to get the same result without having to pay for the overhead of moving data over the network? We'll answer this question by delving into how we can partition our data to achieve better data locality, in turn optimizing some of our Spark jobs.", "video": ["Shuffling: What it is and why it's important", "Partitioning", "Optimizing with Partitioners", "Wide vs Narrow Dependencies"], "title": "Partitioning and Shuffling"}, {"description": "With our newfound understanding of the cost of data movement in a Spark job, and some experience optimizing jobs for data locality last week, this week we'll focus on how we can more easily achieve similar optimizations. Can structured data help us? We'll look at Spark SQL and its powerful optimizer which uses structure to apply impressive optimizations. We'll move on to cover DataFrames and Datasets, which give us a way to mix RDDs with the powerful automatic optimizations behind Spark SQL.", "video": ["Structured vs Unstructured Data", "Spark SQL", "DataFrames (1)", "DataFrames (2)", "Datasets", "Time Usage", "Time Usage"], "title": "Structured data: SQL, Dataframes, and Datasets"}], "teach_by": [{"department": "EPFL", "name": "Dr. Heather Miller"}], "course_info": "About this course: Manipulating big data distributed over a cluster using functional concepts is rampant in industry, and is arguably one of the first widespread industrial uses of functional ideas. This is evidenced by the popularity of MapReduce and Hadoop, and most recently Apache Spark, a fast, in-memory distributed collections framework written in Scala. In this course, we'll see how the data parallel paradigm can be extended to the distributed case, using Spark throughout. We'll cover Spark's programming model in detail, being careful to understand how and when it differs from familiar programming models, like shared-memory parallel collections or sequential Scala collections. Through hands-on examples in Spark and Scala, we'll learn when important issues related to distribution like latency and network communication should be considered and how they can be addressed effectively for improved performance.\n\nLearning Outcomes. By the end of this course you will be able to:\n\n- read data from persistent storage and load it into Apache Spark,\n- manipulate data with Spark and Scala,\n- express algorithms for data analysis in a functional style, \n- recognize how to avoid shuffles and recomputation in Spark,\n\nRecommended background: You should have at least one year programming experience. Proficiency with Java or C# is ideal, but experience with other languages such as C/C++, Python, Javascript or Ruby is also sufficient. You should have some familiarity using the command line. This course is intended to be taken after Parallel Programming: https://www.coursera.org/learn/parprog1.", "level": null, "rating": "4.6", "package_num": "4", "target_audience": null, "created_by": "École Polytechnique Fédérale de Lausanne", "title": "Big Data Analysis with Scala and Spark"}, {"package_name": null, "week_data": [{"description": "Welcome to the course! During Week 1, we are going to introduce you to the course (go through the Introduction, that’s very important). Then we shall start our work: getting acquainted with Arduino, the development environment and our first components. You will learn how to assemble circuits on a breadboard and will write your first program and assemble your first device. Don’t forget about the DIY section, which is also very important", "video": ["Trailer", "Introduction", "How to take the course", "How to practice", "Marks", "1.1 Overview of the week", "1.2 How to assemble a circuit on a breadboard circuit?", "1.3. How to communicate the knowledge about the assembled circuit?", "1.4. Measurement of electrical properties", "1.5. Automotise it", "1.6. Let’s get acquainted with Arduino", "1.7. Development tools for Arduino IDE", "1.8 ;-)", "1.9. Translators’ collaborative work", "1.10. First glance at a program", "1.11. First coded material", "1.12. Macrodefinitions, variables, counting loops", "DIY", "External links", "Test №1"], "title": "Week 1"}, {"description": "It’s time to learn how to receive data with the help of sensors. During Week 2, we will teach you how to read off digital and analog signals, exchange data with a computer, create more complex algorithms, and use new output devices.", "video": ["2.1. Week overview", "2.2. First sensor", "2.3. Voltage divider", "2.4. How to read off analog signals", "2.5. Exchanging data through a serial port", "2.6. About a signal", "2.7. Reading off digital signals", "2.8. Boolean expressions and program branching", "2.9. New display devices: buzzer and bar graph", "2.10. Seven-segment display", "2.11. Microchips", "2.12. Output shift register", "2.13. Debugging", "2.14. Usage of modules", "2.15. Monitoring system", "DIY", "External links", "Test №2"], "title": "Week 2"}, {"description": "During Week 3, you will learn to explore the world around you with the help of a distance sensor, and visualize data on a computer. You are also going improve your programming skills by creating a device with moving components. ", "video": ["3.1. Week review", "3.2. IR distance sensor", "3.3. Analog signal recording", "3.4. Fighting the noise", "3.5. Arrays", "3.6. Declaring a function", "3.7. While loop", "3.8. Servo and the library", "3.9. Measuring distance with ultrasound", "3.10. Four symbols through one wire", "3.11. What to look for and where", "3.12. Processing and mapping", "3.13. Arduino ->; I2C -> Multiservo -> 18 servo", "3.14. All-seeing Eye", "DIY", "External links", "Test №3"], "title": "Week 3"}, {"description": "After going through Week 4, you will be able to connect your device to a network, plan its creation beforehand , control heavy loads, and power your device correctly.", "video": ["4.1. Week overview", "4.2. Submersible pump", "4.3. Field transistor and relay", "4.4. Power supply", "4.5. Planning", "4.6. Think first", "4.7. Soil humidity sensor", "4.8. Where do web pages come from", "4.9. How to transmit data to a network", "4.10. How to receive a command from a network", "4.11. Finite-state automaton", "4.12. WaterMe program basics and switch", "4.13. Errors that we often encounter", "4.14. The longest sketch so far", "4.15. How WaterMe works", "DIY", "Practice task 1 (facultative)", "External links", "Test №4"], "title": "Week 4"}, {"description": "Let’s turn one wheel and then two wheels at once, and the robot car will start moving. It’ll be moving along the line or under your control. It could as well be just messing with your hand with which you are trying to control it. ", "video": ["5.1. Week overview", "5.2. Starting the commutator motor", "5.3. Motor driver", "5.4. Motor control expansion board", "5.5. Robot car", "5.6. Hitch", "5.7. Relay algorithm", "5.8. Analog line sensor", "5.9. Running the relay algorithm", "5.10. Regulator", "5.11. Denoting coefficients for a proportional regulator", "5.12. Cube error and alternative regulator", "5.13. Diagnostics", "5.14. Conditional compilation", "5.15. Connecting through Bluetooth", "5.16. SoftwareSerial", "5.17. Joystick app and testing", "5.18. Remote control", "5.19. RemoteXY", "5.20. Counting the turns of the wheels", "5.21. External interrupts", "5.22. Having counted the turns of the wheels", "Practice", "Practice task 2 (facultative)", "Links and resources", "Test 5"], "title": "Week 5."}, {"description": "Having learnt to create a step motor, you can create devices which can perform very precise actions. For example, a 3D printer, which we will study in detail and then use to print some components.", "video": ["6.1. Week overview", "6.2. Step motor", "6.3. The structure of a 3D printer and its functions", "6.4. 3D model of a part", "6.5. Getting parts from models", "Final video", "Practice", "Combinations", "Links and resources", "Quiz: Final test"], "title": "Week 6"}], "teach_by": [{"department": "Центр инновационных образовательных технологий МФТИ", "name": "Алексей Перепелкин"}, {"department": "Лаборатория инновационных образовательных технологий МФТИ", "name": "Дмитрий Савицкий"}], "course_info": "About this course: For many years now, people have been improving their tools, studying the forces of nature and bringing them under control, using the energy of the nature to operate their machines. Last century is noted for the creation of machines which can operate other machines. Nowadays the creation of devices that interact with the physical world is available to anyone. \nOur course consists of a series of practical problems on making things that work independently: they make their own decisions, act, move, communicate with each other and people around, and control other devices. We will demonstrate how to assemble such devices and programme them using the Arduino platform as a basis.\nAfter this course, you will be able to create devices that read the data about the external world with a variety of sensors, receive and forward this data to a PC, the Internet and mobile devices, and control indexing and the movement. The creation of such devices will involve design, the study of their components, the assemblage of circuit boards, coding and diagnostics. Along with the creation of the devices themselves, you will perform visualization on a PC, create a web page that will demonstrate one of your devices, and figure out how an FDM 3D-printer is configured and how it functions.   \nBesides those keen on robotics or looking to broaden their horizons and develop their skills, the course will also be useful to anyone facing the task of home and industrial automation, as well as to anyone engaged in industrial design, advertising and art. \nThe course does not require any special knowledge from the participants and is open even to students of upper secondary school. Programming skills and the level of English allowing to read technical documentation would be an advantage, but this is not obligatory.\nThe entire course is dedicated to practice, so the best way for you would be to get hold of some electronics, follow the illustrated examples and experiment on your own.\n\nThe kits can be purchased here: kits.cyberphysica.ru.\n\nTaught by: Alexey Perepelkin, head of Robotics department in the Laboratory of innovative educational technologies at MIPT\nTaught by: Dmitry Savitsky, researcher in the Laboratory of innovative educational technologies at MIPT", "level": "Beginner", "rating": "4.4", "package_num": null, "target_audience": null, "created_by": "Moscow Institute of Physics and Technology", "title": "Building Arduino robots and devices"}, {"package_name": "Algorithms Specialization ", "week_data": [{"description": "Breadth-first and depth-first search; computing strong components; applications.", "video": ["Week 1 Overview", "Overview, Resources, and Policies", "Lecture slides", "Graph Search - Overview", "Breadth-First Search (BFS): The Basics", "BFS and Shortest Paths", "BFS and Undirected Connectivity", "Depth-First Search (DFS): The Basics", "Topological Sort", "Computing Strong Components: The Algorithm", "Computing Strong Components: The Analysis", "Structure of the Web [Optional]", "Optional Theory Problems (Week 1)", "Problem Set #1", "Programming Assignment #1"], "title": "Week 1"}, {"description": "Dijkstra's shortest-path algorithm.", "video": ["Week 2 Overview", "Dijkstra's Shortest-Path Algorithm", "Dijkstra's Algorithm: Examples", "Correctness of Dijkstra's Algorithm", "Dijkstra's Algorithm: Implementation and Running Time", "Optional Theory Problems (Week 2)", "Problem Set #2", "Programming Assignment #2"], "title": "Week 2"}, {"description": "Heaps; balanced binary search trees.", "video": ["Week 3 Overview", "Data Structures: Overview", "Heaps: Operations and Applications", "Heaps: Implementation Details [Advanced - Optional]", "Balanced Search Trees: Operations and Applications", "Binary Search Tree Basics, Part I", "Binary Search Tree Basics, Part II", "Red-Black Trees", "Rotations [Advanced - Optional]", "Insertion in a Red-Black Tree [Advanced]", "Problem Set #3", "Programming Assignment #3"], "title": "Week 3"}, {"description": "Hashing; bloom filters.", "video": ["Week 4 Overview", "Hash Tables: Operations and Applications", "Hash Tables: Implementation Details, Part I", "Hash Tables: Implementation Details, Part II", "Pathological Data Sets and Universal Hashing Motivation", "Universal Hashing: Definition and Example [Advanced - Optional]", "Universal Hashing: Analysis of Chaining [Advanced - Optional]", "Hash Table Performance with Open Addressing [Advanced - Optional]", "Bloom Filters: The Basics", "Bloom Filters: Heuristic Analysis", "Optional Theory Problems (Week 4)", "Info and FAQ for final exam", "Problem Set #4", "Programming Assignment #4", "Final Exam"], "title": "Week 4"}], "teach_by": [{"department": "Computer Science", "name": "Tim Roughgarden"}], "course_info": "About this course: The primary topics in this part of the specialization are: data structures (heaps, balanced search trees, hash tables, bloom filters), graph primitives (applications of breadth-first and depth-first search, connectivity, shortest paths), and their applications (ranging from deduplication to social network analysis).", "level": "Intermediate", "rating": "4.8", "package_num": "2", "target_audience": "Who is this class for: Learners with at least a little bit of programming experience who want to learn the essentials of algorithms.  In a University computer science curriculum, this course is typically taken in the third year.", "created_by": "Stanford University", "title": "Graph Search, Shortest Paths, and Data Structures"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "Graphs arise in various real-world situations as there are road networks, computer networks and, most recently, social networks! If you're looking for the fastest time to get to work, cheapest way to connect set of computers into a network or efficient algorithm to automatically find communities and opinion leaders hot in Facebook, you're going to work with graphs and algorithms on graphs. In this module, you will learn ways to represent a graph as well as basic algorithms for decomposing graphs into parts. In the programming assignment of this module, you will apply the algorithms that you’ve learned to implement efficient programs for exploring mazes, analyzing Computer Science curriculum, and analyzing road networks. In the first week of the module, we focus on undirected graphs.", "video": ["Welcome", "Graph Basics", "Representing Graphs", "Slides and External References", "Exploring Graphs", "Connectivity", "Previsit and Postvisit Orderings", "Slides and External References", "Programming Assignment 1: Decomposition of Graphs"], "title": "Decomposition of Graphs 1"}, {"description": "This week we continue to study graph decomposition algorithms, but now for directed graphs.", "video": ["Directed Acyclic Graphs", "Topological Sort", "Strongly Connected Components", "Computing Strongly Connected Components", "Slides and External References", "Programming Assignment 2: Decomposition of Graphs"], "title": "Decomposition of Graphs 2"}, {"description": "In this module you will study algorithms for finding Shortest Paths in Graphs. These algorithms have lots of applications. When you launch a navigation app on your smartphone like Google Maps or Yandex.Navi, it uses these algorithms to find you the fastest route from work to home, from home to school, etc. When you search for airplane tickets, these algorithms are used to find a route with the minimum number of plane changes. Unexpectedly, these algorithms can also be used to determine the optimal way to do currency exchange, sometimes allowing to earh huge profit! We will cover all these applications, and you will learn Breadth-First Search, Dijkstra's Algorithm and Bellman-Ford Algorithm. These algorithms are efficient and lay the foundation for even more efficient algorithms which you will learn and implement in the Shortest Paths Capstone Project to find best routes on real maps of cities and countries, find distances between people in Social Networks. In the end you will be able to find Shortest Paths efficiently in any Graph. This week we will study Breadth-First Search algorithm.", "video": ["Most Direct Route", "Breadth-First Search", "Breadth-First Search (continued)", "Implementation and Analysis", "Proof of Correctness", "Proof of Correctness (continued)", "Shortest-Path Tree", "Reconstructing the Shortest Path", "Slides and External References", "Programming Assignment 3: Paths in Graphs"], "title": "Paths in Graphs 1"}, {"description": "This week we continue to study Shortest Paths in Graphs. You will learn Dijkstra's Algorithm which can be applied to find the shortest route home from work. You will also learn Bellman-Ford's algorithm which can unexpectedly be applied to choose the optimal way of exchanging currencies. By the end you will be able to find shortest paths efficiently in any Graph.", "video": ["Fastest Route", "Naive Algorithm", "Dijkstra's Algorithm: Intuition and Example", "Dijkstra's Algorithm: Implementation", "Dijkstra's Algorithm: Proof of Correctness", "Dijkstra's Algorithm: Running Time", "Slides and External References", "Currency Exchange", "Currency Exchange: Reduction to Shortest Paths", "Bellman-Ford Algorithm", "Bellman-Ford Algorithm: Proof of Correctness", "Negative Cycles", "Infinite Arbitrage", "Slides and External References", "Programming Assignment 4: Paths in Graphs"], "title": "Paths in Graphs 2"}, {"description": "In this module, we study the minimum spanning tree problem. We will cover two elegant greedy algorithms for this problem: the first one is due to Kruskal and uses the disjoint sets data structure, the second one is due to Prim and uses the priority queue data structure. In the programming assignment for this module you will be computing an optimal way of building roads between cities and an optimal way of partitioning a given set of objects into clusters (a fundamental problem in data mining).", "video": ["Building a Network", "Greedy Algorithms", "Cut Property", "Kruskal's Algorithm", "Prim's Algorithm", "Slides and External References", "Programming Assignment 5: Minimum Spanning Trees"], "title": "Minimum Spanning Trees"}, {"description": "In this module, you will learn Advanced Shortest Paths algorithms that work in practice 1000s (up to 25000) of times faster than the classical Dijkstra's algorithm on real-world road networks and social networks graphs. You will work on a Programming Project based on these algorithms. You will find the shortest paths on the real maps of parts of US and the shortest paths connecting people in the social networks. We encourage you not only to use the ideas from this module's lectures in your implementations, but also to come up with your own ideas for speeding up the algorithm! We encourage you to compete on the forums to see whose implementation is the fastest one :)", "video": ["Programming Project: Introduction", "Bidirectional Search", "Six Handshakes", "Bidirectional Dijkstra", "Finding Shortest Path after Meeting in the Middle", "Computing the Distance", "Slides and External References", "A* Algorithm", "Performance of A*", "Bidirectional A*", "Potential Functions and Lower Bounds", "Landmarks (Optional)", "Slides and External References", "Highway Hierarchies and Node Importance", "Preprocessing", "Witness Search", "Query", "Proof of Correctness", "Node Ordering", "Slides and External Refernces", "Bidirectional Dijkstra, A* and Contraction Hierarchies", "Advanced Shortest Paths"], "title": "Advanced Shortest Paths Project (Optional)"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Department of Computer Science and Engineering / Department of Mathematics", "name": "Daniel M Kane"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}], "course_info": "About this course: If you have ever used a navigation service to find optimal route and estimate time to destination, you've used algorithms on graphs. Graphs arise in various real-world situations as there are road networks, computer networks and, most recently, social networks! If you're looking for the fastest time to get to work, cheapest way to connect set of computers into a network or efficient algorithm to automatically find communities and opinion leaders in Facebook, you're going to work with graphs and algorithms on graphs.\n\nIn this course, you will first learn what a graph is and what are some of the most important properties. Then you'll learn several ways to traverse graphs and how you can do useful things while traversing the graph in some order. We will then talk about shortest paths algorithms — from the basic ones to those which open door for 1000000 times faster algorithms used in Google Maps and other navigational services. You will use these algorithms if you choose to work on our Fast Shortest Routes industrial capstone project. We will finish with minimum spanning trees which are used to plan road, telephone and computer networks and also find applications in clustering and approximate algorithms.", "level": "Intermediate", "rating": "4.7", "package_num": "3", "target_audience": null, "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Algorithms on Graphs"}, {"package_name": null, "week_data": [{"description": "In this module, you will learn to write code and do your first assignment in the Practice Programming Environment. You have practiced the first four steps of the Seven Steps in the previous course, and you will review them here before learning Step 5: Translating Your Algorithm to Code. Expert programmers spend most of their time planning before they begin writing code, and you will learn to do the same!", "video": ["Introduction to Writing Code", "Planning", "Revisiting Step 1", "Revisiting Step 2", "Step 3: Generalizing Values", "Step 3: Repetitions", "Step 3: Conditional Behavior", "Revisiting Step 4", "Intersection of Two Rectangles", "Steps 1–4 Review", "Translation to Code", "Translating Algorithm Components", "Translating the Intersection Algorithm to Code", "Completed Rectangle Intersection Code", "Top-down Design and Composability", "Stars Example", "Step 5 Concepts", "Introduction to the Programming Environment", "Introduction to the Programming Environment", "UNIX basics", "More UNIX Commands", "Editing Files with Emacs", "Emacs", "Git", "More about Git", "GitHub", "How Assignments Work in This Course", "Next Steps", "Using the Programming Environment", "Assignment 01_apple", "Assignments 02_code1 and 03_code2"], "title": "Writing Code"}, {"description": "Now that you know how to plan an algorithm and translate it to code, you need to learn how to compile and run it! You will learn about the compiler, which takes the code you wrote and translates it into instructions a machine can execute, which you can then run. You will also learn about different options you can give the compiler, as well as different ways to run your program that give you debugging information.", "video": ["Now We Need to Compile", "Compiling Overview", "Compilation Process", "Preprocessing", "Compiling", "\"Hello World\"", "Planning isPrime", "Generalizing isPrime", "Translating isPrime to Code", "Getting Help: man Pages", "Comparing Output with diff", "More about Macros and Header Files", "The Actual Compiler", "Compiler Errors", "Assembling", "Linking", "Compilation Process", "Build Tool: make", "Make", "Compiling with a Makefile", "Fancier make Options", "Running Your Program", "valgrind", "Compiler Options", "Make and Valgrind", "Assignment 04_compile", "Assignment 05_squares", "Assignments 06_rect and 07_retirement"], "title": "Compiling and Running"}, {"description": "Two skills that are crucial to good programming are testing—finding problems with your code, and debugging—fixing them. In this module you will learn systematic ways to identify problems in your code, as well as how to apply the scientific method to fix your program when you do find a bug.", "video": ["Testing Means Finding Bugs", "Black Box Testing", "Test-driven Development", "Practical Tips for Designing Test Cases", "White Box Testing", "Generating Test Cases", "Asserts", "Code Review", "Code Review", "Testing", "Step 7: Debugging", "The Scientific Method", "Accept or Reject Your Hypothesis?", "Debugging", "Finding Problems with Valgrind", "Intro to gdb", "Getting Started with gdb", "Investigating the State of Your Program", "Controlling Execution", "Gathering Information with gdb", "Watchpoints", "Signals", "gdb", "Assignments 08_testing and 09_testing", "Assignment 10_gdb"], "title": "Testing and debugging"}, {"description": "In this module you will begin the project you will complete over the course of the rest of the specialization. At the end of each course, you will write a piece of a program that will calculate the odds of different poker hands winning with a Monte Carlo simulation—a way to calculate complicated probabilities by generating random data.", "video": ["Introduction to the Poker Project", "Poker Project Roadmap", "Rules of Poker", "Assignment c2prj_cards", "Assignment c3prj_testing"], "title": "Project"}], "teach_by": [{"department": "Electrical and Computer Engineering", "name": "Andrew D. Hilton"}, {"department": "Electrical and Computer Engineering/Mechanical Engineering", "name": "Genevieve M. Lipp"}, {"department": "Computer Science, Cornell University", "name": "Anne Bracy"}], "course_info": "About this course: Building on the course Programming Fundamentals, this course will teach you how to write code by first planning what your program should do—an important approach for novice and professional programmers. You will learn how to compile and run your program, and then how to test and debug it. This course builds on the Seven Steps you have already learned and provides a framework for systematically testing for problems and fixing them, so you can find and fix problems efficiently.", "level": "Beginner", "rating": null, "package_num": null, "target_audience": "Who is this class for: This course is for learners who have an interest in learning how to program, for people with no programming experience or for people with some experience who would like to gain solid fundamentals and a deeper understanding of how to program effectively.", "created_by": "Duke University", "title": "Writing, Running, and Fixing Code in C"}, {"package_name": "Algorithms Specialization ", "week_data": [{"description": "Two motivating applications; selected review; introduction to greedy algorithms; a scheduling application; Prim's MST algorithm.", "video": ["Week 1 Overview", "Overview, Resources, and Policies", "Lecture slides", "Application: Internet Routing", "Application: Sequence Alignment", "Introduction to Greedy Algorithms", "Application: Optimal Caching", "Problem Definition", "A Greedy Algorithm", "Correctness Proof - Part I", "Correctness Proof - Part II", "Handling Ties [Advanced - Optional]", "MST Problem Definition", "Prim's MST Algorithm", "Correctness Proof I", "Correctness Proof II", "Proof of Cut Property [Advanced - Optional]", "Fast Implementation I", "Fast Implementation II", "Optional Theory Problems (Week 1)", "Problem Set #1", "Programming Assignment #1"], "title": "Week 1"}, {"description": "Kruskal's MST algorithm and applications to clustering; advanced union-find (optional). ", "video": ["Week 2 Overview", "Kruskal's MST Algorithm", "Correctness of Kruskal's Algorithm", "Implementing Kruskal's Algorithm via Union-Find I", "Implementing Kruskal's Algorithm via Union-Find II", "MSTs: State-of-the-Art and Open Questions [Advanced - Optional]", "Application to Clustering", "Correctness of Clustering Algorithm", "Lazy Unions [Advanced - Optional]", "Union-by-Rank [Advanced - Optional]", "Analysis of Union-by-Rank [Advanced - Optional]", "Path Compression [Advanced - Optional]", "Path Compression: The Hopcroft-Ullman Analysis I [Advanced - Optional]", "Path Compression: The Hopcroft-Ullman Analysis II [Advanced - Optional]", "The Ackermann Function [Advanced - Optional]", "Path Compression: Tarjan's Analysis I [Advanced - Optional]", "Path Compression: Tarjan's Analysis II [Advanced - Optional]", "Optional Theory Problems (Week 2)", "Problem Set #2", "Programming Assignment #2"], "title": "Week 2"}, {"description": "Huffman codes; introduction to dynamic programming.", "video": ["Week 3 Overview", "Introduction and Motivation", "Problem Definition", "A Greedy Algorithm", "A More Complex Example", "Correctness Proof I", "Correctness Proof II", "Introduction: Weighted Independent Sets in Path Graphs", "WIS in Path Graphs: Optimal Substructure", "WIS in Path Graphs: A Linear-Time Algorithm", "WIS in Path Graphs: A Reconstruction Algorithm", "Principles of Dynamic Programming", "Problem Set #3", "Programming Assignment #3"], "title": "Week 3"}, {"description": "Advanced dynamic programming: the knapsack problem, sequence alignment, and optimal binary search trees.", "video": ["Week 4 Overview", "The Knapsack Problem", "A Dynamic Programming Algorithm", "Example [Review - Optional]", "Optimal Substructure", "A Dynamic Programming Algorithm", "Problem Definition", "Optimal Substructure", "Proof of Optimal Substructure", "A Dynamic Programming Algorithm I", "A Dynamic Programming Algorithm II", "Optional Theory Problems (Week 4)", "Info and FAQ for final exam", "Problem Set #4", "Programming Assignment #4", "Final Exam"], "title": "Week 4"}], "teach_by": [{"department": "Computer Science", "name": "Tim Roughgarden"}], "course_info": "About this course: The primary topics in this part of the specialization are: greedy algorithms (scheduling, minimum spanning trees, clustering, Huffman codes) and dynamic programming (knapsack, sequence alignment, optimal search trees).", "level": "Intermediate", "rating": "4.9", "package_num": "3", "target_audience": "Who is this class for: Learners with at least a little bit of programming experience who want to learn the essentials of algorithms.  In a University computer science curriculum, this course is typically taken in the third year.", "created_by": "Stanford University", "title": "Greedy Algorithms, Minimum Spanning Trees, and Dynamic Programming"}, {"package_name": null, "week_data": [{"description": "This module gives the learner a first impression of what discrete mathematics is about, and in which ways its \"flavor\" differs from other fields of mathematics. It introduces basic objects like sets, relations, functions, which form the foundation of discrete mathematics.", "video": ["Introduction to the course", "Exercises for introduction lesson", "Sets, Relations, Functions", "Sets, Relations, Functions", "Sets, relations, and functions"], "title": "Introduction - Basic Objects in Discrete Mathematics"}, {"description": "Even without knowing, the learner has seen some orderings in the past. Numbers are ordered by <=. Integers can be partially ordered by the \"divisible by\" relation. In genealogy, people are ordered by the \"A is an ancestor of B\" relation. This module formally introduces partial orders and proves some fundamental and non-trivial facts about them.", "video": ["Partial orderings: basic notions", "Mirsky's and Dilworth's Theorem", "Partial orders, maximal and minimal elements, chains, antichains", "Partial orders, maximal and minimal elements, chains, antichains"], "title": "Partial Orders"}, {"description": "A big part of discrete mathematics is about counting things. A classic example asks how many different words can be obtained by re-ordering the letters in the word Mississippi. Counting problems of this flavor abound in discrete mathematics discrete probability and also in the analysis of algorithms.", "video": ["How to Count Functions, Injections, Permutations, and Subsets", "Evaluating Simple Sums", "Pascal's Triangle", "Counting Basic Objects", "Counting Basic Objects"], "title": "Enumerative Combinatorics"}, {"description": "The binomial coefficient (n choose k) counts the number of ways to select k elements from a set of size n. It appears all the time in enumerative combinatorics. A good understanding of (n choose k) is also extremely helpful for analysis of algorithms.", "video": ["Combinatorial Identities", "Combinatorial Identities", "Digging Into Pascal's Triangle", "Estimating the Binomial Coefficient", "Excursion to Discrete Probability: Computing the Expected Minimum of k Random Elements from {1,...,n}", "An Eagle's View of Pascal's Triangle"], "title": "The Binomial Coefficient"}, {"description": "", "video": ["Asymptotics and the O( )-Notation", "Basic Facts", "Classes that often occur in complexity theory", "The Big-O-Notation"], "title": "Asymptotics and the O-Notation"}, {"description": "Graphs are arguably the most important object in discrete mathematics. A huge number of problems from computer science and combinatorics can be modelled in the language of graphs. This module introduces the basic notions of graph theory - graphs, cycles, paths, degree, isomorphism.", "video": ["Basic Notions and Examples", "Graph Isomorphism, Degree, Graph Score", "Graphs and Isomorphisms", "Graph Score Theorem", "The Graph Score Theorem", "Graphs, isomorphisms, and the sliding tile puzzle"], "title": "Introduction to Graph Theory"}, {"description": "We continue with graph theory basics. In this module, we introduce trees, an important class of graphs, and several equivalent characterizations of trees. Finally, we present an efficient algorithm for detecting whether two trees are isomorphic.", "video": ["Graphs and Connectivity", "Cycles and Trees", "Cycles and Trees", "Spanning Tree Exchange Graph", "An Efficient Algorithm for Isomorphism of Trees", "Cycles and Trees"], "title": "Connectivity, Trees, Cycles"}, {"description": "Starting with the well-known \"Bridges of Königsberg\" riddle, we prove the well-known characterization of Eulerian graphs. We discuss Hamiltonian paths and give sufficient criteria for their existence with Dirac's and Ore's theorem.", "video": ["Eulerian Cycles", "Hamilton Cycles - Ore's and Dirac's Theorem", "Hamiltonian Cycles and Paths", "Hamiltonian Cycles and Paths"], "title": "Eulerian and Hamiltonian Cycles"}, {"description": "We discuss spanning trees of graphs. In particular we present Kruskal's algorithm for finding the minimum spanning tree of a graph with edge costs. We prove Cayley's formula, stating that the complete graph on n vertices has n^(n-2) spanning trees.", "video": ["Minimum Spanning Trees", "Minimum Spanning Trees", "The Number of Trees on n Vertices", "Counting Trees on n Vertices", "Spanning Trees"], "title": "Spanning Trees"}, {"description": "This module is about flow networks and has a distinctively algorithmic flavor. We prove the maximum flow minimum cut duality theorem.", "video": ["Flow Networks, Flows, Cuts: Basic Notions and Examples", "Flow Networks: The Maxflow - Mincut Theorem", "Network Flows", "Network flow"], "title": "Maximum flow and minimum cut"}, {"description": "We prove Hall's Theorem and Kőnig's Theorem, two important results on matchings in bipartite graphs. With the machinery from flow networks, both have quite direct proofs. Finally, partial orderings have their comeback with Dilworth's Theorem, which has a surprising proof using Kőnig's Theorem.", "video": ["Matchings in Bipartite Graphs - Basic Notions and an Algorithm", "Matchings in Bipartite Graphs: Hall's and König's Theorem", "Matchings in Bipartite Graphs", "Partial Orders: Dilworth's Theorem on Chains and Antichains"], "title": "Matchings in Bipartite Graphs"}], "teach_by": [{"department": "The Department of Computer Science and Engineering", "name": "Dominik Scheder"}], "course_info": "About this course: Discrete mathematics forms the mathematical foundation of computer and information science. It is also a fascinating subject in itself.\n\nLearners will become familiar with a broad range of mathematical objects like sets, functions, relations, graphs, that are omnipresent in computer science. Perhaps more importantly, they will reach a certain level of mathematical maturity - being able to  understand formal statements and their proofs; coming up with rigorous proofs themselves; and coming up with interesting results.\n\nThis course attempts to be rigorous without being overly formal. This means, for every concept we introduce we will show at least one interesting and non-trivial result and give a full proof. However, we will do so without too much formal notation, employing examples and figures whenever possible.\n\nThe main topics of this course are (1) sets, functions, relations, (2) enumerative combinatorics, (3) graph theory, (4) network flow and matchings. It does not cover modular arithmetic, algebra, and logic, since these topics have a slightly different flavor and because there are already several courses on Coursera specifically on these topics.", "level": "Intermediate", "rating": "3.7", "package_num": null, "target_audience": "Who is this class for: The main target audience of this course is undergraduate students from Computer Science, Mathematics, and other related subjects. It is also suited for people with an interest in maths but without much prior formal education therein.", "created_by": "Shanghai Jiao Tong University", "title": "Discrete Mathematics"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to class!</p><p>This course will focus on two questions at the forefront of modern computational biology, along with the algorithmic approaches we will use to solve them in parentheses:</p><ol><li>Weeks 1-2: Where in the Genome Does DNA Replication Begin? (<em>Algorithmic Warmup</em>)</li><li>Weeks 3-4: Which DNA Patterns Play the Role of Molecular Clocks? (<em>Randomized Algorithms</em>)</li></ol><p>Week 5 will consist of a Bioinformatics Application Challenge in which you will get to apply software for finding DNA motifs to a real biological dataset.</p><p>Each of the two chapters in the course is accompanied by a Bioinformatics Cartoon created by Randall Christopher and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. You can find the first chapter's cartoon at the bottom of this message. What does a cryptic message leading to buried treasure have to do with biology? We hope you will join us to find out!</p><p><img src=\"http://bioinformaticsalgorithms.com/images/cover/replication_cropped.jpg\" title=\"Image: http://bioinformaticsalgorithms.com/images/cover/chapter1_cropped.jpg\" width=\"500\"></p><p><a href=\"http://compeau.cbd.cmu.edu\" target=\"_blank\"><img src=\"http://bioinformaticsalgorithms.com/images/Compeau_caricature.jpg\" width =\"150\"></a>       <a href=\"http://cseweb.ucsd.edu/~ppevzner/\" target=\"_blank\"><img src=\"http://bioinformaticsalgorithms.com/images/Pevzner_caricature.jpg\" width =\"150\"></a></p><p>Phillip and Pavel</p>", "video": ["(Check Out Our Wacky Course Intro Video)", "Course Details", "Stepik Interactive Text for Week 1", "Where in the Genome Does DNA Replication Begin? (Part 1) (11:37)", "Where in the Genome Does DNA Replication Begin? (Part 2) (06:24)", "Week 1 FAQs (Optional)", "What is Pseudocode? (Optional)", "Week 1 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Welcome!"}, {"description": "<p>Welcome to Week 2 of class!</p>\n\n<p>This week, we will examine the biological details of how DNA replication is carried out in the cell.  We will then see how to use these details to help us design an intelligent algorithmic approach looking for the replication origin in a bacterial genome.</p>", "video": ["Stepik Interactive Text for Week 2", "Where in the Genome Does DNA Replication Begin? (Part 3) (09:05)", "Where in the Genome Does DNA Replication Begin? (Part 4) (04:10)", "Week 2 FAQs (Optional)", "Week 2 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: Finding Replication Origins"}, {"description": "<p>Welcome to Week 3 of class!</p>\n\n<p>This week, we begin a new chapter, titled \"Which DNA Patterns Play the Role of Molecular Clocks?\" At the bottom of this message is this week's Bioinformatics Cartoon. &nbsp;What does a late night casino trip with two 18th Century French mathematicians have in common with finding molecular clocks? &nbsp;Start learning to find out...</p>\n\n<p><img src=\"https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter3_final.jpg\" title=\"Image: https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter3_final.jpg\" width=\"528\"></p>", "video": ["Stepik Interactive Text for Week 3", "From Implanted Patterns to Regulatory Motifs (Part 1) (10:09)", "From Implanted Patterns to Regulatory Motifs (Part 2) (05:06)", "From Implanted Patterns to Regulatory Motifs (Part 3) (07:22)", "Week 3 FAQs (Optional)", "Week 3 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 3"], "title": "Week 3: Hunting for Regulatory Motifs"}, {"description": "<p>Welcome to Week 4 of class!</p>\n\n<p>Last week, we encountered a few introductory motif-finding algorithms.  This week, we will see how to improve upon these motif-finding approaches by designing randomized algorithms that can \"roll dice\" to find motifs.</p>", "video": ["Stepik Interactive Text for Week 4", "How Rolling Dice Helps Us Find Regulatory Motifs (Part 1) (12:43)", "How Rolling Dice Helps Us Find Regulatory Motifs (Part 2) (05:37)", "How Rolling Dice Helps Us Find Regulatory Motifs (Part 3) (07:46)", "Week 4 FAQs (Optional)", "Week 4 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 4"], "title": "Week 4: How Rolling Dice Helps Us Find Regulatory Motifs"}, {"description": "Welcome to week 5 of the class!\n\nThis week, we will apply popular motif-finding software in order to hunt for motifs in a real biological dataset.", "video": ["Bioinformatics Application Challenge"], "title": "Week 5: Bioinformatics Application Challenge"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}], "course_info": "About this course: Named a top 50 MOOC of all time by Class Central!\n\nThis course begins a series of classes illustrating the power of computing in modern biology. Please join us on the frontier of bioinformatics to look for hidden messages in DNA without ever needing to put on a lab coat.\n\nIn the first half of the course, we investigate DNA replication, and ask the question, where in the genome does DNA replication begin?  We will see that we can answer this question for many bacteria using only some straightforward algorithms to look for hidden messages in the genome.\n\nIn the second half of the course, we examine a different biological question, when we ask which DNA patterns play the role of molecular clocks.  The cells in your body manage to maintain a circadian rhythm, but how is this achieved on the level of DNA?  Once again, we will see that by knowing which hidden messages to look for, we can start to understand the amazingly complex language of DNA.  Perhaps surprisingly, we will apply randomized algorithms, which roll dice and flip coins in order to solve problems.\n\nFinally, you will get your hands dirty and apply existing software tools to find recurring biological motifs within genes that are responsible for helping Mycobacterium tuberculosis go \"dormant\" within a host for many years before causing an active infection.", "level": "Beginner", "rating": "4.7", "package_num": "1", "target_audience": "Who is this class for: This course is primarily aimed at undergraduate-level learners in computer science, biology, or a related field who are interested in learning about how the intersection of these two disciplines represents an important frontier in modern science. ", "created_by": "University of California, San Diego", "title": "Finding Hidden Messages in DNA (Bioinformatics I)"}, {"package_name": null, "week_data": [{"description": "These lectures and readings give you an introduction to this course: its philosophy, organization, and load. They also tell you how the assignments are a significant part of the class.  This week covers the common input/output organization of the assignments, how they are graded, and how to succeed in this class.", "video": ["Course Promo", "Course Motivation - Indiana Jones, challenges, applications", "Start of Course Survey", "Socialize", "Course Introduction - philosophy, design, grading rubric", "Course Syllabus", "Assignments Introduction & Any Integer", "Any Integer"], "title": "Welcome"}, {"description": "These lectures introduce optimization problems and some optimization techniques through the knapsack problem, one of the most well-known problem in the field. It discusses how to formalize and model optimization problems using knapsack as an example. It then reviews how to apply dynamic programming and branch and bound to the knapsack problem, providing intuition behind these two fundamental optimization techniques. The concept of relaxation and search are also discussed.", "video": ["Knapsack 1 - intuition", "Knapsack 2 - greedy algorithms", "Knapsack 3 - modeling", "Knapsack 4 - dynamic programming", "Knapsack 5 - relaxation, branch and bound", "Knapsack 6 - search strategies, depth first, best first, least discrepancy", "Assignments Getting Started", "Knapsack & External Solver", "Exploring the Material -  open course design, optimization landscape, picking your adventure", "Knapsack"], "title": "Knapsack"}, {"description": "Constraint programming is an optimization technique that emerged from the field of artificial intelligence. It is characterized by two key ideas: To express the optimization problem at a high level to reveal its structure and to use constraints to reduce the search space by removing, from the variable domains, values that cannot appear in solutions. These lectures cover constraint programming in detail, describing the language of constraint programming, its underlying computational paradigm and how it can be applied in practice.", "video": ["CP 1 - intuition, computational paradigm, map coloring, n-queens", "CP 2 - propagation, arithmetic constraints, send+more=money", "CP 3 - reification, element constraint, magic series, stable marriage", "CP 4 - global constraint intuition, table constraint, sudoku", "CP 5 - symmetry breaking, BIBD, scene allocation", "CP 6 - redundant constraints, magic series, market split", "CP 7 - car sequencing, dual modeling", "CP 8 - global constraints in detail, knapsack, alldifferent", "CP 9 - search, first-fail, euler knight, ESDD", "CP 10 - value/variable labeling, domain splitting, symmetry breaking in search", "Graph Coloring", "Optimization Tools", "Optimization Tools", "Set Cover", "Set Cover", "Graph Coloring"], "title": "Constraint Programming"}, {"description": "Local search is probably the oldest and most intuitive optimization technique. It consists in starting from a solution and improving it by performing (typically) local perturbations (often called moves). Local search has evolved substantially in the last decades with a lot of attention being devoted on which moves to explore. These lectures explore the theory and practice of local search, from the concept of neighborhood and connectivity to meta-heuristics such as tabu search and simulated annealing.", "video": ["LS 1 - intuition, n-queens", "LS 2 - swap neighborhood, car sequencing, magic square", "LS 3 - optimization, warehouse location, traveling salesman, 2-opt, k-opt", "LS 4 - optimality vs feasibility, graph coloring", "LS 5 - complex neighborhoods, sports scheduling", "LS 6 - escaping local minima, connectivity", "LS 7 - formalization, heuristics, meta-heuristics introduction", "LS 8 - iterated location search, metropolis heuristic, simulated annealing, tabu search intuition", "LS 9 - tabu search formalized, aspiration, car sequencing, n-queens", "Traveling Salesman", "Traveling Salesman"], "title": "Local Search"}, {"description": "Linear programming has been, and remains, a workhorse of optimization. It consists in optimizing a linear objective subject to linear constraints, admits efficient algorithmic solutions, and is often an important building block for other optimization techniques. These lectures review fundamental concepts in linear programming, including the infamous simplex algorithm, simplex tableau, and duality. .", "video": ["LP 1 - intuition, convexity, geometric view", "LP 2 - algebraic view, naive algorithm", "LP 3 - the simplex algorithm", "LP 4 - matrix notation, the tableau", "LP 5 - duality derivation", "LP 6 - duality interpretation and uses"], "title": "Linear Programming"}, {"description": "Mixed Integer Programming generalizes linear programming by allowing integer variables, which dramatically changes the complexity of the problems but also broadens the potential applications significantly. These lectures review how to model problems in mixed-integer programming and how to solve mixed-integer programs using branch and bound. Advanced techniques such as cutting planes and polyhedral cuts are also covered.", "video": ["MIP 1 - intuition, relaxation, branch and bound, knapsack, warehouse location", "MIP 2 - modeling, big-M, warehouse location, graph coloring", "MIP 3 - cutting planes, Gomory cuts", "MIP 4 - convex hull, polyhedral cuts, warehouse location, node packing, graph coloring", "MIP 5 - cover cuts, branch and cut, seven bridges, traveling salesman", "Facility Location", "Facility Location"], "title": "Mixed Integer Programming"}, {"description": "These lectures cover some more advanced concepts in optimization. They introduce constraint-programming techniques for scheduling and routing. ", "video": ["Scheduling - jobshop, disjunctive global constraint", "Vehicle Routing", "Vehicle Routing"], "title": "Advanced Topics: Part I"}, {"description": "These lectures continues to cover some more advanced concepts in optimization. They introduce large neighborhood search, which often combines constraint programming and local search, and column generation which decomposes an optimization model into a master and pricing problem, using more complex variables.", "video": ["Large Neighborhood Search - asymmetric TSP with time windows", "Column Generation - branch and price, cutting stock"], "title": "Advanced Topics: Part II"}], "teach_by": [{"department": null, "name": "Professor Pascal Van Hentenryck"}, {"department": "Computing and Information Systems", "name": "Dr. Carleton Coffrin"}], "course_info": "About this course: Tired of solving Sudokus by hand? This class teaches you how to solve complex search problems with discrete optimization concepts and algorithms, including constraint programming, local search, and mixed-integer programming.\n\nOptimization technology is ubiquitous in our society. It schedules planes and their crews, coordinates the production of steel, and organizes the transportation of iron ore from the mines to the ports. Optimization clears the day-ahead and real-time markets to deliver electricity to millions of people. It organizes kidney exchanges and cancer treatments and helps scientists understand the fundamental fabric of life, control complex chemical reactions, and design drugs that may benefit billions of individuals.\n\nThis class is an introduction to discrete optimization and exposes students to some of the most fundamental concepts and algorithms in the field. It covers constraint programming, local search, and mixed-integer programming from their foundations to their applications for complex practical problems in areas such as scheduling, vehicle routing, supply-chain optimization, and resource allocation.", "level": "Intermediate", "rating": "4.9", "package_num": null, "target_audience": "Who is this class for: Good programming skills, knowledge of fundamental algorithms, and linear algebra.", "created_by": "The University of Melbourne", "title": "Discrete Optimization"}, {"package_name": "Introduction to Discrete Mathematics for Computer Science Specialization ", "week_data": [{"description": "What are graphs? What do we need them for? This week we'll see that a graph is a simple pictorial way to represent almost any relations between objects. We'll see that we use graph applications daily! We'll learn what graphs are, when and how to use them, how to draw graphs, and we'll also see the most important graph classes. We start off with two interactive puzzles. While they may be hard, they demonstrate the power of graph theory very well! If you don't find these puzzles easy, please see the videos and reading materials after them.", "video": ["Airlines Graph", "Knight Transposition", "Seven Bridges of Königsberg", "Slides", "What is a Graph?", "Graph Drawing Example", "Graph Examples", "Graph Applications", "Slides", "Vertex Degree", "Paths", "Connectivity", "Directed Graphs", "Weighted Graphs", "Slides", "Paths, Cycles and Complete Graphs", "Trees", "Bipartite Graphs", "Slides", "Glossary", "Puzzle: Guarini's Puzzle", "Puzzle: Bridges of Königsberg", "Definitions", "Puzzle: Make a Tree", "Graph Types"], "title": "What is a Graph?"}, {"description": "We’ll consider connected components of a graph and how they can be used to implement a simple program for solving the Guarini puzzle and for proving optimality of a certain protocol. We’ll see how to find a valid ordering of a to-do list or project dependency graph. Finally, we’ll figure out the dramatic difference between seemingly similar Eulerian cycles and Hamiltonian cycles, and we’ll see how they are used in genome assembly! ", "video": ["Puzzle: Connect Points by Segments", "Handshaking Lemma", "Total Degree", "Slides", "Connected Components", "Connected Components", "Guarini Puzzle: Code", "Guarini Puzzle Solver", "Lower Bound", "The Heaviest Stone", "Directed Acyclic Graphs", "Topological Sorting", "Strongly Connected Components", "Strongly Connected Components", "Slides", "Eulerian Cycles", "Eulerian Cycles: Criteria", "Eulerian Cycles", "Hamiltonian Cycles", "Genome Assembly", "Slides", "Glossary", "Computing the Number of Edges", "Number of Connected Components", "Number of Strongly Connected Components", "Eulerian Cycles", "Puzzle: Hamiltonian Cycle"], "title": "CYCLES"}, {"description": "This week we will study three main graph classes: trees, bipartite graphs, and planar graphs. We'll define minimum spanning trees, and then develop an algorithm which finds the cheapest way to connect arbitrary cities. We'll study matchings in bipartite graphs, and see when a set of jobs can be filled by applicants. We'll also learn what planar graphs are, and see when subway stations can be connected without intersections. Stay tuned for more interactive puzzles!", "video": ["Road Repair", "Trees", "Minimum Spanning Tree", "Minimum Spanning Tree", "Slides", "Job Assignment", "Bipartite Graphs", "Matchings", "Hall's Theorem", "Maximum Matching", "Slides", "Subway Lines", "Planar Graphs", "Euler's Formula", "Applications of Euler's Formula", "Slides", "Glossary", "Puzzle: Road Repair", "Trees", "Puzzle: Job Assignment", "Bipartite Graphs", "Puzzle: Subway Lines", "Planar Graphs"], "title": "Graph Classes"}, {"description": "We'll focus on the graph parameters and related problems. First, we'll define graph colorings, and see why political maps can be colored in just four colors. Then we will see how cliques and independent sets are related in graphs. Using these notions, we'll prove Ramsey Theorem which states that in a large system, complete disorder is impossible! Finally, we'll study vertex covers, and learn how to find the minimum number of computers which control all network connections.", "video": ["Map Coloring", "Graph Coloring", "Bounds on the Chromatic Number", "Applications", "Slides", "Graph Cliques", "Cliques and Independent Sets", "Maximum Clique", "Connections to Coloring", "Mantel's Theorem", "Slides", "Balanced Graphs", "Ramsey Numbers", "Existence of Ramsey Numbers", "Slides", "Antivirus System", "Vertex Covers", "König's Theorem", "Slides", "Glossary", "Puzzle: Map Coloring", "Graph Coloring", "Puzzle: Graph Cliques", "Cliques and Independent Sets", "Puzzle: Balanced Graphs", "Ramsey Numbers", "Puzzle: Antivirus System", "Vertex Covers"], "title": "Graph Parameters"}, {"description": "This week we'll develop an algorithm that finds the maximum amount of water which can be routed in a given water supply network. This algorithm is also used in practice for optimization of road traffic and airline scheduling. We'll see how flows in networks are related to matchings in bipartite graphs. We'll then develop an algorithm which finds stable matchings in bipartite graphs. This algorithm solves the problem of matching students with schools, doctors with hospitals, and organ donors with patients. By the end of this week, we'll implement an algorithm which won the Nobel Prize in Economics!", "video": ["An Example", "The Framework", "Ford and Fulkerson: Proof", "Hall's theorem", "Constant Degree Bipartite Graphs", "What Else?", "Slides", "Why Stable Matchings?", "Mathematics and Real Life", "Basic Examples", "Looking For a Stable Matching", "Gale-Shapley Algorithm", "Correctness Proof", "Why The Algorithm Is Unfair", "Why the Algorithm is Very Unfair", "Slides", "Gale-Shapley Algorithm", "Project Description", "Glossary", "Choose an Augmenting Path Carefully", "Base Cases", "Algorithm"], "title": "Flows and Matchings"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}], "course_info": "About this course: We invite you to a fascinating journey into Graph Theory — an area which connects the elegance of painting and the rigor of mathematics;  is simple, but not unsophisticated. Graph Theory gives us, both an easy way to pictorially represent many major mathematical results, and insights into the deep theories behind them. \n\nIn this course, among other intriguing applications, we will see how GPS systems find shortest routes, how engineers design integrated circuits, how biologists assemble genomes, why a political map can always be colored using a few colors. We will study Ramsey Theory which proves that in a large system, complete disorder is impossible! \n\nBy the end of the course, we will implement an algorithm which finds an optimal assignment of students to schools. This algorithm, developed by David Gale and Lloyd S. Shapley, was later recognized by the conferral of Nobel Prize in Economics.\n\nAs prerequisites we assume only basic math (e.g., we expect you to know what is a square or how to add fractions), basic programming in python (functions, loops, recursion), common sense and curiosity. Our intended audience are all people that work or plan to work in IT, starting from motivated high school students.", "level": "Beginner", "rating": "4.6", "package_num": "3", "target_audience": null, "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Introduction to Graph Theory"}, {"package_name": "Introduction to Discrete Mathematics for Computer Science Specialization ", "week_data": [{"description": "Suppose we need to count certain objects. Can we do anything better than just list all the objects? Do we need to create a list all phone numbers to check whether there are enough phone numbers for everyone? Is there a way to tell whether our algorithm will run in a reasonable time before implementing and actually running it? All these questions are addressed by a mathematical field called Combinatorics. In this module we will give an introduction to this field that will help us to answer basic versions of the above questions.", "video": ["Why counting", "Rule of Sum", "Numbers Divisible by 2 or 3", "How Not to Use the Rule of Sum", "Convenient Language: Sets", "Generalized Rule of Sum", "Slides", "Number of Paths", "Rule of Product", "Back to Recursive Counting", "Slides", "Number of Tuples", "Licence Plates", "Tuples with Restrictions", "Permutations", "Listing All Permutations", "Slides", "Rule of Sum in Programming", "Operations with Sets", "Generalized Rule of Sum", "Puzzle: Number of Paths", "Rule of Product in Programming", "Applications of the Rule of Product", "Tuples", "Counting with Restrictions"], "title": "Basic Counting"}, {"description": "In how many ways one can select a team of five students out of ten students? What is the number of non-negative integers with at five digits whose digits are decreasing? In how many ways one can get from the bottom left cell to the top right cell of a 5x5 grid, each time going either up or to the right? And why all these three numbers are equal? We'll figure this out in this module!", "video": ["Previously on Combinatorics", "Generating Combinatorial Objects: Code", "Number of Games in a Tournament", "Combinations", "Number of Iterations of Nested For Loops", "Slides", "Pascal's Triangle", "Symmetries", "Row Sums", "Binomial Theorem", "Slides", "Practice Counting", "Slides", "Number of Segments and Diagonals", "Forming Sport Teams", "Sum of the First Six Rows of Pascal's Triangle", "Expanding (3a-2b)^k", "Practice Counting"], "title": "Binomial Coefficients"}, {"description": "We have already considered most of the most standard settings in Combinatorics, that allow us to address many counting problems. However, successful application of this knowledge on practice requires considerable experience in this kind of problems. In this module we will address the final standard setting in our course, combinations with repetitions, and then we will gain some experience by discussing various problems in Combinatorics.", "video": ["Review", "Salad", "Combinations with Repetitions", "Salads", "Slides", "Distributing Assignments Among People", "Distributing Assignments Among People", "Distributing Candies Among Kids", "Distributing Candies Among Kids", "Numbers with Fixed Sum of Digits", "Numbers with Fixed Sum of Digits", "Numbers with Non-increasing Digits", "Numbers with Non-increasing Digits", "Splitting into Working Groups", "Splitting into Working Groups", "Slides", "Salads", "Combinations with Repetitions", "Problems in Combinatorics"], "title": "Advanced Counting"}, {"description": "The word \"probability\" is used quite often in the everyday life. However, not always we can speak about probability as some number: for that a mathematical model is needed. What is this mathematical model (probability space)? How to compute probabilities (if the model is given)? How to judge whether the model is adequate? What is conditional probability and Bayes' theorem? How our plausible reasoning can be interpreted in terms of Bayes' theorem? In this module we cover these questions using some simple examples of probability spaces and real life sutiations.", "video": ["The Paradox of Probability Theory", "Galton Board", "Natural Sciences and Mathematics", "Rolling Dice", "More Probability Spaces", "Slides", "Not Equiprobable Outcomes", "More About Finite Spaces", "Mathematics for Prisoners", "Not All Questions Make Sense", "Slides", "What Is Conditional Probability?", "How Reliable Is The Test?", "Bayes' Theorem", "Conditional Probability: A Paradox", "Past and Future", "Independence", "Slides", "Monty Hall Paradox", "`Our Position'", "Slides", "Concentration for Galton Board", "Computing Probabilities for Two Dice", "Computing Probabilities: More Examples", "Fair Decisions and Imperfect Coins", "Puzzle: Prisoner and King", "Inclusion-Exclusion Formula", "Computing Conditional Probabilities", "Prisoner, King and Conditional Probabilities", "More Conditional Probabilities", "More About Independence", "Monty Hall Gone Crazy"], "title": "Probability"}, {"description": "In the previous module we discussed how to compute probabilities of random events. But in many practical situation we are interested not only in positive or negative outcome, but also in some quantitative characteristics of an outcome. Among these cases are number of  steps of an algorithms, number of points that one can win in the games involving any kind of randomness, all quantitative characteristics of a random person in some group of people. Basically settings of this kind arise in all situations when (a) any kind of uncertainty is presented (b) we are interested in quantitative characteristics. The mathematical model for this is called random variables. And we will discuss them in this module.", "video": ["Random Variables", "Average", "Average Value of a Dice Throw: Experiment", "Expectation", "Slides", "Linearity of Expectation", "Birthday Problem", "Slides", "Expectation is Not All", "Dice Game Experiment", "Slides", "From Expectation to Probability", "Markov’s Inequality", "Application to Algorithms", "Slides", "Random Variables", "Average", "Expectations", "Linearity of Expectation", "Bob’s Party", "More Linearity", "Average Income", "Bob’s Party Revisited", "Alice’s tests"], "title": "Random Variables"}, {"description": "In this module, we will apply accumulated knowledge to create a project solving a certain dice game. The game is very simple: two players pick a dice each from a given pool of dices with various numbers on their sides. Then each player throws his dice and the one with the greater number on his dice wins. The game looks very simple and it seems that it is very easy to play this game optimally once we know our pool of dices. Yet it turns out that this intuition is overwhelmingly wrong: the game turns out to be very counterintuitive. In this module we will discuss the game in detail and create a program that finds an optimal strategy to play the game on a given pool of dices.", "video": ["Dice Game", "Playing the Game", "Experiment: Dice Game", "Slides", "Project Description", "Slides", "Final Project: Dice Game"], "title": "Project: Dice Games"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science Department", "name": "Vladimir Podolskii"}], "course_info": "About this course: Counting is one of the basic mathematically related tasks we encounter on a day to day basis. The main question here is the following. If we need to count something, can we do anything better than just counting all objects one by one? Do we need to create a list of all phone numbers to ensure that there are enough phone numbers for everyone? Is there a way to tell that our algorithm will run in a reasonable time before implementing and actually running it? All these questions are addressed by a mathematical field called Combinatorics.\n\nIn this course we discuss most standard combinatorial settings that can help to answer questions of this type. We will especially concentrate on developing the ability to distinguish these settings in real life and algorithmic problems. This will help the learner to actually implement new knowledge. Apart from that we will discuss recursive technique for counting that is important for algorithmic implementations.\n\nOne of the main `consumers’ of Combinatorics is Probability Theory. This area is connected with numerous sides of life, on one hand being an important concept in everyday life and on the other hand being an indispensable tool in such modern and important fields as Statistics and Machine Learning. In this course we will concentrate on providing the working knowledge of basics of probability and a good intuition in this area. The practice shows that such an intuition is not easy to develop.\n\nIn the end of the course we will create a program that successfully plays a tricky and very counterintuitive dice game.\n\nAs prerequisites we assume only basic math (e.g., we expect you to know what is a square or how to add fractions), basic programming in python (functions, loops, recursion), common sense and curiosity. Our intended audience are all people that work or plan to work in IT, starting from motivated high school students.", "level": "Beginner", "rating": "4.6", "package_num": "2", "target_audience": null, "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Combinatorics and Probability"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "What is Algorithmic Thinking?, class structure, graphs, brute-force algorithms", "video": ["What is Algorithmic Thinking? ", "Class structure", "Pseudo-code ", "The small-world problem ", "Graphs and representation ", "Paths and distances ", "Brute force ", "What Is algorithm efficiency? ", "Measuring efficiency ", "Efficiency of brute force distance ", "Number of steps of brute force distance ", "Class notes", "Coding notes", "Coding styles and standards  -  PoC", "Machine grading  -  PoC", "Plotting data - PoC", "Peer assessment - \"We want a shrubbery!\"  - IIPP", "Homework  #1"], "title": "Module 1 - Core Materials"}, {"description": "Graph representations, plotting, analysis of citation graphs", "video": ["Project #1 Description", "Project Submission History", "Application #1 Description", "Application #1 Solution", "Assignment: Degree Distribution for Graphs", "Analysis of Citation Graphs"], "title": "Modules 1 - Project and Application"}, {"description": "Asymptotic analysis, \"big O\" notation, pseudocode, breadth-first search", "video": ["Orders of growth ", "Asymptotics", "Illustrating \"Big O\"", "Illustrating BFS ", "Queues and boundary cases ", "Pseudocode ", "BFS running time - loose analysis ", "BFS running time - tighter analysis ", "BFS-based distance distribution ", "Homework #2"], "title": "Module 2 - Core Materials"}, {"description": "Connected components, graph resilience, and analysis of computer networks", "video": ["Project #2 Description", "Application #2 Description", "Application #2 Solution", "Assignment: Connected Components and Graph Resilience", "Analysis of a Computer Network"], "title": "Module 2 - Project and Application"}], "teach_by": [{"department": "Computer Science; Biochemistry and Cell Biology ", "name": "Luay Nakhleh"}, {"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science", "name": "Joe Warren"}], "course_info": "About this course: Experienced Computer Scientists analyze and solve computational problems at a level of abstraction that is beyond that of any particular programming language.  This two-part course builds on the principles that you learned in our Principles of Computing course and is designed to train students in the mathematical concepts and process of \"Algorithmic Thinking\", allowing them to build simpler, more efficient solutions to real-world computational problems.\n\nIn part 1 of this course, we will study the notion of algorithmic efficiency and consider its application to several problems from graph theory.  As the central part of the course, students will implement several important graph algorithms in Python and then use these algorithms to analyze two large real-world data sets.  The main focus of these tasks is to understand interaction between the algorithms and the structure of the data sets being analyzed by these algorithms.\n\nRecommended Background - Students should be comfortable writing intermediate size  (300+ line) programs in Python and have a basic understanding of searching, sorting, and recursion. Students should also have a solid math background that includes algebra, pre-calculus and a familiarity with the math concepts covered in \"Principles of Computing\".", "level": "Intermediate", "rating": "4.6", "package_num": "5", "target_audience": null, "created_by": "Rice University", "title": "Algorithmic Thinking (Part 1)"}, {"package_name": null, "week_data": [{"description": "Week 1 will introduce you to visual basic for applications (VBA) and teach you the foundational tools required to create basic procedures in VBA.  You'll learn about different data types and the scope of variables, how to troubleshoot your code when it's not working, and how to record basic macros using both absolute and relative referencing modes.", "video": ["Welcome!", "What can you do with Excel/VBA?", "For Mac users", "Is this course for you?", "How the course works", "What about you?!", "Review of Excel (if you need it!)", "Week 1 preview", "Getting your feet wet", "Saving your files as macro-enabled workbooks", "Recording basic macros", "Absolute vs. relative referencing during macro recording", "Overview of procedures in VBA", "Why use Option Explicit?", "Declaration of variables, data types, and scope of variables", "How to troubleshoot when your code is not working properly", "\"Debugging.xlsm\" file", "(OPTIONAL) Week 1 reflection & suggestions for Part 2 of the course?", "Assignment 1", "Assignment 1 preview and instructions", "Week 1 Quiz", "Assignment 1 Submission"], "title": "Macro recording, VBA procedures, and debugging"}, {"description": "In Week 2, you will learn basic VBA expression entry, how to create user-defined functions, how to convert functions to Add-Ins in Excel, how to borrow Excel's built-in functions, how to troubleshoot your VBA functions when they aren't working, and you'll learn about how to design your procedures in a modular fashion.", "video": ["Week 2 preview", "How to write basic VBA expressions and use built-in functions", "How to make your own user-defined function", "Example of a user-defined function", "How to convert a user-defined function to an Excel Add-In", "Borrowing Excel functions", "How to troubleshoot your user defined functions", "Why you don't use input and message boxes in functions", "An introduction to modular programming", "Running a subroutine that resides in another file", "(OPTIONAL) Week 2 reflection & suggestions for Part 2 of the course?", "Assignment 2", "Assignment 2 preview and instructions", "Week 2 Quiz", "Assignment 2 submission"], "title": "User-Defined VBA Functions"}, {"description": "Week 3 teaches you all about how to reference and move information to VBA from Excel and vice versa.  You'll learn about the various objects, properties, methods, and events in VBA.  Some of the most important properties and methods will be learned in this module that will make future problem solving in the course possible.  You will also learn how to deal with errors that arise in your subroutines.", "video": ["Week 3 preview", "Introduction to objects, properties, methods, and events", "Common objects, properties, and methods", "Examples, Part 1: Basic input and output in subroutines", "Examples, Part 2: Basic input and output in subroutines", "Examples, Part 3: Basic input and output in subroutines", "How to handle basic user error in your subroutines", "(OPTIONAL) Week 3 reflection & suggestions for Part 2 of the course?", "Assignment 3", "Assignment 3 preview and instructions", "Week 3 Quiz", "Assignment 3 submission"], "title": "Exchanging Information Between Excel and VBA"}, {"description": "Week 4 begins the \"meat\" of programming in VBA, and we are finally moving into some exciting problem solving.  You will learn about the common programming structures in VBA (sequence, selection, and repetition) that form the foundation for advanced programming procedures.  Several examples will highlight the utility of these programming structures.", "video": ["Week 4 preview", "How to implement One-Way If...Then selection structures", "How to implement Two-Way If...Then selection structures", "All about the Multi-Alternative If...Then", "Variable iteration loops (Do...Loops)", "Validating user input using a Do...Loop", "Creating a guessing game using a Do...Loop", "All about fixed iteration (For...Next) loops", "Putting it all together: Example 1", "Putting it all together: Example 2", "Using the For Each... Next statement", "Worked mini-project: Searching through high and low temperatures in an Excel workbook", "\"Boulder High and Low Temperatures 2016 - STARTER.xlsm\" file", "(OPTIONAL) Advanced input validation and error handling: Part 1", "(OPTIONAL) Advanced input validation and error handling: Part 2", "(OPTIONAL) Week 4 reflection & suggestions for Part 2 of the course?", "Assignment 4", "Assignment 4 preview and instructions", "Week 4 Quiz", "Assignment 4 submission"], "title": "Programming structures in VBA"}, {"description": "Week 5 delves into some important numerical techniques that can be used in Excel without the use of VBA but we also explore ways in which the targeting tools in Excel (Goal Seek and Solver tools) can be automated in VBA.  Finally, we explore some exciting \"live solution\" methods that have distinct advantages, especially for case studies where you have multiple scenarios that must be solved.  Week 5 represents the most math-heavy module of either part of \"Excel/VBA for Creative Problem Solving\" but will provide you with some extremely useful tools that you can implement in solving a variety of real world problems.", "video": ["Week 5 preview", "How to use the Goal Seek and Solver tools to solve targeting problems", "How to solve optimization problems using the Solver tool", "Fuel tank example and limitations of the Goal Seek and Solver Tools", "\"Fuel Tank - STARTER.xlsx\" file", "Automating the Goal Seek and Solver Tools", "Circular Calculations in Excel", "Implementing the bisection method in Excel", "Implementing a live solution of the bisection method to solve a case study", "Using the Golden Section search technique for optimization problems in Excel", "Live solution of the Golden Search technique for solving an optimization problem", "Solving a case study for friction factor using a circular calculation", "Implementing targeting and optimization algorithms in VBA subroutines", "Bisection method in a VBA function", "(OPTIONAL) Week 5 reflection & suggestions for Part 2 of the course?", "Preview of Part 2 of the course", "Assignment 5", "Assignment 5 preview and instructions", "Week 5 Quiz", "Assignment 5 submission"], "title": "Numerical techniques and live solution strategies"}], "teach_by": [{"department": "Chemical and Biological Engineering", "name": "Charlie Nuttelman"}], "course_info": "About this course: \"Excel/VBA for Creative Problem Solving, Part 1\" is aimed at learners who are seeking to augment, expand, optimize, and increase the efficiency of their Excel spreadsheet skills by tapping into the powerful programming, automation, and customization capabilities available with Visual Basic for Applications (VBA).  \n\nThis course is the first part of a two-part series that will focus on the application of computing techniques in Excel/VBA to solve problems.  In this course (Part 1), you will: 1) create macros to automate procedures in Excel; 2) define your own user-defined functions; 3) create basic subroutines to interface with the user; 4) learn the basic programming structures in VBA; and 5) automate Excel’s Goal Seek and Solver tools and use numerical techniques to create “live solutions” to solve targeting and optimization problems.\n\nNew to computer programming?  The extremely intuitive and visual nature of VBA lends itself nicely to teaching and learning - what a fun way to learn to code!  No prior knowledge in programming nor advanced math skills are necessary yet seasoned programmers will pick up new and creative spreadsheet problem solving strategies.\n\nAfter you have learned the basics of VBA, each module will have introduce foundational and broad problems inspired by situations that you might encounter in the real world.  To pass each module, you'll need to pass a mastery quiz and complete a problem solving assignment.  This course is unique in that the weekly assignments are completed in-application (i.e., on your own computer in Excel), providing you with valuable hands-on training.", "level": "Beginner", "rating": null, "package_num": null, "target_audience": "Who is this class for: This course is aimed at science/engineering/business students and professionals wishing to unlock the vast potential of Visual Basic for Applications to help you automate and customize the Excel spreadsheet environment.", "created_by": "University of Colorado Boulder", "title": "Excel/VBA for Creative Problem Solving, Part 1"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "Network flows show up in many real world situations in which a good needs to be transported across a network with limited capacity. You can see it when shipping goods across highways and routing packets across the internet. In this unit, we will discuss the mathematical underpinnings of network flows and some important flow algorithms. We will also give some surprising examples on seemingly unrelated problems that can be solved with our knowledge of network flows.", "video": ["Slides and Resources on Flows in Networks", "Introduction", "Network Flows", "Residual Networks", "Maxflow-Mincut", "The Ford–Fulkerson Algorithm", "Slow Example", "The Edmonds–Karp Algorithm", "Bipartite Matching", "Image Segmentation", "Available Programming Languages", "FAQ on Programming Assignments", "Flow Algorithms", "Programming Assignment 1"], "title": "Flows in Networks"}, {"description": "Linear programming is a very powerful algorithmic tool. Essentially, a linear programming problem asks you to optimize a linear function of real variables constrained by some system of linear inequalities. This is an extremely versatile framework that immediately generalizes flow problems, but can also be used to discuss a wide variety of other problems from optimizing production procedures to finding the cheapest way to attain a healthy diet. Surprisingly, this very general framework admits efficient algorithms. In this unit, we will discuss some of the importance of linear programming problems along with some of the tools used to solve them.", "video": ["Slides and Resources on Linear Programming", "Introduction", "Linear Programming", "Linear Algebra: Method of Substitution", "Linear Algebra: Gaussian Elimination", "Convexity", "Duality", "(Optional) Duality Proofs", "Linear Programming Formulations", "The Simplex Algorithm", "(Optional) The Ellipsoid Algorithm", "Linear Programming Quiz", "Programming Assignment 2"], "title": "Linear Programming"}, {"description": "Although many of the algorithms you've learned so far are applied in practice a lot, it turns out that the world is dominated by real-world problems without a known provably efficient algorithm. Many of these problems can be reduced to one of the classical problems called NP-complete problems which either cannot be solved by a polynomial algorithm or solving any one of them would win you a million dollars (see Millenium Prize Problems) and eternal worldwide fame for solving the main problem of computer science called P vs NP. It's good to know this before trying to solve a problem before the tomorrow's deadline :) Although these problems are very unlikely to be solvable efficiently in the nearest future, people always come up with various workarounds. In this module you will study the classical NP-complete problems and the reductions between them. You will also practice solving large instances of some of these problems despite their hardness using very efficient specialized software based on tons of research in the area of NP-complete problems.", "video": ["Slides and Resources on NP-complete Problems", "Brute Force Search", "Search Problems", "Traveling Salesman Problem", "Hamiltonian Cycle Problem", "Longest Path Problem", "Integer Linear Programming Problem", "Independent Set Problem", "P and NP", "Reductions", "Showing NP-completeness", "Independent Set to Vertex Cover", "3-SAT to Independent Set", "SAT to 3-SAT", "Circuit SAT to SAT", "All of NP to Circuit SAT", "Using SAT-solvers", "NP-complete Problems", "Programming Assignment 3"], "title": "NP-complete Problems"}, {"description": "After the previous module you might be sad: you've just went through 5 courses in Algorithms only to learn that they are not suitable for most real-world problems. However, don't give up yet! People are creative, and they need to solve these problems anyway, so in practice there are often ways to cope with an NP-complete problem at hand. We first show that some special cases on NP-complete problems can, in fact, be solved in polynomial time. We then consider exact algorithms that find a solution much faster than the brute force algorithm. We conclude with approximation algorithms that work in polynomial time and find a solution that is close to being optimal. ", "video": ["Slides and Resources on Coping with NP-completeness", "Introduction", "2-SAT", "2-SAT: Algorithm", "Independent Sets in Trees", "3-SAT: Backtracking", "3-SAT: Local Search", "TSP: Dynamic Programming", "TSP: Branch and Bound", "Vertex Cover", "Metric TSP", "TSP: Local Search", "Coping with NP-completeness", "Programming Assignment 4"], "title": "Coping with NP-completeness"}, {"description": "In most previous lectures we were interested in designing algorithms with fast (e.g. small polynomial) runtime, and assumed that the algorithm has random access to its input, which is loaded into memory. In many modern applications in big data analysis, however, the input is so large that it cannot be stored in memory. Instead,  the input is presented as a stream of updates, which the algorithm scans while maintaining a small summary of the stream seen so far. This is precisely the setting of the streaming model of computation, which we study in this lecture. The streaming model is well-suited for designing and reasoning about small space algorithms. It has received a lot of attention in the literature, and several powerful algorithmic primitives for computing basic stream statistics in this model have been designed, several of them impacting the practice of big data analysis. In this lecture we will see one such algorithm (CountSketch), a small space algorithm for finding the top k most frequent items in a data stream.", "video": ["Introduction", "Heavy Hitters Problem", "Reduction 1", "Reduction 2", "Basic Estimate 1", "Basic Estimate 2", "Final Algorithm 1", "Final Algorithm 2", "Proofs 1", "Proofs 2", "Quiz: Heavy Hitters", "(Optional) Programming Assignment 5"], "title": "Streaming Algorithms (Optional)"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Department of Computer Science and Engineering / Department of Mathematics", "name": "Daniel M Kane"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}], "course_info": "About this course: You've learned the basic algorithms now and are ready to step into the area of more complex problems and algorithms to solve them. Advanced algorithms build upon basic ones and use new ideas. We will start with networks flows which are used in more typical applications such as optimal matchings, finding disjoint paths and flight scheduling as well as more surprising ones like image segmentation in computer vision. We then proceed to linear programming with applications in optimizing budget allocation, portfolio optimization, finding the cheapest diet satisfying all requirements and many others. Next we discuss inherently hard problems for which no exact good solutions are known (and not likely to be found) and how to solve them in practice. We finish with a soft introduction to streaming algorithms that are heavily used in Big Data processing. Such algorithms are usually designed to be able to process huge datasets without being able even to store a dataset.", "level": "Advanced", "rating": "4.4", "package_num": "5", "target_audience": "Who is this class for: Programmers with basic experience looking to understand the practical and conceptual underpinnings of algorithms, with the goal of becoming more effective software engineers. Computer science students and researchers as well as interdisciplinary students (studying electrical engineering, mathematics, bioinformatics, etc.) aiming to get more profound understanding of algorithms and hands-on experience implementing them and applying for real-world problems. Applicants who want to prepare for an interview in a high-tech company.", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Advanced Algorithms and Complexity"}, {"package_name": "Object Oriented Programming in Java Specialization ", "week_data": [{"description": "Welcome to the first module in the second course of our Intermediate Java Programming Specialization.  We'll start with introductions again: to ourselves, the Google engineers, and the structure of the course.  After the introduction we'll have a short warm up to get you comfortable with the code you will be building on to this class.  But don't worry--no graded programming assignments yet.  This week is all about getting comfortable and excited to learn.", "video": ["Course Title", "A Customized Welcome to this Course", "Welcome (Object Oriented Java Programming: Data Structures and Beyond Specialization)", "Welcome (Object Oriented Programming in Java Specialization)", "After completing this course, you will be able to...", "Is this course right for me?", "Pre-Course Quiz", "Up Next: A short survey", "Survey: Your goals for the course", "If you want more practice before you begin...", "The structure of this course", "Your path through the course", "Concept Challenges", "In the Real World: Welcome from Google Engineers", "Project Overview", "Project Prototype", "Setting up Java and Eclipse", "Getting and Working with the Starter Code", "Quiz about the Starter Code and Course Structure"], "title": "Introduction to the Course"}, {"description": "This week we're going to dive into the course programming project.  In the first lesson you'll learn about Strings and Regular Expressions, and in the programming assignment this week you'll apply that knowledge to adding functionality to your text editor so that it can measure the \"readability\" of text by calculating something called the \"Flesch Readability Score\".  This course is focused on building code that not only does interesting things, but also finishes them quickly.  So, let's get started building some code!", "video": ["Introduction", "A note about week numbers", "By the end of this week, you will be able to...", "Project Overview", "Core: Introduction to the Flesch Readability Score", "Core: Basics of Strings in Java", "Core: Working with Strings in Java", "Where to next?", "Support: For-Each Loops, part 1 of 5", "Support: For-Each Loops, part 2 of 5", "Support: For-Each Loops, part 3 of 5", "Support: For-Each Loops, part 4 of 5", "Support: For-Each Loops, part 5 of 5", "Core: Introduction to Regular Expressions", "When I struggled: Regular expressions", "Concept Challenge: Regular Expressions", "Support: More with Regular Expressions", "Strings and Regular Expressions", "Did you have trouble with any question(s) on the practice quiz?", "What questions do you have about Strings and Regular Expressions?", "Week 2: Additional Resources", "Project: Programming Assignment Walk Through", "Programming Assignment FAQ", "Week 2: Congratulations and quiz answers", "How Easy to Read is Your Writing?", "Module and Programming Assignment Quiz"], "title": "Working with Strings"}, {"description": "Welcome to week 3!  The text-editor application you worked with last week does something, but it doesn't do it particularly fast.  This week we'll start talking about efficiency.  We'll introduce the concept of \"Big-O\" notation, which sounds a little silly, but is really a powerful (and extremely common) way of analyzing a program's efficiency, independent of the system that it's running on and the exact details of how it's implemented.  Then we'll go the other direction and dive into the details, talking about how to measure the actual running time of a piece of code to get an idea of how it really performs in practice. ", "video": ["Introduction", "By the end of this week, you will be able to...", "Project Overview", "In the Real World: Efficiency", "Core: Our Motivation for Asymptotic Analysis", "Core: Counting Operations", "Core: Introduction to Asymptotic Analysis, Part 1", "Core: Introduction to Asymptotic Analysis, Part 2", "Core: Computing Big O with Consecutive Operations", "Core: Computing Big O with Nested Operations", "Where to next?", "Practice Quiz", "Concept Challenge: Classifying Functions using Big O", "Support: Analyzing Selection Sort", "Concept Challenge: Estimating Big O from Code", "Core: Worst, Best, and Average Cases", "In the Real World: Worst Case Analysis", "Core: Analyzing Search Algorithms", "Core: Analyzing Sorting Algorithms", "When I struggled: Algorithm performance", "Core: Merge Sort", "Core: A Summary of Sorting", "Core: Common Pitfalls in Asymptotic Analysis", "Asymptotic Notation and Analysis", "Core: Introduction to Benchmarking", "Core: Using Java Time", "Core: Analyzing Timings", "Concept Challenge: Relating Timing Data to Algorithm Analysis", "Week 3: Additional Resources", "Project: Week 3 Project Walk Through", "Week 3: Congratulations and quiz answers", "Making Flesch Score Calculation More Efficient", "Module and After Programming Assignment Quiz"], "title": "Efficiency Analysis and Benchmarking"}, {"description": "This week we'll start talking about some of the basic concepts that one expects to find in a data structures course: the idea of data abstraction, and a data structure called a Linked List.  Even though Linked Lists are not very efficient structures (for the most part), they do hit home the idea of \"linking\" pieces of data together in your computer's memory, rather than storing the data in one contiguous region.  This linking idea will be central to many of the more advanced data structures, namely trees and graphs, that are coming up later in this course and in the next course in this specialization.  In this module you'll also learn tools and procedures for unit testing your code, which is a way to make sure that what you've written is correct, and a staple practice of any sophisticated software developer.", "video": ["Introduction", "By the end of this week, you will be able to...", "Project Overview", "Core: Introduction to Abstraction", "In the Real World: Data Abstraction", "Core: Linked Lists vs. Arrays", "In the Real World: Lists vs. Arrays", "Core: Generics and Exceptions", "Core: Java Code for a Linked List", "Concept Challenge: Implementing linked lists, a first attempt", "Concept Challenge: Drawing Linked Lists, second attempt", "Support: Adding to a Linked List", "When I struggled: Data structures", "Core: Testing and Confidence", "In the Real World: How can the compiler help with testing?", "Core: Testing Practices", "Where to next?", "In the Real World: How do you test the behavior of code?", "Support: JUnit in Eclipse", "In the Real World: Unit Testing", "Core: Testing Linked List's \"Get\" Method", "Concept Challenge: Which Tests Should You Run?", "In the Real World: Test-driven development", "Week 4: Additional Resources", "Project: Linked List Assignment Walk Through", "When I struggled: confidence in code", "Where to next?", "Core: Markov Text Generation", "Core: Implementing Markov Text Generation", "Optional Project: Markov Text Generation Walk Through", "(Optional) Markov Text Generation", "Week 4: Congratulations", "Implement and Test a Linked List", "Week 4 Reflective Programming Assignment Quiz"], "title": "Interfaces, Linked Lists vs. Arrays, and Correctness"}, {"description": "Welcome to week 4!  We know you've been working hard.  We hope you tried that optional Markov Text Generation programming assignment last week, but if not, no worries.  You can always go back and do it later (spoiler alert: it's pretty amazing that such a simple algorithm can produce such realistic text).  This week there's more fun (and hard work) as we learn about trees.  Trees rely on the same linked structure idea as Linked Lists, only they're MUCH faster (usually...).  In the project this week you'll add auto-complete to your text editor.  Believe us when we say it's so cool when you get it working!  You'll see... and we bet you can't wait for the programming assignment now.  :)", "video": ["Introduction", "By the end of this week, you will be able to...", "Project Overview", "Core: Trees", "In the Real World: Trees", "Core: Defining Trees", "Core: Binary Trees", "Core: Pre-Order Traversals", "Where to next?", "Core: Post-Order, In-Order, and Level-Order Traversals (Breadth-first search)", "When I struggled: Why traverse a tree?", "Core: Introduction to Binary Search Trees", "Core: Searching in a BST", "Support: Code for BST's \"Find\" Method", "Core: Inserting into a BST", "Support: Code for BST's \"Insert\" Method", "Core: Deleting from a BST", "Concept Challenge: BST Shape", "Core: Performance of BSTs and Balancing, Part 1", "Core: Performance of BSTs and Balancing, Part 2", "Core: Introduction to Tries", "Core: Performance of Tries", "Core: Implementing a Trie", "Week 5: Additional Resources", "Project: Week 5 Project Walk Through", "Week 5: Congratulations and quiz answers", "Spell Checking and Autocomplete", "Week 5 Content and Programming Assignment Quiz"], "title": "Trees! (including Binary Search Trees and Tries)"}, {"description": "You made it to the last week!  Congratulations on getting this far!  In this last week we'll be looking at a fundamental data structure called a Hash Table.  If you thought trees were fast, just wait until you see what Hash Tables can do!   Your last programming assignment will add spelling correction suggestions to your text editor, and there's an optional assignment that builds on the same ideas as the main assignment too, if you have the time and energy.  ", "video": ["Introduction", "By the end of this week, you will be able to...", "Project Overview", "Core: Hash Tables", "Core: Collisions in Hash Tables", "When I Struggled: Hash Tables", "Core: Applications of Hash Tables", "Support: Modular Arithmetic", "Concept Challenge: Hash Tables", "Core: Overview", "Core: Algorithm", "Core: Edit Distance", "Week 6: Additional Resources", "Project: Spelling Suggestions Walk Through", "Project: Word Path Walk Through", "Word Paths (Optional but Recommended)", "Week 6: Congratulations and quiz answers", "Core: Congratulations!", "Spelling Suggestions", "Week 6: Programming Assignment and Content Quiz"], "title": "Hash Maps and Edit Distance"}], "teach_by": [{"department": "Computer Science and Engineering", "name": "Christine Alvarado"}, {"department": "Computer Science and Engineering", "name": "Mia Minnes"}, {"department": "Computer Science and Engineering", "name": "Leo Porter"}], "course_info": "About this course: How do Java programs deal with vast quantities of data? Many of the data structures and algorithms that work with introductory toy examples break when applications process real, large data sets.  Efficiency is critical, but how do we achieve it, and how do we even measure it?\n\nThis is an intermediate Java course. We recommend this course to learners who have previous experience in software development or a background in computer science, and in particular, we recommend that you have taken the first course in this specialization (which also requires some previous experience with Java).  \n\nIn this course, you will use and analyze data structures that are used in industry-level applications, such as linked lists, trees, and hashtables.  You will explain how these data structures make programs more efficient and flexible.  You will apply asymptotic Big-O analysis to describe the performance of algorithms and evaluate which strategy to use for efficient data retrieval, addition of new data, deletion of elements, and/or memory usage.\n\nThe program you will build throughout this course allows its user to manage, manipulate and reason about large sets of textual data.  This is an intermediate Java course, and we will build on your prior knowledge.  This course is designed around  the same video series as in our first course in this specialization, including explanations of core content, learner videos, student and engineer testimonials, and support videos -- to better allow you to choose your own path through the course!", "level": "Intermediate", "rating": "4.8", "package_num": "4", "target_audience": "Who is this class for: This is an intermediate software development course. We recommend this course to learners who have previous experience in programming, specifically in Java, or a background in computer science and who want to take the next step in designing data structures for more efficient and more complex algorithms.", "created_by": "University of California, San Diego", "title": "Data Structures and Performance"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "How would you search for a longest repeat in a string in LINEAR time? In 1973, Peter Weiner came up with a surprising solution that was based on suffix trees, the key data structure in pattern matching.  Computer scientists were so impressed with his algorithm that they called it the Algorithm of the Year.  In this lesson, we will explore some key ideas for pattern matching that will - through a series of trials and errors - bring us to suffix trees.", "video": ["From Genome Sequencing to Pattern Matching", "Brute Force Approach to Pattern Matching", "Herding Patterns into Trie", "Trie Construction - Pseudocode", "Herding Text into Suffix Trie", "Suffix Trees", "FAQ", "Slides and External References", "Available Programming Languages", "FAQ on Programming Assignments", "Programming Assignment 1"], "title": "Suffix Trees"}, {"description": "Although EXACT pattern matching with suffix trees is fast, it is not clear how to use suffix trees for APPROXIMATE pattern matching.  In 1994, Michael Burrows and David Wheeler invented an ingenious algorithm for text compression that is now known as Burrows-Wheeler Transform. They knew nothing about genomics, and they could not have imagined that 15 years later their algorithm will become the workhorse of biologists searching for genomic mutations. But what text compression has to do with pattern matching??? In this lesson you will learn that the fate of an algorithm is often hard to predict – its applications may appear in a field that has nothing to do with the original plan of its inventors.", "video": ["Burrows-Wheeler Transform", "Inverting Burrows-Wheeler Transform", "Using BWT for Pattern Matching", "Using BWT for Pattern Matching", "Suffix Arrays", "Pattern Matching with Suffix Array", "Approximate Pattern Matching", "FAQ", "Slides and External References", "Programming Assignment 2"], "title": "Burrows-Wheeler Transform and Suffix Arrays"}, {"description": "Congratulations, you have now learned the key pattern matching concepts: tries, suffix trees, suffix arrays and even the Burrows-Wheeler transform! However, some of the results Pavel mentioned remain mysterious: e.g., how can we perform exact pattern matching in O(|Text|) time rather than in O(|Text|*|Pattern|) time as in the naïve brute force algorithm? How can it be that matching a 1000-nucleotide pattern against the human genome is nearly as fast as matching a 3-nucleotide pattern??? Also, even though Pavel showed how to quickly construct the suffix array given the suffix tree, he has not revealed the magic behind the fast algorithms for the suffix tree construction!In this module, Miсhael will address some algorithmic challenges that Pavel tried to hide from you :) such as the Knuth-Morris-Pratt algorithm for exact pattern matching and more efficient algorithms for suffix tree and suffix array construction.", "video": ["Exact Pattern Matching", "Safe Shift", "Prefix Function", "Computing Prefix Function", "Knuth-Morris-Pratt Algorithm", "Programming Assignment 3 lasts for two weeks", "Slides and External References", "Exact Pattern Matching"], "title": "Knuth–Morris–Pratt Algorithm"}, {"description": "In this module we continue studying algorithmic challenges of the string algorithms. You will learn an O(n log n) algorithm for suffix array construction and a linear time algorithm for construction of suffix tree from a suffix array. You will also implement these algorithms and the Knuth-Morris-Pratt algorithm in the last Programming Assignment in this course.", "video": ["Suffix Array", "General Strategy", "Initialization", "Counting Sort", "Sort Doubled Cyclic Shifts", "SortDouble Implementation", "Updating Classes", "Full Algorithm", "Slides and External References", "Suffix Array and Suffix Tree", "LCP Array", "Computing the LCP Array", "Computing the LCP Array - Additional Slides", "Construct Suffix Tree from Suffix Array and LCP Array", "Suffix Tree Construction - Pseudocode", "Slides and External References", "Suffix Array Construction", "Programming Assignment 3"], "title": "Constructing Suffix Arrays and Suffix Trees"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}], "course_info": "About this course: World and internet is full of textual information. We search for information using textual queries, we read websites, books, e-mails. All those are strings from the point of view of computer science. To make sense of all that information and make search efficient, search engines use many string algorithms. Moreover, the emerging field of personalized medicine uses many search algorithms to find disease-causing mutations in the human genome.", "level": "Intermediate", "rating": "4.5", "package_num": "4", "target_audience": "Who is this class for: Programmers with basic experience looking to understand the practical and conceptual underpinnings of algorithms, with the goal of becoming more effective software engineers. Computer science students and researchers as well as interdisciplinary students (studying electrical engineering, mathematics, bioinformatics, etc.) aiming to get more\nprofound understanding of algorithms and hands-on experience implementing them and applying for real-world problems. Applicants who want to prepare for an interview in a high-tech company.", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Algorithms on Strings"}, {"package_name": "Algorithms Specialization ", "week_data": [{"description": "The Bellman-Ford algorithm; all-pairs shortest paths.", "video": ["Week 1 Overview", "Overview, Resources, and Policies", "Lecture Slides", "Single-Source Shortest Paths, Revisted", "Optimal Substructure", "The Basic Algorithm I", "The Basic Algorithm II", "Detecting Negative Cycles", "A Space Optimization", "Internet Routing I [Optional]", "Internet Routing II [Optional]", "Problem Definition", "Optimal Substructure", "The Floyd-Warshall Algorithm", "A Reweighting Technique", "Johnson's Algorithm I", "Johnson's Algorithm II", "Optional Theory Problems (Week 1)", "Problem Set #1", "Programming Assignment #1"], "title": "Week 1"}, {"description": "NP-complete problems and exact algorithms for them.", "video": ["Week 2 Overview", "Polynomial-Time Solvable Problems", "Reductions and Completeness", "Definition and Interpretation of NP-Completeness I", "Definition and Interpretation of NP-Completeness II", "The P vs. NP Question", "Algorithmic Approaches to NP-Complete Problems", "The Vertex Cover Problem", "Smarter Search for Vertex Cover I", "Smarter Search for Vertex Cover II", "The Traveling Salesman Problem", "A Dynamic Programming Algorithm for TSP", "Optional Theory Problems (Week 2)", "Problem Set #2", "Programming Assignment #2"], "title": "Week 2"}, {"description": "Approximation algorithms for NP-complete problems.", "video": ["Week 3 Overview", "A Greedy Knapsack Heuristic", "Analysis of a Greedy Knapsack Heuristic I", "Analysis of a Greedy Knapsack Heuristic II", "A Dynamic Programming Heuristic for Knapsack", "Knapsack via Dynamic Programming, Revisited", "Ananysis of Dynamic Programming Heuristic", "Problem Set #3", "Programming Assignment #3"], "title": "Week 3"}, {"description": "Local search algorithms for NP-complete problems; the wider world of algorithms.", "video": ["Week 4 Overview", "The Maximum Cut Problem I", "The Maximum Cut Problem II", "Principles of Local Search I", "Principles of Local Search II", "The 2-SAT Problem", "Random Walks on a Line", "Analysis of Papadimitriou's Algorithm", "Stable Matching [Optional]", "Matchings, Flows, and Braess's Paradox [Optional]", "Linear Programming and Beyond [Optional]", "Epilogue", "Optional Theory Problems (Week 4)", "Info and FAQ for final exam", "Problem Set #4", "Programming Assignment #4", "Final Exam"], "title": "Week 4"}], "teach_by": [{"department": "Computer Science", "name": "Tim Roughgarden"}], "course_info": "About this course: The primary topics in this part of the specialization are: shortest paths (Bellman-Ford, Floyd-Warshall, Johnson), NP-completeness and what it means for the algorithm designer, and strategies for coping with computationally intractable problems (analysis of heuristics, local search).", "level": "Intermediate", "rating": "4.8", "package_num": "4", "target_audience": "Who is this class for: Learners with at least a little bit of programming experience who want to learn the essentials of algorithms.  In a University computer science curriculum, this course is typically taken in the third year.", "created_by": "Stanford University", "title": "Shortest Paths Revisited, NP-Complete Problems and What To Do About Them"}, {"package_name": "Genomic Data Science Specialization ", "week_data": [{"description": "In this Module, you can expect to study topics of \"Just enough molecular biology\", \"The genome\", \"Writing a DNA sequence\", \"Central dogma\", \"Transcription\", \"Translation\", and \"DNA structure and modifications\".", "video": ["Syllabus", "Pre-Course Survey", "Why Genomics?", "What Is Genomics?", "What Is Genomic Data Science?", "Just Enough Cell Biology", "Important Molecules in Molecular Biology", "The Human Genome Project", "Molecular Biology Structures", "From Genes to Phenotypes", "Quiz 1: Overview and Molecular Biology"], "title": "Overview"}, {"description": "In this module, you'll learn about polymerase chain reaction, next generation sequencing, and applications of sequencing.", "video": ["Polymerase Chain Reaction", "Next Generation Sequencing", "Applications of Sequencing", "Quiz 2: Measurement Technology"], "title": "Measurement Technology"}, {"description": "The lectures for this module cover a few basic topics in computing technology. We'll go over the foundations of computer science, algorithms, memory and data structures, efficiency, software engineering, and computational biology software.", "video": ["What Is Computer Science?", "Algorithms", "Memory and Data Structures", "Efficiency", "Software Engineering", "What is Computational Biology Software", "Quiz 3: Computing Technology"], "title": "Computing Technology"}, {"description": "In this module on Data Science Technology, we'll be covering quite a lot of information about how to handle the data produced during the sequencing process. We'll cover reproducibility, analysis, statistics, question types, the central dogma of inference, analysis code, testing, prediction, variation, experimental design, confounding, power, sample size, correlation, causation, and degrees of freedom.", "video": ["Why Care About Statistics?", "What Went Wrong?", "The Central Dogma of Statistics", "Data Sharing Plans", "Getting Help with Statistics", "Plotting Your Data", "Sample Size and Variability", "Statistical Significance", "Multiple Testing", "Study Design, Batch Effects, and Confounding", "Course Project Instructions and Reading", "Post-Course Survey", "Quiz 4: Data Science Technology", "Course Project"], "title": "Data Science Technology"}], "teach_by": [{"department": "Biomedical Engineering, Computer Science, and Biostatistics", "name": "Steven Salzberg, PhD"}, {"department": "Bloomberg School of Public Health ", "name": "Jeff Leek, PhD"}], "course_info": "About this course: This course introduces you to the basic biology of modern genomics and the experimental tools that we use to measure it. We'll introduce the Central Dogma of Molecular Biology and cover how next-generation sequencing can be used to measure DNA, RNA, and epigenetic patterns. You'll also get an introduction to the key concepts in computing and data science that you'll need to understand how data from next-generation sequencing experiments are generated and analyzed.  \n\nThis is the first course in the Genomic Data Science Specialization.", "level": null, "rating": "4.5", "package_num": "1", "target_audience": null, "created_by": "Johns Hopkins University", "title": "Introduction to Genomic Technologies"}, {"package_name": null, "week_data": [{"description": "Graphical user interfaces turn computer control problem into visual problem solving. The lectures of this module introduce five attempts to enhance current GUI operations such as scrolling interfaces, management of desktop icons, pointing on a large display, digital inking, and vocal interaction.", "video": ["Course Preview", "Introduction", "Course Description", "Syllabus", "Course FAQs", "Problems when running Java Application / Java Applet", "1-1 Scrolling Interface", "Scrolling Interface", "1-2 Desktop Icons", "Desktop Icons", "1-3 Pointing", "Pointing", "1-4 Digital Ink", "Digital Ink", "1-5 Voice Interaction", "Voice Interaction", "Graphical User Interfaces"], "title": "Graphical User Interfaces"}, {"description": "In this module we will dive deep into the world of 2D. We will discuss techniques for authoring 2D drawings and animations. Specifically, we will introduce interactive diagram beautification, pen-and-ink texture synthesis, shape manipulation, and dynamic illustrations. We hope you will witness how interactive software can change burdensome drawing work into full of fun!", "video": ["2-1 Diagram Beautification", "Diagram Beautification", "2-2 Pen-and-ink Textures", "Pen-and-ink Textures", "2-3 Shape Manipulation", "Shape Manipulation", "2-4 Dynamic Illustrations", "Dynamic Illustrations", "2D Drawings and Animations"], "title": "2D Drawings and Animations"}, {"description": "In this module, we rise up from 2D plane to 3D space, and discuss 3D geometric modeling methods. Topics introduced are; suggestive interface for architectural models, a sketch-based modeling system for freeform shapes, a curve-based shape control method, a flower modeling system, and volumetric texture. You will see how 3D objects can be easily and quickly modeled by specially-designed 2D user interfaces!", "video": ["3-1 Suggestive Interface", "Suggestive Interface", "3-2 Sketch-based Modeling", "Sketch-based Modeling", "3-3 Shape Control by Curves", "Shape Control by Curves", "3-4 Flower Modeling", "Flower Modeling", "3-5 Volumetric Textures", "Volumetric Textures", "3D Geometric Modeling"], "title": "3D Geometric Modeling"}, {"description": "Starting from this module, we are shifting our attention towards simulating/crafting real objects and movements, which usually require intricate systems to deal with. As for this module, we will introduce clothing manipulation techniques, layer operations for stacked deformable objects, spatial key framing for character animations, procedural deformation, and human motion visualization using stick figures. You will discover how deformation and animation techniques help visually reproduce complex objects and motions.", "video": ["4-1 Clothing Manipulations", "Clothing Manipulations", "4-2 Layer Operations", "Layer Operations", "4-3 Spatial Key Framing", "Spatial Key Framing", "4-4 Procedural Deformation", "Procedural Deformation", "4-5 Motion Database", "Motion Database", "Deformation and Animation"], "title": "Deformation and Animation"}, {"description": "In this module, we will discuss systems for supporting personal fabrication. In particular, we will introduce systems for designing plush toys, beadworks, chairs, and softly folded objects. In addition, interactive packing method is presented.", "video": ["5-1 Plush Toys", "Plush Toys", "5-2 Beadworks", "Beadworks", "5-3 Chairs", "Chairs", "5-4 Soft Folding", "Soft Folding", "5-5 Interactive Packing", "Interactive Packing", "Fabrication"], "title": "Fabrication"}, {"description": "Nowadays, computers are indispensable for designing products; computers mediate the interaction between designers and products. But in most cases, designing and testing processes are separated, so that designers will not foresee the consequences of their design in real time.\nIn this module, we will discuss computer-aided design supported by simultaneous physical simulation. The works introduced are: systems for designing cantilever, musical instruments, garments, furniture, and gliders. You will see how real-time feedback helps designers improve the output products!", "video": ["6-1 Cantilever", "Cantilever", "6-2 Musical Instruments", "Musical Instruments", "6-3 Garments", "Garments", "6-4 Furniture", "Furniture", "6-5 Gliders", "Gliders", "Computer-aided Design"], "title": "Computer-aided Design"}, {"description": "Computer-operated appliances, such as robotic cleaners, are gradually spreading to general households in recent years. These emerging technologies have opened the door to the new research area, i.e. research on the interactions between ordinary people and robots. In this module, we will discuss interactive techniques and systems for real world interaction. Topics include: a command card interface for robot control, style-by-demonstration for robot behavior design, an actuated puppet device for character posing, a painting interface for robotic lights, and a fur display.", "video": ["7-1 Command Card Interface", "Command Card Interface", "7-2 Style-by-Demonstration", "Style-by-Demonstration", "7-3 Actuated Puppet", "Actuated Puppet", "7-4 Robotic Light", "Robotic Light", "7-5 Fur Display", "Fur Display", "Concluding Remarks", "Students' Work Gallery", "Acknowledgments", "Real World Interaction"], "title": "Real-world Interaction"}], "teach_by": [{"department": "Department of Computer Science, Graduate School of Information Science and Technology", "name": "Takeo Igarashi"}], "course_info": "About this course: Computer graphics can be a powerful tool for supporting visual problem solving, and interactivity plays a central role in harnessing the users' creativity. This course will introduce various interactive tools developed in computer graphics research field with their design rationales and algorithms. Examples include enhancements to graphical user interfaces, authoring tools for 2D drawings and 3D animations, and interactive computer-aided design systems. Rich live demonstrations and course assignments will give you insights and skills to design and implement such tools for your own problems.", "level": "Intermediate", "rating": "4.3", "package_num": null, "target_audience": "Who is this class for: This course is mainly aimed at those who have basic programming skills as well as basic mathematical skills and physics knowledge, since Graded Quizzes assume that students have some experience and knowledge in computer science and programming.\nHowever, auditing the course is also welcome! By watching lecture videos and trying some quizzes, you will gain some insights into creative problem solving. In this case, no background knowledge is expected.", "created_by": "The University of Tokyo", "title": "Interactive Computer Graphics"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "Read mouse input, learn about list methods and dictionaries, draw images", "video": ["Introduction", "Mouse input", "List Methods", "List Examples", "Iteration", "Practice Exercises for Mouse and List Methods (optional)", "Dictionaries", "Images", "Visualizing Iteration", "Programming Tips - 5", "Practice Exercises for Dictionaries and Images (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Quiz 5a", "Quiz 5b", "Memory"], "title": "Week 5 - Mouse input, list methods, dictionaries"}, {"description": "Learn the basics of object-oriented programming in Python using classes, work with tiled images", "video": ["Object-oriented Programming - 1", "Object-oriented Programming - 2", "Working with Objects", "Classes for Blackjack", "Practice Exercises for Classes (part 1) (optional)", "Practice Exercise for Avatar class (optional)", "Tiled Images", "Visualizing Objects", "Programming Tips - 6", "Practice Exercises for Classes (part 2) (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Quiz 6a", "Quiz 6b", "Blackjack"], "title": "Week 6 - Classes and object-oriented programming"}, {"description": "\tUnderstand the math of acceleration and friction, work with sprites, add sound to your game", "video": ["Acceleration and Friction", "Spaceship Class", "Sound", "Sprite Class", "Programming Tips - 7", "Practice Exercises for Sprites and Sound (optional)", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Quiz 7a", "Quiz 7b", "Spaceship"], "title": "Week 7 - Basic game physics, sprites"}, {"description": "Learn about sets in Python, compute collisions between sprites, animate sprites", "video": ["Sets", "Collisions for Sprites", "Practice Exercises for Sets and Collisions (optional)", "Sprite Animation", "Programming Tips - 8", "Mini-project Video", "Mini-project Description", "Code Clinic Tips", "Beyond CodeSkulptor", "Class Wrap-up", "Quiz 8", "RiceRocks"], "title": "Week 8 - Sets and animation"}], "teach_by": [{"department": "Computer Science", "name": "Joe Warren"}, {"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Department of Computer Science ", "name": "John Greiner"}, {"department": "Computer Science", "name": "Stephen Wong"}], "course_info": "About this course: This two-part course is designed to help students with very little or no computing background learn the basics of building simple interactive applications. Our language of choice, Python, is an easy-to learn, high-level computer language that is used in many of the computational courses offered on Coursera. To make learning Python easy, we have developed a new browser-based programming environment that makes developing interactive applications in Python simple. These applications will involve windows whose contents are graphical and respond to buttons, the keyboard and the mouse.\n\nIn part 2 of this course, we will introduce more elements of programming (such as list, dictionaries, and loops) and then use these elements to create games such as Blackjack.  Part 1 of this class will culminate in building a version of the classic arcade game \"Asteroids\".  Upon completing this course, you will be able to write small, but interesting Python programs.  The next course in the specialization will begin to introduce a more principled approach to writing programs and solving computational problems that will allow you to write larger and more complex programs.", "level": "Beginner", "rating": "4.9", "package_num": "2", "target_audience": null, "created_by": "Rice University", "title": "An Introduction to Interactive Programming in Python (Part 2)"}, {"package_name": "Advanced Machine Learning Specialization ", "week_data": [], "teach_by": [{"department": "HSE Faculty of Computer Science", "name": "Pavel Shvechikov"}, {"department": "HSE Faculty of Computer Science", "name": "Alexander Panin"}], "course_info": "About this course: The goal of «Intro to Reinforcement learning» is in its name: introduce students to reinforcement learning – the prominent area of modern research in artificial intelligence.  The reinforcement learning differs much from both supervised and unsupervised learning and is more about how humans learn in reality.  \nStudents will learn from this course both theoretical core and recent practical RL methods. Most importantly, they will learn how to apply such methods to practical problems. In six weeks students will be guided through the basics of Reinforcement Learning (RL):  we will talk about essential theory of RL, value-based methods (such as SARSA and Q-learning), policy based algorithms and methods, designed to solve the optimal exploration problem. In addition to algorithms and theory, during the course we will also present useful practical tips and tricks, needed for learning stabilization, and study how to apply the methods to large scale problems with deep neural networks.", "level": "Intermediate", "rating": null, "package_num": "4", "target_audience": "Who is this class for: The course is designed for people  (1) who already know the basics of machine learning and want to broaden their horizons (2) who have never studied the specifics of reinforcement learning and want to fill that gap  (3) who want to understand the methods and details standing behind the breaking AI news.", "created_by": "National Research University Higher School of Economics", "title": "Practical Reinforcement Learning"}, {"package_name": "Introduction to Discrete Mathematics for Computer Science Specialization ", "week_data": [{"description": "In this week we will discuss integer numbers and standard operations on them: addition, subtraction, multiplication and division. The latter operation is the most interesting one and creates a complicated structure on integer numbers. We will discuss division with a remainder and introduce an arithmetic on the remainders. This mathematical set-up will allow us to created non-trivial computational and cryptographic constructions in further weeks.", "video": ["Numbers", "Divisibility", "Remainders", "Python Code for Remainders", "Division by 4", "Four Numbers", "Division by 101", "Problems", "Divisibility Tests", "Slides", "Division by 2", "Binary System", "Slides", "Modular Arithmetic", "Applications", "Modular Subtraction and Division", "Slides", "Divisibility", "Take the Last Rock", "Remainders", "Properties of Divisibility", "Divisibility Tests", "Division by 2", "Binary System", "Modular Arithmetic", "Remainders of Large Numbers", "Modular Division"], "title": "Modular Arithmetic"}, {"description": "This week we'll study Euclid's algorithm and its applications. This fundamental algorithm is the main stepping-stone for understanding much of modern cryptography! Not only does this algorithm find the greatest common divisor of two numbers (which is an incredibly important problem by itself), but its extended version also gives an efficient way to solve Diophantine equations and compute modular inverses.", "video": ["Greatest Common Divisor", "Greatest Common Divisor", "Euclid’s Algorithm", "Greatest Common Divisor: Code", "Extended Euclid’s Algorithm", "Extended Euclid's Algorithm: Code", "Slides", "Least Common Multiple", "Least Common Multiple", "Diophantine Equations: Examples", "Diophantine Equations", "Diophantine Equations: Theorem", "Modular Division", "Slides", "Tile a Rectangle with Squares", "Least Common Multiple: Code", "Diophantine Equations: Code", "Modular Division: Code"], "title": "Euclid's Algorithm"}, {"description": "Cryptography studies ways to share secrets securely, so that even eavesdroppers can't extract any information from what they hear or network traffic they intercept. One of the most popular cryptographic algorithms called RSA is based on unique integer factorization, Chinese Remainder Theorem and fast modular exponentiation. In this module, we are going to study these properties and algorithms which are the building blocks for RSA. In the next module we will use these building blocks to implement RSA and also to implement some clever attacks against RSA and decypher some secret codes.", "video": ["Introduction", "Prime Numbers", "Integers as Products of Primes", "Existence of Prime Factorization", "Euclid's Lemma", "Unique Factorization", "Implications of Unique Factorization", "Slides", "Remainders", "Chinese Remainder Theorem", "Many Modules", "Slides", "Fast Modular Exponentiation", "Fermat's Little Theorem", "Euler's Totient Function", "Euler's Theorem", "Slides", "Integer Factorization", "Remainders", "Chinese Remainder Theorem", "Fast Modular Exponentiation", "Modular Exponentiation"], "title": "Building Blocks for Cryptography"}, {"description": "Modern cryptography has developed the most during the World War I and World War II, because everybody was spying on everybody. You will hear this story and see why simple cyphers didn't work anymore. You will learn that shared secret key must be changed for every communication if one wants it to be secure. This is problematic when the demand for secure communication is skyrocketing, and the communicating parties can be on different continents. You will then study the RSA cryptosystem which allows parties to exchange secret keys such that no eavesdropper is able to decipher these secret keys in any reasonable time. After that, you will study and later implement a few attacks against incorrectly implemented RSA, and thus decipher a few secret codes and even pass a small cryptographic quest!", "video": ["Cryptography", "One-time Pad", "Many Messages", "Many Time Pad Attack", "Many Time Pad Attack", "Slides", "RSA Cryptosystem", "Simple Attacks", "Small Difference", "Randomness Generation", "Insufficient Randomness", "Hastad's Broadcast Attack", "More Attacks and Conclusion", "RSA Quest Notebook", "Slides and External References", "RSA Quiz", "RSA Quest - Quiz"], "title": "Cryptography"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Computer Science Department", "name": "Vladimir Podolskii"}], "course_info": "About this course: We all learn numbers from the childhood. Some of us like to count, others hate it, but any person uses numbers everyday to buy things, pay for services, estimated time and necessary resources. People have been wondering about numbers’ properties for thousands of years. And for thousands of years it was more or less just a game that was only interesting for pure mathematicians. Famous 20th century mathematician G.H. Hardy once said “The Theory of Numbers has always been regarded as one of the most obviously useless branches of Pure Mathematics”. Just 30 years after his death, an algorithm for encryption of secret messages was developed using achievements of number theory. It was called RSA after the names of its authors, and its implementation is probably the most frequently used computer program in the word nowadays. Without it, nobody would be able to make secure payments over the internet, or even log in securely to e-mail and other personal services. In this short course, we will make the whole journey from the foundation to RSA in 4 weeks. By the end, you will be able to apply the basics of the number theory to encrypt and decrypt messages, and to break the code if one applies RSA carelessly. You will even pass a cryptographic quest!\n\nAs prerequisites we assume only basic math (e.g., we expect you to know what is a square or how to add fractions), basic programming in python (functions, loops, recursion), common sense and curiosity. Our intended audience are all people that work or plan to work in IT, starting from motivated high school students.", "level": "Beginner", "rating": "4.5", "package_num": "4", "target_audience": null, "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Number Theory and Cryptography"}, {"package_name": null, "week_data": [{"description": "After this module, you will be able to\n1. Locate and download files for data analysis involving genes and medicine.\n2. Open files and preprocess data using R language.\n3. Write R scripts to replace missing values, normalize data, discretize data, and sample data.\n", "video": ["Introduction to the Course", "Introduction to Module", "DNA and Genes", "RNA and Proteins", "DNA, RNA, Genes, and Proteins", "Transcription Process", "Transcription Animation", "Translation Process", "Translation Animation", "Transcription and Translation Processes", "Data, Variables, and Big Datasets", "Data, Variables, and Big Datasets", "Working with cBioPortal - Genetic Data Analysis", "Working with cBioPortal - Gene Networks", "Working with cBioPortal", "Module 1 Discussion", "Module 1 cBioPortal Data Analytics", "Module 1 Resources", "Module 1 Quiz", "Module 1 cBioPortal Data Analytics"], "title": "Genes and Data"}, {"description": "After this module, you will be able to: \n1. Locate and download files for data analysis involving genes and medicine.\n2. Open files and preprocess data using R language.\n3. Write R scripts to replace missing values, normalize data, discretize data, and sample data.\n", "video": ["Introduction to Module", "Datasets and Files", "Data Sources", "Datasets and Files", "Importance of Data Preprocessing", "Data Preprocessing Tasks", "Data Preprocessing Tasks", "Replacing Missing Values", "Replacing Missing Values", "Data Normalization", "Data Discretization", "Normalization and Discretization", "Feature Selection", "Data Sampling", "Data Reduction", "Principles of R", "R Language", "Working with R", "Module 2 Notebook", "Jupyter Notebooks 101", "Jupyter Notebooks Essentials", "Notebook Module 2 Tutorial", "Module 2 Discussion", "Module 2 R Data Preprocessing", "Module 2 Notebook", "Module 2 Resources", "Module 2 Quiz", "Module 2 R Data Preprocessing"], "title": "Preparing Datasets for Analysis"}, {"description": "After this module, you will be able to\n1. Select features from highly dimensional datasets.\n2. Evaluate the performance of feature selection methods.\n3. Write R scripts to select features from datasets involving gene expressions.\n", "video": ["Introduction to Module", "Overview of Feature Selection Methods", "Filter Methods", "Wrapper Methods", "Feature Selection Methods", "Evaluation Schemes", "Evaluation Schemes", "Selecting Differentially Expressed Genes", "Differentially Expressed Genes", "Heatmaps", "Heatmaps", "R Scripts for Feature Selection", "Module 3 Notebook", "Notebook Module 3 Tutorial", "Jupyter Notebooks Essentials", "Jupyter Notebooks 101", "Module 3 Discussion", "Module 3 R Finding Differentially Expressed Genes", "Module 3 Notebook", "Module 3 Resources", "Module 3 Quiz", "Module 3 R Finding Differentially Expressed Genes"], "title": "Finding Differentially Expressed Genes"}, {"description": "After this module, you will be able to\n1. Build classification and prediction models.\n2. Evaluate the performance of classification and prediction methods.\n3. Write R scripts to classify and predict diseases from gene expressions.", "video": ["Introduction to Module", "Overview of Classification and Prediction Methods", "Overview", "Classification Methods Based on Analogy", "Classification with Analogy", "Classification Methods Based on Rules", "Classification based on Rules", "Classification Methods Based on Neural Networks", "Classification with Neural Networks", "Classification Methods Based on Statistics", "Classification based on Statistics", "Classification Methods Based on Probabilities", "Classification based on Probabilities", "Prediction Methods", "Prediction Models", "Evaluation Schemes", "Evaluation Schemes", "Prediction Workflow", "R Scripts for Prediction", "Module 4 Notebook", "Jupyter Notebooks Essentials", "Jupyter Notebooks 101", "Notebook Module 4 Tutorial", "Module 4 Discussion", "Module 4 R Predicting Diseases from Genes", "Module 4 Resources", "Module 4 Quiz", "Module 4 R Predicting Diseases from Genes"], "title": "Predicting Diseases from Genes"}, {"description": "After this module, you will be able to\n1. List different types of gene alterations.\n2. Compare and contrast methods for detecting gene mutations.\n3. Compare and contrast methods for detecting methylation.\n4. Compare and contrast methods for detecting copy number variations.\n5. Quantify genomic alterations.\n6. Connect genomic alterations to differential expression of genes.\n7. Write programs in R for determining gene alterations and their relationship with gene expression.\n", "video": ["Introduction to Module", "Overview of Gene Alterations", "Gene Alterations", "Genetic Mutations", "Finding Genetic Mutations", "Gene Mutations", "Methylation", "Methylation", "Copy Number Alterations", "Copy Number Alterations", "Genomic Alterations and Gene Expressions", "Genomic Alterations and Gene Expressions", "R Scripts for Gene Alterations", "Module 5 Notebook", "Jupyter Notebooks 101", "Notebook Module 5 Tutorial", "Jupyter Notebooks Essentials", "Module 5 Discussion", "Module 5 Quiz (Temporary)", "Module 5 R Gene Alterations", "Module 5 Resources", "Module 5 Quiz", "Module 5 R Gene Alterations"], "title": "Determining Gene Alterations"}, {"description": "After this module, you will be able to 1. Find clusters in biomedical data involving genes.2. Analyze and visualize biological pathways. 3. Write R scripts for clustering and for pathway analysis.", "video": ["Introduction to Module", "Overview of Clustering Methods", "Similarity Assessment", "Clustering", "Clustering with KMeans", "Density Based Clustering", "Hierarchical Clustering", "Clustering Methods", "Pathway Analysis", "Pathway Discovery", "Pathway Visualization", "Pathways", "R Scripts for Clustering and Pathway Analysis", "Module 6 Notebook", "Jupyter Notebooks 101", "Jupyter Notebooks Essentials", "Notebook Module 6 Tutorial", "Module 6 Discussion", "Module 6 R Clustering and Pathways", "Module 6 Resources", "Concluding Remarks", "Acknowledgements", "Module 6 Quiz", "Module 6 R Clustering and Pathways"], "title": "Clustering and Pathway Analysis"}], "teach_by": [{"department": "Computer Science", "name": "Isabelle Bichindaritz"}], "course_info": "About this course: This course distills for you expert knowledge and skills mastered by professionals in Health Big Data Science and Bioinformatics. You will learn exciting facts about the human body biology and chemistry, genetics, and medicine that will be intertwined with the science of Big Data and skills to harness the avalanche of data openly available at your fingertips and which we are just starting to make sense of. We’ll investigate the different steps required to master Big Data analytics on real datasets, including Next Generation Sequencing data, in a healthcare and biological context, from preparing data for analysis to completing the analysis, interpreting the results, visualizing them, and sharing the results.\n\nNeedless to say, when you master these high-demand skills, you will be well positioned to apply for or move to positions in biomedical data analytics and bioinformatics. No matter what your skill levels are in biomedical or technical areas, you will gain highly valuable new or sharpened skills that will make you stand-out as a professional and want to dive even deeper in biomedical Big Data. It is my hope that this course will spark your interest in the vast possibilities offered by publicly available Big Data to better understand, prevent, and treat diseases.", "level": "Advanced", "rating": "4.1", "package_num": null, "target_audience": "Who is this class for: This course is primarily aimed at health care professionals or assistants, and those with a BS/MA/MS in science or technology or equivalent professional experience. Minimum technical skills are a good understanding of using an Excel spreadsheet. Additional prerequisite knowledge in basic statistics would be preferred, however additional resources will be made available to learners to acquire this knowledge.\n\nI think that anyone interested in getting insights into how to harness Big Data to better understand, prevent, and treat diseases can take this course because the material can be applied at different levels of expertise.\n", "created_by": "The State University of New York", "title": "Big Data, Genes, and Medicine"}, {"package_name": "Advanced Machine Learning Specialization ", "week_data": [], "teach_by": [{"department": "HSE Faculty of Computer Science", "name": "Anna Potapenko"}, {"department": "HSE Faculty of Computer Science", "name": "Alexey Zobnin"}, {"department": "Yandex", "name": "Anna Kozlova"}, {"department": "Yandex", "name": "Sergey Yudin"}, {"department": "HSE Faculty of Computer Science", "name": "Andrei Zimovnov"}], "course_info": "About this course: This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. Upon completing, you will be able to recognize NLP tasks in your day-to-day work, propose approaches, and judge what techniques are likely to work well.  The final project is devoted to one of the most hot topics in today’s NLP. You will build your own conversational chat-bot that will assist with search on StackOverflow website. The project will be based on practical assignments of the course, that will give you hands-on experience with such tasks as text classification, named entities recognition, and duplicates detection. \n\nThroughout the lectures, we will aim at finding a balance between traditional and deep learning techniques in NLP and cover them in parallel. For example, we will discuss word alignment models in machine translation and see how similar it is to attention mechanism in encoder-decoder neural networks. Core techniques are not treated as black boxes. On the contrary, you will get in-depth understanding of what’s happening inside. To succeed in that, we expect your familiarity with the basics of linear algebra and probability theory, machine learning setup, and deep neural networks. Some materials are based on one-month-old papers and introduce you to the very state-of-the-art in NLP research.", "level": "Advanced", "rating": null, "package_num": "6", "target_audience": "Who is this class for: This course is for those who are interested in NLP field and want to know the current state-of-the-art in research and production. We expect that you have already taken some courses on machine learning and deep learning, but probably have never applied those models to texts and want to get a quick start.", "created_by": "National Research University Higher School of Economics", "title": "Natural Language Processing"}, {"package_name": null, "week_data": [{"description": "", "video": ["01-课程介绍", "02-正式内容之前：形式化及其极限", "03-正式内容之前：悖论、版画、卡农", "04-数理逻辑介绍", "05-什么是命题", "06-排中律", "07-命题符号化", "08-逻辑联结词（上）", "09-逻辑联结词（下）", "10-命题公式", "11-真值函数", "12-命题形式化", "课件", "测验#1"], "title": "数理逻辑：基本概念"}, {"description": "", "video": ["13-重言式", "14-逻辑等价式和逻辑蕴涵式", "15-代入原理和替换原理", "16-证明逻辑等价式和逻辑蕴涵式", "17-范式及基本术语", "18-求范式的一般步骤", "19-主范式", "20-联结词集完备性", "21-形式系统和证明、演绎", "22-命题演算形式系统PC", "23-PC中的定理证明", "24-三个元定理", "25-定理判定问题", "课件", "测验#2"], "title": "数理逻辑：命题逻辑及形式系统 "}, {"description": "", "video": ["26-数理逻辑-个体、谓词和量词", "27-数理逻辑-谓词公式", "28-数理逻辑-谓词公式永真式", "29-数理逻辑-谓词演算形式系统FC", "30-数理逻辑-全称引入规则及存在消除规则", "31-数理逻辑-自然推理系统", "32-数理逻辑-ND中的定理证明", "课件", "测验#3"], "title": "数理逻辑：谓词逻辑及形式系统"}, {"description": "", "video": ["33-集合论与无限", "34-集合基本概念", "35-子集合", "36-集合基本运算", "37-集合族及运算", "38-归纳定义", "39-自然数的定义", "40-归纳原理", "41-数学归纳法", "课件", "测验#4"], "title": "集合论：集合代数"}, {"description": "", "video": ["42-有序组", "43-笛卡尔积", "44-关系定义", "45-关系运算", "46-关系合成运算", "47-关系基本特性", "48-关系特性定理", "课件", "测验#5"], "title": "集合论：集合代数"}, {"description": "", "video": ["49-等价关系", "50-等价关系与划分", "51-划分之间的关系", "52-划分运算", "53-序关系", "54-序关系中的特殊元素", "55-函数", "56-函数合成", "57-特殊函数类", "课件", "测验#6"], "title": "集合论：特殊关系及函数"}, {"description": "", "video": ["58-图的定义", "59-图的基本概念", "60-度和正则图", "61-子图与同构图", "62-路径与连通性", "63-连通性", "64-欧拉图与哈密顿图", "课件", "测验#7"], "title": "图论：图的基本概念"}, {"description": "", "video": ["65-图的矩阵表示", "66-二分图", "67-二分图的匹配", "68-平面图", "69-树", "70-树的应用", "课件", "测验#8"], "title": "图论：特殊图"}, {"description": "", "video": ["71-引言", "72-代数结构", "73-幺元", "74-零元", "75-逆元", "76-可约元素", "77-同构与同态", "78-同余关系", "79-群环域", "课件", "测验#9"], "title": "抽象代数"}, {"description": "", "video": ["80-语言及研究方向", "81-形式语言", "82-短语结构语法", "83-语言及语法表示", "84-形式语法分类", "85-语法分析", "86-BNF范式", "87-语法图", "88-正则语法", "课件", "测验#10"], "title": "形式语言与自动机：基本概念"}, {"description": "", "video": ["89-有限状态机", "90-状态图", "91-泵引理", "92-机器同余", "93-商机器", "94-商机器的性质", "95-机器化简", "96-带输出的机器", "97-程序实现状态机", "课件", "测验#11"], "title": "形式语言与自动机：有限状态机"}, {"description": "", "video": ["98-图灵机", "99-图灵机例子", "100-图灵机变种", "101-识别与判定", "102-哥德尔编码", "103-通用图灵机", "104-停机问题", "105-哥德尔不完备定理", "106-不可判定问题", "课件", "测验#12"], "title": "形式语言与自动机：图灵机与计算理论"}, {"description": "", "video": ["期末考试"], "title": "期末考试"}], "teach_by": [{"department": "北京大学", "name": "陈斌"}], "course_info": "About this course: 离散数学是计算机科学的基础理论，离散结构的基础知识和逻辑思维的形式化是信息技术类学生的基本功，离散数学的基本概念是理科专业学生进行信息类课程学习的重要基础。\n\n本课程介绍计算机科学和信息技术理论基础的概念和思想方法，介绍数理逻辑、集合论、图论、抽象代数和形式语言与自动机等各部分的基本概念，介绍离散数学基本概念和空间信息技术之间的联系与结合，培养学生理解和掌握离散数学基本概念，采用形式化方法分析问题，并能自觉运用逻辑分析、结构层次分析和同构类比等思想方法解决问题的能力。", "level": "Beginner", "rating": "4.8", "package_num": null, "target_audience": "Who is this class for: 本课程面向非计算机软件专业本科生及相关IT行业从业人士，介绍计算机科学和信息技术理论基础的概念和思想方法。先修过《高等数学》《计算概论》《数据结构与算法》等理科基础课程最好，但这些先修课并不是必须的，有基本数理概念也可以选修本课程。", "created_by": "Peking University", "title": "离散数学概论 Discrete Mathematics Generality"}, {"package_name": "Probabilistic Graphical Models  Specialization ", "week_data": [{"description": "This module provides a high-level overview of the main types of inference tasks typically encountered in graphical models: conditional probability queries, and finding the most likely assignment (MAP inference).", "video": ["Overview: Conditional Probability Queries", "Overview: MAP Inference"], "title": "Inference Overview "}, {"description": "This module presents the simplest algorithm for exact inference in graphical models: variable elimination. We describe the algorithm, and analyze its complexity in terms of properties of the graph structure.", "video": ["Variable Elimination Algorithm", "Complexity of Variable Elimination", "Graph-Based Perspective on Variable Elimination", "Finding Elimination Orderings", "Variable Elimination"], "title": "Variable Elimination"}, {"description": "This module describes an alternative view of exact inference in graphical models: that of message passing between clusters each of which encodes a factor over a subset of variables. This framework provides a basis for a variety of exact and approximate inference algorithms. We focus here on the basic framework and on its instantiation in the exact case of clique tree propagation. An optional lesson describes the loopy belief propagation (LBP) algorithm and its properties.", "video": ["Belief Propagation Algorithm", "Properties of Cluster Graphs", "Properties of Belief Propagation", "Clique Tree Algorithm - Correctness", "Clique Tree Algorithm - Computation", "Clique Trees and Independence", "Clique Trees and VE", "BP In Practice", "Loopy BP and Message Decoding", "Message Passing in Cluster Graphs", "Clique Tree Algorithm", "Exact Inference"], "title": "Belief Propagation Algorithms "}, {"description": "This module describes algorithms for finding the most likely assignment for a distribution encoded as a PGM (a task known as MAP inference). We describe message passing algorithms, which are very similar to the algorithms for computing conditional probabilities, except that we need to also consider how to decode the results to construct a single assignment. In an optional module, we describe a few other algorithms that are able to use very different techniques by exploiting the combinatorial optimization nature of the MAP task.", "video": ["Max Sum Message Passing", "Finding a MAP Assignment", "Tractable MAP Problems", "Dual Decomposition - Intuition", "Dual Decomposition - Algorithm", "MAP Message Passing"], "title": "MAP Algorithms"}, {"description": "In this module, we discuss a class of algorithms that uses random sampling to provide approximate answers to conditional probability queries. Most commonly used among these is the class of Markov Chain Monte Carlo (MCMC) algorithms, which includes the simple Gibbs sampling algorithm, as well as a family of methods known as Metropolis-Hastings.", "video": ["Simple Sampling", "Markov Chain Monte Carlo", "Using a Markov Chain", "Gibbs Sampling", "Metropolis Hastings Algorithm", "Sampling Methods", "Sampling Methods", "Sampling Methods PA Quiz"], "title": "Sampling Methods"}, {"description": "In this brief lesson, we discuss some of the complexities of applying some of the exact or approximate inference algorithms that we learned earlier in this course to dynamic Bayesian networks.", "video": ["Inference in Temporal Models", "Inference in Temporal Models"], "title": "Inference in Temporal Models"}, {"description": "This module summarizes some of the topics that we covered in this course and discusses tradeoffs between different algorithms. It also includes the course final exam.", "video": ["Inference: Summary", "Inference Final Exam"], "title": "Inference Summary"}], "teach_by": [{"department": "School of Engineering", "name": "Daphne Koller"}], "course_info": "About this course: Probabilistic graphical models (PGMs) are a rich framework for encoding probability distributions over complex domains: joint (multivariate) distributions over large numbers of random variables that interact with each other. These representations sit at the intersection of statistics and computer science, relying on concepts from probability theory, graph algorithms, machine learning, and more. They are the basis for the state-of-the-art methods in a wide variety of applications, such as medical diagnosis, image understanding, speech recognition, natural language processing, and many, many more. They are also a foundational tool in formulating many machine learning problems. \n\nThis course is the second in a sequence of three. Following the first course, which focused on representation, this course addresses the question of probabilistic inference: how a PGM can be used to answer questions. Even though a PGM generally describes a very high dimensional distribution, its structure is designed so as to allow questions to be answered efficiently. The course presents both exact and approximate algorithms for different types of inference tasks, and discusses where each could best be applied. The (highly recommended) honors track contains two hands-on programming assignments, in which key routines of the most commonly used exact and approximate algorithms are implemented and applied to a real-world problem.", "level": "Advanced", "rating": "4.6", "package_num": "2", "target_audience": null, "created_by": "Stanford University", "title": "Probabilistic Graphical Models 2: Inference"}, {"package_name": "Probabilistic Graphical Models  Specialization ", "week_data": [{"description": "This module presents some of the learning tasks for probabilistic graphical models that we will tackle in this course.", "video": ["Learning: Overview"], "title": "Learning: Overview"}, {"description": "This module contains some basic concepts from the general framework of machine learning, taken from Professor Andrew Ng's Stanford class offered on Coursera. Many of these concepts are highly relevant to the problems we'll tackle in this course.", "video": ["Regularization: The Problem of Overfitting ", "Regularization: Cost Function ", "Evaluating a Hypothesis ", "Model Selection and Train Validation Test Sets ", "Diagnosing Bias vs Variance ", "Regularization and Bias Variance"], "title": "Review of Machine Learning Concepts from Prof. Andrew Ng's Machine Learning Class (Optional)"}, {"description": "This module discusses the simples and most basic of the learning problems in probabilistic graphical models: that of parameter estimation in a Bayesian network. We discuss maximum likelihood estimation, and the issues with it. We then discuss Bayesian estimation and how it can ameliorate these problems.", "video": ["Maximum Likelihood Estimation", "Maximum Likelihood Estimation for Bayesian Networks", "Bayesian Estimation", "Bayesian Prediction", "Bayesian Estimation for Bayesian Networks", "Learning in Parametric Models", "Bayesian Priors for BNs"], "title": "Parameter Estimation in Bayesian Networks"}, {"description": "In this module, we discuss the parameter estimation problem for Markov networks - undirected graphical models. This task is considerably more complex, both conceptually and computationally, than parameter estimation for Bayesian networks, due to the issues presented by the global partition function.", "video": ["Maximum Likelihood for Log-Linear Models", "Maximum Likelihood for Conditional Random Fields", "MAP Estimation for MRFs and CRFs", "Parameter Estimation in MNs", "CRF Learning for OCR"], "title": "Learning Undirected Models"}, {"description": "This module discusses the problem of learning the structure of Bayesian networks. We first discuss how this problem can be formulated as an optimization problem over a space of graph structures, and what are good ways to score different structures so as to trade off fit to data and model complexity. We then talk about how the optimization problem can be solved: exactly in a few cases, approximately in most others.", "video": ["Structure Learning Overview", "Likelihood Scores", "BIC and Asymptotic Consistency", "Bayesian Scores", "Learning Tree Structured Networks", "Learning General Graphs: Heuristic Search", "Learning General Graphs: Search and Decomposability", "Structure Scores", "Tree Learning and Hill Climbing", "Learning Tree-structured Networks"], "title": "Learning BN Structure"}, {"description": "In this module, we discuss the problem of learning models in cases where some of the variables in some of the data cases are not fully observed. We discuss why this situation is considerably more complex than the fully observable case. We then present the Expectation Maximization (EM) algorithm, which is used in a wide variety of problems.", "video": ["Learning With Incomplete Data - Overview", "Expectation Maximization - Intro", "Analysis of EM Algorithm", "EM in Practice", "Latent Variables", "Learning with Incomplete Data", "Expectation Maximization", "Learning with Incomplete Data"], "title": "Learning BNs with Incomplete Data"}, {"description": "This module summarizes some of the issues that arise when learning probabilistic graphical models from data. It also contains the course final.", "video": ["Summary: Learning", "Learning: Final Exam"], "title": "Learning Summary and Final"}, {"description": "This module contains an overview of PGM methods as a whole, discussing some of the real-world tradeoffs when using this framework in practice. It refers to topics from all three of the PGM courses.", "video": ["PGM Course Summary"], "title": "PGM Wrapup"}], "teach_by": [{"department": "School of Engineering", "name": "Daphne Koller"}], "course_info": "About this course: Probabilistic graphical models (PGMs) are a rich framework for encoding probability distributions over complex domains: joint (multivariate) distributions over large numbers of random variables that interact with each other. These representations sit at the intersection of statistics and computer science, relying on concepts from probability theory, graph algorithms, machine learning, and more. They are the basis for the state-of-the-art methods in a wide variety of applications, such as medical diagnosis, image understanding, speech recognition, natural language processing, and many, many more. They are also a foundational tool in formulating many machine learning problems. \n\nThis course is the third in a sequence of three. Following the first course, which focused on representation, and the second, which focused on inference, this course addresses the question of learning: how a PGM can be learned from a data set of examples. The course discusses the key problems of parameter estimation in both directed and undirected models, as well as the structure learning task for directed models. The (highly recommended) honors track contains two hands-on programming assignments, in which key routines of two commonly used learning algorithms are implemented and applied to a real-world problem.", "level": "Advanced", "rating": "4.7", "package_num": "3", "target_audience": null, "created_by": "Stanford University", "title": "Probabilistic Graphical Models 3: Learning"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "This week, we will introduce you to the structure and standards of the Principles of Computing courses.", "video": ["Principles of Computing ", "Introduction", "Required Python Knowledge", "Required Python Knowledge", "Coding Style and Standards", "Guidelines for Coding Style", "Python Modules", "Importing Custom Modules in Python", "Machine Grading", "Mini-project Video", "Mini-project Description", "2048", "Assignment Submission History", "Math Expressions for Homework", "Math Notes on Functions", "Practice Mini-project - Solitaire Mancala", "CodeSkulptor", "Saving in CodeSkulptor", "Beyond CodeSkulptor (15:12) (optional video)", "Python Development Environments", "Homework 1", "Assignment: 2048 (Merge)"], "title": "Required Python knowledge, coding standards, and machine grading"}, {"description": "This week, we will explain the importance of testing.  We will also learn to solve problems with grids.", "video": ["The Importance of Testing ", "Testing", "Building Tests for Python Programs", "Plotting", "Grids", "Mini-project Video", "Mini-project Description", "Math Notes on Grid Representations", "Practice Activity - Testing Solitaire Mancala", "Homework 2", "Assignment: 2048 (Full)"], "title": "Testing, plotting, and grids"}, {"description": "This we will learn how to use probability and randomness to solve problems.", "video": ["The Importance of Probability ", "Basics of Probability", "Expected Value ", "Monte Carlo Methods", "Objects and References ", "Mini-project Video", "Mini-project Description", "TTTBoard Class", "Math Notes on Basic Probability", "Math Notes on Expected Value", "Practice Mini-project - Nim (Monte Carlo)", "Practice Activity - The Monty Hall Problem", "Homework 3", "Assignment: Tic-Tac-Toe (Monte Carlo)"], "title": "Probability, randomness, and objects/references"}, {"description": "This week, we will learn how to use combinatorics to solve problems.", "video": ["The Importance of Combinatorics ", "Enumeration", "Permutations and Combinations", "Combinatorics and Password Breaking ", "Debugging", "Mini-project Video", "Mini-project Description", "Math Notes on Enumeration", "Math Notes on Permutations and Combinations", "Practice Activity - Analyzing a Simple Dice Game", "Practice Activity - Counting Game States", "Homework 4", "Assignment: Yahtzee"], "title": "Combinatorics, generators, and debugging"}, {"description": "This week, we will explain the importance of counting in solving complex problems.", "video": ["The Importance of Counting ", "Counting and Sums", "Functions: Finding the Max ", "Higher-order Functions ", "Plotting Statement Counts", "Mini-project Video", "Mini-project Description", "BuildInfo Class", "Math Notes on Arithmetic Sums", "Math Notes on Logarithms and Exponentials", "Math Notes on Growth Rates of Functions", "Practice Activity - Modeling the Growth of Functions", "Practice Activity - The Case of the Greedy Boss", "Homework 5", "Assignment: Cookie Clicker"], "title": "Counting, growth of functions, higher-order functions"}], "teach_by": [{"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science", "name": "Joe Warren"}, {"department": "Computer Science; Biochemistry and Cell Biology ", "name": "Luay Nakhleh"}], "course_info": "About this course: This two-part course builds upon the programming skills that you learned in our Introduction to Interactive Programming in Python course.  We will augment those skills with both important programming practices and critical mathematical problem solving skills.  These skills underlie larger scale computational problem solving and programming. The main focus of the class will be programming weekly mini-projects in Python that build upon the mathematical and programming principles that are taught in the class. To keep the class fun and engaging, many of the projects will involve working with strategy-based games.\n\nIn part 1 of this course, the programming aspect of the class will focus on coding standards and testing.  The mathematical portion of the class will focus on probability, combinatorics, and counting with an eye towards practical applications of these concepts in Computer Science.  \n\nRecommended Background - Students should be comfortable writing small (100+ line) programs in Python using constructs such as lists, dictionaries and classes and also have a high-school math background that includes algebra and pre-calculus.", "level": "Intermediate", "rating": "4.8", "package_num": "3", "target_audience": null, "created_by": "Rice University", "title": "Principles of Computing (Part 1)"}, {"package_name": null, "week_data": [], "teach_by": [{"department": "Computer Science", "name": "Robert Sedgewick"}], "course_info": "About this course: This course teaches a calculus that enables precise quantitative predictions of large combinatorial structures. In addition, this course covers generating functions and real asymptotics and then introduces the symbolic method in the context of applications in the analysis of algorithms and basic structures such as permutations, trees, strings, words, and mappings.", "level": "Advanced", "rating": null, "package_num": null, "target_audience": null, "created_by": "Princeton University", "title": "Analysis of Algorithms"}, {"package_name": null, "week_data": [{"description": "In this module you will become familiar with the course and our learning environment. The orientation will also help you obtain the technical skills required for the course.", "video": ["Welcome and Introduction", "Syllabus", "Demographics Survey", "Tools For This Course", "KBDD", "MiniSat", "Espresso", "SIS"], "title": "Orientation"}, {"description": "In this module, we will introduce advanced Boolean algebra math concepts that make it possible to take a \"computational\" approach to Boolean algebra. ", "video": ["Week 1 Overview", "Computational Boolean Algebra: Basics", "Computational Boolean Algebra: Boolean Difference", "Computational Boolean Algebra: Quantification Operators", "Computational Boolean Algebra: Application to Logic Network Repair", "Computational Boolean Algebra: Recursive Tautology", "Computational Boolean Algebra: Recursive Tautology—URP Implementation", "Week 1 Assignments"], "title": "Computational Boolean Algebra"}, {"description": "Week 2 introduces two powerful and important representation techniques that allow us to do SERIOUS computational Boolean algebra, on industrial-scale designs.", "video": ["Week 2 Overview", "BDD Basics, Part 1", "BDD Basics, Part 2", "BDD Sharing", "BDD Ordering", "Satisfiability (SAT), Part 1", "Boolean Constraint Propagation (BCP) for SAT", "Using SAT for Logic", "Week 2 Assignments", "Problem Set #1", "Programming Assignment #1: Unate Recursive Complement"], "title": "Boolean Representation via BDDs and SAT"}, {"description": "In Week 3, we will move from \"representing\" things to \"synthesizing\" things. In this case, synthesis means \"optimization\", or maybe the word \"minimization\" is more familiar from hand work with Kmaps or Boolean algebra.", "video": ["Week 3 Overview", "2-Level Logic: Basics", "2-Level Logic: The Reduce-Expand-Irredundant Optimization Loop", "2-Level Logic: Details for One Step: Expand", "Multilevel Logic and the Boolean Network Model", "Multilevel Logic: Algebraic Model for Factoring", "Multilevel Logic: Algebraic Division", "Multilevel Logic: Role of Kernels and Co-Kernels in Factoring", "Multilevel Logic: Finding the Kernels", "Week 3 Assignments", "Problem Set #2"], "title": "2-Level Logic Synthesis, and Multi-Level Logic Synthesis via the Algebraic Model"}, {"description": "You now know that to factor a multi-level network to reduce its complexity, you must look at the kernels and co-kernels. You know how to \"get\" these for any node. But -- what do you do with a big network to actually FIND the right common divisors? This is called EXTRACTION. We then look at a new opportunity to optimize multi-level logic: Don't Cares. In simple designs, we usually regard Don't Cares as \"impossible inputs\" -- things that just do not happen, so we can choose the value the hardware creates to minimize the logic.", "video": ["Week 4 Overview", "Mulitlevel Logic and Divisor Extraction—Single Cube Case", "Mulitlevel Logic and Divisor Extraction—Multiple Cube Case", "Multilevel Logic and Divisor Extraction—Finding Prime Rectangles & Summary", "Multilevel Logic—Implicit Don't Cares, Part 1", "Multilevel Logic—Implicit Don't Cares, Part 2", "Multilevel Logic—Satisfiability Don't Cares", "Multilevel Logic—Controllability Don't Cares", "Multilevel Logic—Observability Don't Cares", "Week 4 Assignments", "Problem Set #3", "Programming Assignment #2: Serious BDDs", "Auxiliary Quiz of Serious BDDs"], "title": "Multilevel Factor Extract and Don't Cares"}, {"description": "There is no new content this week. Instead, you should focus on finishing the last problem set and completing the Final Exam.", "video": ["End of Course Survey", "Problem Set #4", "Final Exam"], "title": "Final Exam"}], "teach_by": [{"department": "Department of Computer Science", "name": "Rob A. Rutenbar"}], "course_info": "About this course: A modern VLSI chip has a zillion parts -- logic, control, memory, interconnect, etc.  How do we design these complex chips?  Answer: CAD software tools.  Learn how to build thesA modern VLSI chip is a remarkably complex beast:  billions of transistors, millions of logic gates deployed for computation and control, big blocks of memory, embedded blocks of pre-designed functions designed by third parties (called “intellectual property” or IP blocks).  How do people manage to design these complicated chips?  Answer: a sequence of computer aided design (CAD) tools takes an abstract description of the chip, and refines it step-wise to a final design. This class focuses on the major design tools used in the creation of an Application Specific Integrated Circuit (ASIC) or System on Chip (SoC) design. Our focus in this first part of the course is on key Boolean logic representations that make it possible to synthesize, and to verify, the gate-level logic in these designs.  This is the first step of the design chain, as we move from logic to layout.    Our goal is for students to understand how the tools themselves work, at the level of their fundamental algorithms and data structures. Topics covered will include: Computational Boolean algebra, logic verification, and logic synthesis (2-level and multi-level).\n\nRecommended Background\nProgramming experience (C, C++, Java, Python, etc.) and basic knowledge of data structures and algorithms (especially recursive algorithms).  An understanding of basic digital design:  Boolean algebra, Kmaps, gates and flip flops, finite state machine design.  Linear algebra and calculus at the level of a junior or senior in engineering.  Exposure to basic VLSI at an undergraduate level is nice -- but it’s not necessary.  We will keep the course self-contained, but students with some VLSI will be able to skip some background material.e tools in this class.", "level": "Intermediate", "rating": "4.8", "package_num": null, "target_audience": "Who is this class for: You should be taking this course if (1) you are interested in building VLSI design tools; (2) you are interested in designing VLSI chips, and you want to know why the tools do what they do; (3) you just like cool algorithms, that work on big cool problems that involve bits, and gates, and geometry, and graphs, and matrices, and time, etc.", "created_by": "University of Illinois at Urbana-Champaign", "title": "VLSI CAD Part I: Logic"}, {"package_name": "Object Oriented Java Programming: Data Structures and Beyond Specialization ", "week_data": [{"description": "Welcome to the first week in the third course of our Intermediate Java Programming Specialization.  Once again start with introductions, and in particular introduce the unique structure of this course.  Also, if you're not sure if this course is right for you, we've got an optional pre-course quiz coming right up that can help you figure out if you're in the right place.  If you decide to stay with us (and we really hope you will!) we've got a great backbone project for you: your very own mapping application, inspired by Google Maps!  The core data structure throughout this course is graphs, which may very well be the most fundamental data structure in all of computer science.  Ready to begin?  So are we!", "video": ["Welcome", "After completing this course, you will be able to ...", "Is this course right for me?", "Pre-course quiz", "Up Next: A short survey", "Survey: Your goals for the course", "If you want more practice before you begin...", "The structure of this course", "Your path through this course", "Concept challenges", "Welcome from the Google engineers", "Introduce Yourself!", "Project Overview", "Project Prototype", "Setting up Java and Eclipse", "Getting and Setting up the Starter Code", "Project: Orientation to the Starter Code, Data Files and Front-end", "Course Structure and Starter Code Quiz (make sure you can run the starter code first)"], "title": "Introduction to the Course"}, {"description": "This week we'll start getting technical, introducing you to the central data structure in the course: Graphs.  You'll learn the basics and then have a chance to dive in a little deeper into the code, getting ready to start building that Google Maps-like application.", "video": ["Introduction", "A note about week numbers", "By the end of this week, you will be able to...", "Project: Introduction to Graphs Project Overview", "Core: What's a graph?", "Core: Graph definitions", "In the real world: Graphs at Google", "In the real world: More graphs at Google", "Graphs", "(Read only AFTER finishing Graphs Quiz)", "Core: Implementing graphs in Java", "Core: Adjacency matrix", "Core: Adjacency list", "Where to next?", "Concept Challenge: Comparing implementations of graphs", "In the real world: Performance considerations", "When I struggled: Analyzing implementations", "Core: Neighbors", "Support: Coding getNeighbors", "Support: Coding 2-Hop Neighbors", "Support: Multiplying Adjacency Matrices", "Graph definitions and implementation: a glossary", "Week 2: Additional Resources", "Project: Programming Assignment Walkthrough", "Programming Assignment FAQ", "Graph definitions and implementations Quiz Answer explanations (Read ONLY after you pass the quiz)", "Project: Implementing Graphs", "Graph definitions and implementation"], "title": "Introduction to Graphs"}, {"description": "This week you'll get the backbone of your map search engine up and running.  In previous courses, including the previous courses in this specialization, you've probably been given most of the classes you needed to complete the assignments.  But learning how to design classes from scratch is a key skill that you will need as you become a more sophisticated Java programmer.  This week we'll give you the tools you need to create a robust and elegant class design for your map search engine.  We'll introduce a similar problem and show you how it can be represented as a graph.  Then we'll introduce two core search algorithms: depth-first search and breadth-first search.  Finally, we'll turn our graph problem into a set of Java classes.   Your task on the programming assignment this week will be to do the same thing, but in the context on the map search engine!", "video": ["Introduction", "By the end of this week, you will be able to ...", "Project: Route Finding Project Overview", "Core: Intro to Class Design", "When I struggled: Building useful classes", "In the Real World: Design patterns", "Core: DFS, Part 1", "Core: DFS, Part 2", "Core: BFS", "Support: Developing Small Examples to Test Your Code", "Where to next?", "When I struggled: Data structures jargon", "When I struggled: The right data structure for the job", "Concept Challenge: Performance of DFS and BFS", "Core: Class Design", "When I struggled: If you fail to plan ...", "When I struggled: ... but don't forget to start!", "In the real world: Planning ahead with design", "Core: Refactoring", "Support: Where to start the project design?", "In the Real World: Why is code refactored?", "Week 3: Additional Resources", "Project: Programming Assignment Walk-through", "End of Week Quiz Answers", "Project: Class Design and Graph Search", "Code Design Peer Review", "End of Week Quiz (complete project and peer review first)"], "title": "Class design and simple graph search"}, {"description": "In the past two weeks, you've developed a strong understanding of how to design classes to represent a graph and how to use a graph to represent a map.  In this week, you'll add a key feature of map data to our graph representation -- distances -- by adding weights to your edges to produce a \"weighted graph\".  Although this might seem like a small change, the algorithms that work for unweighted graphs may prove ineffective for weighted graphs.  To address this problem, you'll explore more advanced shortest path algorithms.  First, you'll see how to find the shortest path on a weighted graph, then you'll see how to find it more quickly.  In the project, you'll apply these ideas to create the core of any good mapping application: finding the shortest route from one location to another.", "video": ["Introduction", "By the end of this week, you will be able to ...", "Project: Shortest Path Overview", "Core: Shortest Path with BFS", "Core: Geographic Maps", "Core: Dijkstra's Algorithm", "Concept Challenge: Performance of Dijkstra's Algorithm", "Core: A* Search Algorithm", "When I struggled: Tackling large programming projects", "When I Struggled: Remembering classical algorithms", "Week 4: Additional Resources", "Project: Shortest Path Programming Assignment Walkthrough", "Test cases and debugging guide for the quiz", "End of Week Quiz Answers", "Project: Shortest Path", "End of Week Quiz (very short, do programming assignment first)"], "title": "Finding shortest paths in weighted graphs"}, {"description": "In this week, we'll go beyond the problem of finding a path between two points, and focus on problems requiring overall path planning.  For example, if you wanted to go on errands and visit 6 different locations before returning home, what is the optimal route? This problem is actually a really well known problem in computer science known as the Travelling Salesperson Problem (TSP).  Attempting to solve the problem will lead us to explore complexity theory, what it means to be NP-Hard, and how to solve \"hard\" problems using heuristics and approximation algorithms.  We'll end the week by showing how reformulating a problem can have a huge impact: making something which was effectively unsolvable before, now solvable!  ", "video": ["Introduction", "By the end of this week, you will be able to ...", "Core: Traveling Salesperson Problem (TSP)", "Concept Challenge: An algorithm for TSP", "Core: TSP Brute-Force Algorithm", "Core: TSP Algorithm Running Time", "Core: NP Hard", "Core: Approximations and Heuristics", "Core: Hamiltonian Graphs", "Core: Eulerian graphs", "Core: Eulerian graphs, an algorithm", "Core: An application in bioinformatics", "Week 5: Additional Resources", "End of Week Quiz Answers", "End of Week Quiz"], "title": "Route planning and NP-hard graph problems"}, {"description": "You made it to the last week of our course!  We're glad you're still with us.  As a reward, there's no new content to learn this week.  Instead you'll get the opportunity to extend your project in a direction of your own choosing.  We hope you've got some neat ideas for personalizing your map application, and we look forward to seeing them in the peer review gallery.  Submitting to the peer review gallery is optional (though the extension is required), but we hope you'll choose to participate.  ", "video": ["Week 6 Introduction", "Project: Week 6 Description -- REQUIRED EXTENSION", "Project Extension Feedback", "End of course message", "Week 6 Project Quiz (Complete your project extension first)"], "title": "End of Course Project Extension"}], "teach_by": [{"department": "Computer Science and Engineering", "name": "Leo Porter"}, {"department": "Computer Science and Engineering", "name": "Mia Minnes"}, {"department": "Computer Science and Engineering", "name": "Christine Alvarado"}], "course_info": "About this course: How does Google Maps plan the best route for getting around town given current traffic conditions?  How does an internet router forward packets of network traffic to minimize delay?  How does an aid group allocate resources to its affiliated local partners?\n\nTo solve such problems, we first represent the key pieces of data in a complex data structure. In this course, you’ll learn about data structures, like graphs, that are fundamental for working with structured real world data.  You will develop, implement, and analyze algorithms for working with this data to solve real world problems.   In addition, as the programs you develop in this course become more complex, we’ll examine what makes for good code and class hierarchy design so that you can not only write correct code, but also share it with other people and maintain it in the future.\n\nThe backbone project in this course will be a route planning application.  You will apply the concepts from each Module directly to building an application that allows an autonomous agent (or a human driver!) to navigate its environment.  And as usual we have our different video series to help tie the content back to its importance in the real world and to provide tiered levels of support to meet your personal needs.", "level": "Intermediate", "rating": "4.7", "package_num": "3", "target_audience": "Who is this class for: This is an intermediate Java course. We recommend this course to learners who have previous experience in software development or a background in computer science.", "created_by": "University of California, San Diego", "title": "Advanced Data Structures in Java"}, {"package_name": "Cloud Computing Specialization ", "week_data": [{"description": "Lesson 1: To coordinate machines in a distributed system, this module first looks at classical algorithms for electing a leader, including the Ring algorithm and Bully algorithm. We also cover how Google’s Chubby and Apache Zookeeper solve leader election.  Lesson 2: This module covers solutions to the problem of mutual exclusion, which is important for correctness in distributed systems with shared resources. We cover classical algorithms, including Ricart-Agrawala’s algorithm and Maekawa’s algorithm. We also cover Google’s Chubby support for mutual exclusion.", "video": ["Orientation Overview", "Introduction to Cloud Computing Concepts, Part 2", "Syllabus", "About the Discussion Forums", "Orientation Quiz", "Orientation Towards Cloud Computing Concepts: Some Basic Computer Science Fundamentals", "Getting to Know Your Classmates", "Course Learning Community and Social Media", "Week 1 Overview", "Week 1 Introduction", "1.1. The Election Problem", "1.2. Ring Leader Election", "1.3. Election in Chubby and ZooKeeper", "1.4. Bully Algorithm", "2.1. Introduction and Basics", "2.2. Distributed Mutual Exclusion", "2.3. Ricart-Agrawala's Algorithm", "2.4. Maekawa's Algorithm and Wrap-Up", "Homework 1 Instructions", "Homework 1 Discussion", "Programming Assignment Instructions", "Homework 1"], "title": "Week 1: Course Orientation and Classical Distributed Algorithms Continued"}, {"description": "Lesson 1: Transactions are an important component of many cloud systems today. This module presents building blocks to ensure transactions work as intended, from Remote Procedure Calls (RPCs), to serial equivalence for transactions, to optimistic and pessimistic approaches to concurrency control, to deadlock avoidance/prevention.  Lesson 2: This module covers how replication – maintaining copies of the same data at different locations – is used to provide many nines of availability in distributed systems, as well as different techniques for replication and for ensuring transactions commit correctly in spite of replication. ", "video": ["Week 2 Overview", "Week 2 Introduction", "1.1. RPCs", "1.2. Transactions", "1.3. Serial Equivalence", "1.4. Pessimistic Concurrency", "1.5. Optimistic Concurrency Control", "2.1. Replication", "2.2. Two-Phase Commit", "Homework 2 Instructions", "Homework 2 Discussion", "Homework 2"], "title": "Week 2: Concurrency and Replication Control"}, {"description": "Lesson 1: We study the emerging area of stream processing, touching on key design aspects of Apache Storm.  Lesson 2: We study how enormous graphs can be processed in clouds. Lesson 3: We study various types of networks/graphs that are both natural and artificial, and their surprising commonalities.  Lesson 4: This module presents classical scheduling algorithms that have been used in operating systems since the inception of computers. We then cover two popular scheduling algorithms for Hadoop.", "video": ["Week 3 Overview", "Week 3 Introduction", "Stream Processing in Storm", "Distributed Graph Processing", "Structure of Networks", "4.1. Single-processor Scheduling", "4.2. Hadoop Scheduling", "4.3. Dominant-Resource Fair Scheduling", "Storm Demo ", "Apache Spark by Faria Kalim", "Homework 3 Instructions", "Homework 3 Discussion", "Homework 3"], "title": "Week 3: Emerging Paradigms"}, {"description": "Lesson 1: When files and directories are stored/accessed over the network, it is called a distributed file system. This module covers the working of distributed file systems like NFS and AFS. Lesson 2: This module covers Distributed Shared Memory systems, their techniques, and pros/cons.  Lesson 3: This module looks at the area of sensor networks, starting from what’s inside a sensor mote and how networks of them work.", "video": ["Week 4 Overview", "Week 4 Introduction", "1.1. File System Abstraction", "1.2. NFS and AFS", "Distributed Shared Memory", "Sensor and Their Networks", "Interview with Brighten Godfrey", "Homework 4 Instructions", "Homework 4 Discussion", "Homework 4"], "title": "Week 4: Classical Systems"}, {"description": "Lesson 1: This module is a primer on basic security concepts, not just applied to distributed systems, but also more generally. We study various policies and mechanisms, including encryption, authentication, and authorization.  Lesson 2: This module presents case studies of real datacenter outages, and attempts to draw lessons on how to prevent them and how to better prepare for them. ", "video": ["Week 5 Overview", "Week 5 Introduction", "1.1. Basic Security Concepts", "1.2. Basic Cryptography Concepts", "1.3. Implementing Mechanism using Cryptography", "2.1. What Causes Disasters?", "2.2. AWS Outage", "2.3. Facebook Outage", "2.4. The Planet Outage", "2.5. Wrap-Up", "Interview with Paul Kwiat", "Homework 5 Instructions", "Homework 5 Discussion", "Conclusion to Cloud Computing Concepts, Part 2", "Final Exam Instructions", "Final Exam Discussion", "Final Reflection", "Homework 5", "Fault-Tolerant Key-Value Store", "Final Exam"], "title": "Week 5: Real-Life Behaviors"}], "teach_by": [{"department": "Department of Computer Science", "name": "Indranil Gupta"}], "course_info": "About this course: Cloud computing systems today, whether open-source or used inside companies, are built using a common set of core techniques, algorithms, and design philosophies – all centered around distributed systems. Learn about such fundamental distributed computing \"concepts\" for cloud computing.\n \nSome of these concepts include: clouds, MapReduce, key-value/NoSQL stores, classical distributed algorithms, widely-used distributed algorithms, scalability, trending areas, and much, much more! \n \nKnow how these systems work from the inside out. Get your hands dirty using these concepts with provided homework exercises. In the programming assignments, implement some of these concepts in template code (programs) provided in the C++ programming language. Prior experience with C++ is required.\n \nThe course also features interviews with leading researchers and managers, from both industry and academia.\n\nThis course builds on the material covered in the Cloud Computing Concepts, Part 1 course.", "level": null, "rating": "4.6", "package_num": "2", "target_audience": "Who is this class for: Who this class is for: This course is intended for students with similar backgrounds as junior or senior undergraduates in computer science. This course will teach you basic algorithmic and design concepts for distributed systems, as used in today’s cloud systems. Much of the course, including quizzes, is conceptual and not programming oriented. The programming assignment assumes some knowledge of C++ (if you have only Java experience, you should be able to pick up C++ quickly may suffice), and allow you to write distributed algorithms in an emulated distributed system on your own machine. To ensure you have the necessary prerequisites, you need to take the prerequisite quiz and achieve a high passing score (at least 90%, preferably 100%). Based on prior student experiences, the Linux/Unix environment may work better for the programming assignments than Windows. \n \nWho this class is NOT for: This course is NOT intended for those: (1) wishing to get a high level overview of cloud computing (you can use Wikipedia for that); (2) wishing to do detailed programming in a real cloud (the Cloud Capstone and Cloud Applications MOOCs provide you that); (3) who are averse to theoretical and algorithmic concepts; (4) with little or no prior programming experience in C++ or Java; (5) who expect to see industry-quality code in programming assignments (these are play programming assignments focused on allowing you to implement concepts you learn from lectures, and are not intended for immediate deployment); (6) those not familiar with setting up IDEs/compilers, etc., especially for C++; or (7) those who want to rush through lectures and/or videos and attempt quizzes in haste (quizzes are hard, so make sure you view lectures completely and comprehensively before attempting quizzes).\n", "created_by": "University of Illinois at Urbana-Champaign", "title": "Cloud Computing Concepts: Part 2"}, {"package_name": "Advanced Machine Learning Specialization ", "week_data": [], "teach_by": [{"department": "HSE Faculty of Computer Science", "name": "Anton Konushin"}, {"department": "HSE Faculty of Computer Science", "name": "Alexey Artemov"}], "course_info": "About this course: Deep learning added a huge boost to the already rapidly developing field of computer vision. With deep learning, a lot of new applications of computer vision techniques have been introduced and are now becoming parts of our everyday lives. These include face recognition and indexing, photo stylization or machine vision in self-driving cars. \nThe goal of this course is to introduce students to computer vision, starting from basics and then turning to more modern deep learning models. We will cover both image and video recognition, including image classification and annotation, object recognition and image search, various object detection techniques, motion estimation, object tracking in video, human action recognition, and finally image stylization, editing and new image generation. In course project, students will learn how to build face recognition and manipulation system to understand the internal mechanics of this technology, probably the most renown and oftenly demonstrated in movies and TV-shows example of computer vision and AI.", "level": "Advanced", "rating": null, "package_num": "5", "target_audience": "Who is this class for: The course is designed for people\n(1) who already know the basics of machine learning and deep learning \n(2) who have never studied image processing and computer vision and want to fill that gap\n(3) who want to learn how to solve computer vision problems with deep learning. ", "created_by": "National Research University Higher School of Economics", "title": "Deep Learning in Computer Vision"}, {"package_name": "Introduction to Discrete Mathematics for Computer Science Specialization ", "week_data": [{"description": "We start this module with the definition of mathematical model of the delivery problem — the classical traveling salesman problem (usually abbreviated as TSP). We'll then review just a few of its many applications: from straightforward ones (delivering goods, planning a trip) to less obvious ones (data storage and compression, genome assembly). After that, we will together take the first steps in implementing programs for TSP.", "video": ["Delivery Problem", "Shortest Common Superstring Problem", "Additional Materials", "Brute Force Search", "Nearest Neighbor", "Draw Hamiltonian cycles", "Average Weight: Examples", "Cycle Weight", "Brute Force Algorithm", "Average Weight", "Nearest Neighbors"], "title": "Traveling Salesman Problem"}, {"description": "We'll see two general techniques applied to the traveling salesman problem. The first one, branch and bound, is a classical approach in combinatorial optimization that is used for various problems. It can be seen as an improvement of the brute force search: we try to construct a permutation piece by piece, but at each step we check whether it still makes sense to continue constructing the permutation (if it doesn't, we just cut off the current branch). The second one, dynamic programming, is arguably the most popular algorithmic technique. It solves a problem by going through a collection of smaller subproblems.", "video": ["Branch and Bound", "Dynamic Programming: Main Ideas", "Dynamic Programming: Representing Subsets", "Dynamic Programming: Code", "Dynamic Programming", "Integer Linear Programming (Optional)", "Branch and Bound"], "title": "Exact Algorithms"}, {"description": "As we've seen in the previous modules, solving the traveling salesman problem exactly is hard. In fact, we don't even expect an efficient solution in the nearest future. For this reason, it makes sense to ask: is it possible to find efficiently a solution that is probably suboptimal, but at the same time is close to optimal? It turns out that the answer is yes! We'll learn two algorithms. The first one guarantees to find quickly a solution which is at most twice longer than the optimal one. The second algorithms does not have such guarantees, but it is known to work pretty well in practice.", "video": ["Approximation Algorithms", "Local Search", "2-Approximation. Examples.", "2-Approximation"], "title": "Approximation Algorithms"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}], "course_info": "About this course: We’ll implement (in Python) together efficient programs for a problem needed by delivery companies all over the world millions times per day — the travelling salesman problem. The goal in this problem is to visit all the given places as quickly as possible. How to find an optimal solution to this problem quickly? We still don’t have provably efficient algorithms for this difficult computational problem and this is the essence of the P versus NP problem, the most important open question in Computer Science. Still, we’ll implement several solutions for real world instances of the travelling salesman problem. While designing these solutions, we will rely heavily on the material learned in the courses of the specialization: proof techniques, combinatorics, probability, graph theory. We’ll see several examples of using discrete mathematics ideas to get more and more efficient solutions.", "level": "Beginner", "rating": "4.8", "package_num": "5", "target_audience": "Who is this class for: Our intended audience are all people that work or plan to work in IT, starting from motivated high school students. ", "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Delivery Problem"}, {"package_name": "Genomic Data Science Specialization ", "week_data": [{"description": "This module we begin our exploration of algorithms for analyzing DNA sequencing data. We'll discuss DNA sequencing technology, its past and present, and how it works.\n", "video": ["Welcome to Algorithms for DNA Sequencing", "Pre Course Survey", "Syllabus", "Setting up Python (and Jupyter)", "Getting slides and notebooks", "Using data files with Python programs", "Module 1 Introduction", "Lecture: Why study this?", "Lecture: DNA sequencing past and present", "Lecture: Genomes as strings, reads as substrings", "Lecture: String definitions and Python examples", "Practical: String basics ", "Practical: Manipulating DNA strings ", "Practical: Downloading and parsing a genome ", "Lecture: How DNA gets copied", "Optional lecture: How second-generation sequencers work ", "Optional lecture: Sequencing errors and base qualities ", "Lecture: Sequencing reads in FASTQ format", "Practical: Working with sequencing reads ", "Practical: Analyzing reads by position ", "Lecture: Sequencers give pieces to genomic puzzles", "Lecture: Read alignment and why it's hard", "Lecture: Naive exact matching", "Practical: Matching artificial reads ", "Practical: Matching real reads ", "Programming Homework 1 Instructions (Read First)", "Module 1", "Programming Homework 1"], "title": "DNA sequencing, strings and matching"}, {"description": "In this module, we learn useful and flexible new algorithms for solving the exact and approximate matching problems.  We'll start by learning Boyer-Moore, a fast and very widely used algorithm for exact matching", "video": ["Week 2 Introduction ", "Lecture: Boyer-Moore basics", "Lecture: Boyer-Moore: putting it all together", "Lecture: Diversion: Repetitive elements", "Practical: Implementing Boyer-Moore ", "Lecture: Preprocessing", "Lecture: Indexing and the k-mer index", "Lecture: Ordered structures for indexing", "Lecture: Hash tables for indexing", "Practical: Implementing a k-mer index ", "Lecture: Variations on k-mer indexes", "Lecture: Genome indexes used in research", "Lecture: Approximate matching, Hamming and edit distance", "Lecture: Pigeonhole principle", "Practical: Implementing the pigeonhole principle ", "Programming Homework 2 Instructions (Read First)", "Module 2", "Programming Homework 2"], "title": "Preprocessing, indexing and approximate matching"}, {"description": "This week we finish our discussion of read alignment by learning about algorithms that solve both the edit distance problem and related biosequence analysis problems, like global and local alignment.", "video": ["Module 3 Introduction ", "Lecture: Solving the edit distance problem", "Lecture: Using dynamic programming for edit distance", "Practical: Implementing dynamic programming for edit distance ", "Lecture: A new solution to approximate matching", "Lecture: Meet the family: global and local alignment", "Practical: Implementing global alignment ", "Lecture: Read alignment in the field", "Lecture: Assembly: working from scratch", "Lecture: First and second laws of assembly", "Lecture: Overlap graphs", "Practical: Overlaps between pairs of reads ", "Practical: Finding and representing all overlaps ", "Programming Homework 3 Instructions (Read First)", "Module 3", "Programming Homework 3"], "title": "Edit distance, assembly, overlaps"}, {"description": "In the last module we began our discussion of the assembly problem and we saw a couple basic principles behind it.  In this module, we'll learn a few ways to solve the alignment problem.", "video": ["Module 4 introduction ", "Lecture: The shortest common superstring problem", "Practical: Implementing shortest common superstring ", "Lecture: Greedy shortest common superstring", "Practical: Implementing greedy shortest common superstring ", "Lecture: Third law of assembly: repeats are bad", "Lecture: De Bruijn graphs and Eulerian walks", "Practical: Building a De Bruijn graph ", "Lecture: When Eulerian walks go wrong", "Lecture: Assemblers in practice", "Lecture: The future is long?", "Lecture: Computer science and life science", "Lecture: Thank yous ", "Post Course Survey", "Programming Homework 4", "Module 4"], "title": "Algorithms for assembly"}], "teach_by": [{"department": "Computer Science", "name": "Ben Langmead, PhD"}, {"department": "Department of Computer Science", "name": "Jacob Pritt"}], "course_info": "About this course: We will learn computational methods -- algorithms and data structures -- for analyzing DNA sequencing data. We will learn a little about DNA, genomics, and how DNA sequencing is used.  We will use Python to implement key algorithms and data structures and to analyze real genomes and DNA sequencing datasets.", "level": null, "rating": "4.8", "package_num": "4", "target_audience": null, "created_by": "Johns Hopkins University", "title": "Algorithms for DNA Sequencing"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "Sorting, searching, big-O notation, the Master Theorem", "video": ["What is Algorithmic Thinking? ", "The sorting problem ", "A simple quadratic algorithm ", "Illustrating MergeSort ", "The recurrence for MergeSort ", "The Master Theorem and MergeSort efficiency ", "Linear vs. binary search ", "Efficiency of binary search ", "Class structure (from part 1)", "Class notes", "Coding notes", "Coding styles and standards  -  PoC", "Testing and machine grading  -  PoC", "Plotting data  - PoC", "Peer assessment - \"We want a shrubbery!\"  - IIPP", "Homework #3"], "title": "Module 3 - Core Materials"}, {"description": "Closest pairs of points, clustering of points, comparison of clustering algorithms", "video": ["Project #3 Description", "Tests and Tips for Implementing the Clustering Methods", "Project Submission History", "Application #3 Description", "Application #3 Solution", "Assignment: Closest Pairs and Clustering Algorithms", "Comparison of Clustering Algorithms"], "title": "Module 3 - Project and Application"}, {"description": "Dynamic programming, running time of DP algorithms, local and global sequence alignment ", "video": ["The RNA secondary structure problem ", "A dynamic programming algorithm ", "Illustrating the DP algorithm ", "Running time of the DP algorithm ", "DP vs. recursive implementation ", "Global pairwise sequence alignment ", "Local pairwise sequence alignment ", "Homework 4"], "title": "Module 4 - Core Materials"}, {"description": "Computation of sequence alignments, applications to genomics and text comparison", "video": ["Project #4 Description", "Application #4 Description", "Application #4 Solution", "Class wrap-up ", "Assignment: Computing Alignments of Sequences", "Applications to Genomics and Beyond"], "title": "Module 4 - Project and Application"}], "teach_by": [{"department": "Computer Science; Biochemistry and Cell Biology ", "name": "Luay Nakhleh"}, {"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science", "name": "Joe Warren"}], "course_info": "About this course: Experienced Computer Scientists analyze and solve computational problems at a level of abstraction that is beyond that of any particular programming language.  This two-part class is designed to train students in the mathematical concepts and process of \"Algorithmic Thinking\", allowing them to build simpler, more efficient solutions to computational problems.\n\nIn part 2 of this course, we will study advanced algorithmic techniques such as divide-and-conquer and dynamic programming.  As the central part of the course, students will implement several algorithms in Python that incorporate these techniques and then use these algorithms to analyze two large real-world data sets.  The main focus of these tasks is to understand interaction between the algorithms and the structure of the data sets being analyzed by these algorithms.\n\nOnce students have completed this class, they will have both the mathematical and programming skills to analyze, design, and program solutions to a wide range of computational problems.  While this class will use Python as its vehicle of choice to practice Algorithmic Thinking, the concepts that you will learn in this class transcend any particular programming language.", "level": "Intermediate", "rating": "4.7", "package_num": "6", "target_audience": null, "created_by": "Rice University", "title": "Algorithmic Thinking (Part 2)"}, {"package_name": null, "week_data": [{"description": "This module covers particle kinematics. A special emphasis is placed on a frame-independent vectorial notation. The position velocity and acceleration of particles are derived using rotating frames utilizing the transport theorem.", "video": ["Professor Introduction", "Kinematics Course Introduction", "Module One: Particle Kinematics Introduction", "1: Particle Kinematics", "Optional Review: Vectors, Angular Velocities, Coordinate Frames", "2: Angular Velocity Vector", "3: Vector Differentiation", "3.1: Examples of Vector Differentiation", "3.2: Example of Planar Particle Kinematics with the Transport Theorem", "3.3: Example of 3D Particle Kinematics with the Transport Theorem", "Optional Review: Angular Velocities, Coordinate Frames, and Vector Differentiation", "Optional Review: Angular Velocity Derivative", "Optional Review: Time Derivatives of Vectors, Matrix Representations of Vector", "Concept Check 1 - Particle Kinematics and Vector Frames", "Concept Check 2 - Angular Velocities", "Concept Check 3 - Vector Differentiation and the Transport Theorem"], "title": "Introduction to Kinematics"}, {"description": "This module provides an overview of orientation descriptions of rigid bodies. The 3D heading is here described using either the direction cosine matrix (DCM) or the Euler angle sets.  For each set the fundamental attitude addition and subtracts are discussed, as well as the differential kinematic equation which relates coordinate rates to the body angular velocity vector.  ", "video": ["Module Two: Rigid Body Kinematics Part 1 Introduction", "1: Introduction to Rigid Body Kinematics", "2: Directional Cosine Matrices: Definitions", "Eigenvector Review", "3: DCM Properties", "4: DCM Addition and Subtraction", "5: DCM Differential Kinematic Equations", "Optional Review: Tilde Matrix Properties", "Optional Review: Rigid Body Kinematics and DCMs", "6: Euler Angle Definition", "7: Euler Angle / DCM Relation", "7.1: Example: Topographic Frame DCM Development", "8: Euler Angle Addition and Subtraction", "9: Euler Angle Differential Kinematic Equations", "10: Symmetric Euler Angle Addition", "Optional Review: Euler Angle Definitions", "Optional Review: Euler Angle Mapping to DCMs", "Optional Review: Euler Angle Differential Kinematic Equations", "Optional Review: Integrating Differential Kinematic Equations", "Concept Check 1 - Rigid Body Kinematics", "Concept Check 2 - DCM Definitions", "Concept Check 3 - DCM Properties", "Concept Check 4 - DCM Addition and Subtraction", "Concept Check 5 - DCM Differential Kinematic Equations (ODE)", "Concept Check 6 - Euler Angles Definitions", "Concept Check 7 - Euler Angle and DCM Relation", "Concept Check 8 - Euler Angle Addition and Subtraction", "Concept Check 9 - Euler Angle Differential Kinematic Equations", "Concept Check 10 - Symmetric Euler Angle Addition"], "title": "Rigid Body Kinematics I"}, {"description": "This module covers modern attitude coordinate sets including Euler Parameters (quaternions), principal rotation parameters, Classical Rodrigues parameters, modified Rodrigues parameters, as well as stereographic orientation parameters.  For each set the concepts of attitude addition and subtraction is developed, as well as mappings to other coordinate sets. ", "video": ["Module Three: Rigid Body Kinematics Part 2 Introduction", "1: Principal Rotation Parameter Definition", "2: PRV Relation to DCM", "3: PRV Properties", "Optional Review: Principal Rotation Parameters", "4: Euler Parameter (Quaternion) Definition", "5: Mapping PRV to EPs", "6: EP Relationship to DCM", "7: Euler Parameter Addition", "8: EP Differential Kinematic Equations", "Optional Review: Euler Parameters and Quaternions", "9: Classical Rodrigues Parameters Definitions", "10: CRP Stereographic Projection", "11: CRP Relation to DCM", "12: CRP Addition and Subtraction", "13: CRP Differential Kinematic Equations", "14: CRPs through Cayley Transform", "Optional Review: CRP Properties", "15: Modified Rodrigues Parameters Definitions", "16: MRP Stereographic Projection", "17: MRP Shadow Set Property", "18: MRP to DCM Relation", "19: MRP Addition and Subtraction", "20: MRP Differential Kinematic Equation", "21: MRP Form of the Cayley Transform", "Optional Review: MRP Definitions", "Optional Review: MRP Properties", "22: Stereographic Orientation Parameters Definitions", "Optional Review: SOPs", "Concept Check 1 - Principal Rotation Definitions", "Concept Check 2 - Principal Rotation Parameter relation to DCM", "Concept Check 3 - Principal Rotation Addition", "Concept Check 4 - Euler Parameter Definitions", "Concept Check 5, 6 - Euler Parameter Relationship to DCM", "Concept Check 7 - Euler Parameter Addition", "Concept Check 8 - EP Differential Kinematic Equations", "Concept Check 9 - CRP Definitions", "Concept Check 10 - CRPs Stereographic Projection", "Concept Check 11, 12 - CRP Addition", "Concept Check 13 - CRP Differential Kinematic Equations", "Concept Check 15 - MRPs Definitions", "Concept Check 16 - MRP Stereographic Projection", "Concept Check 17 - MRP Shadow Set", "Concept Check 18 - MRP to DCM Relation", "Concept Check 19 - MRP Addition and Subtraction", "Concept Check 20 - MRP Differential Kinematic Equation"], "title": "Rigid Body Kinematics II"}, {"description": "This module covers how to take an instantaneous set of observations (sun heading, magnetic field direction, star direction, etc.) and compute a corresponding 3D attitude measure.  The attitude determination methods covered include the TRIAD method, Devenport's q-method, QUEST as well as OLAE.  The benefits and computation challenges are reviewed for each algorithm.", "video": ["Module Four: Static Attitude Determination Introduction", "1: Attitude Determination Problem Statement", "2: TRIAD Method Definition", "2.1: TRIAD Method Numerical Example", "3: Wahba's Problem Definition", "4: Devenport's q-Method", "4.1: Example of Devenport's q-Method", "5: QUEST", "5.1: Example of QUEST", "6: Optimal Linear Attitude Estimator", "6.1: Example of OLAE", "Optional Review: Attitude Determination", "Optional Review: Attitude Estimation Algorithms", "Concept Check 1 - Attitude Determination", "Concept Check 2 - TRIAD Method", "Concept Check 3, 4 - Devenport's q-Method", "Concept Check 5 - QUEST Method", "Concept Check 6 - OLAE Method", "Kinematics Final Assignment"], "title": "Static Attitude Determination"}], "teach_by": [{"department": "Department of Aerospace Engineering Sciences", "name": "Hanspeter Schaub"}], "course_info": "About this course: The movement of bodies in space (like spacecraft, satellites, and space stations) must be predicted and controlled with precision in order to ensure safety and efficacy. Kinematics is a field that develops descriptions and predictions of the motion of these bodies in 3D space. This course in Kinematics covers four major topic areas: an introduction to particle kinematics, a deep dive into rigid body kinematics in two parts (starting with classic descriptions of motion using the directional cosine matrix and Euler angles, and concluding with a review of modern descriptors like quaternions and Classical and Modified Rodrigues parameters). The course ends with a look at static attitude determination, using modern algorithms to predict and execute relative orientations of bodies in space.\n\nAfter this course, you will be able to...\n\n* Differentiate a vector as seen by another rotating frame and derive frame dependent velocity and acceleration vectors\n* Apply the Transport Theorem to solve kinematic particle problems and translate between various sets of attitude descriptions\n* Add and subtract relative attitude descriptions and integrate those descriptions numerically to predict orientations over time\n* Derive the fundamental attitude coordinate properties of rigid bodies and determine attitude from a series of heading measurements", "level": "Advanced", "rating": "5.0", "package_num": null, "target_audience": "Who is this class for: This class is for working engineering professionals looking to add to their skill sets, graduate students in engineering looking to fill gaps in their knowledge base, and enterprising engineering undergraduates looking to expand their horizons.", "created_by": "University of Colorado Boulder", "title": "Kinematics: Describing the Motions of Spacecraft"}, {"package_name": null, "week_data": [{"description": "We introduce the course topic by a typical example of a basic problem, called Vertex Cover, for which we will design and analyze a state-of-the-art approximation algorithm using two basic techniques, called Linear Programming Relaxation and Rounding. It is a simple, elementary application of powerful techniques.", "video": ["Lecture: Introduction", "Slides", "Quiz 1: P vs. NP review", "All slides for all chapters of Approx Algs part 1", "Attempt to upload slides in Keynote format", "Lecture: Definition", "Slides", "Quiz 2", "Lecture: Integer program", "Slides", "Quiz 3", "Lecture: A linear programming relaxation", "Slides", "Quiz 4", "Lecture: Approximation algorithm", "Slides", "Quiz 5", "Lecture: Analysis", "Slides", "Quiz 6", "Lecture: General facts", "Slides", "Quiz 7", "Practice Exercises", "PDF version of the peer-graded assignment", "Half integrality (7:35 bug, fixed in pdf slides)", "Half-integrality slides", "All slides together in one file", "Peer Graded Assignment 1"], "title": "Vertex cover and Linear Programming"}, {"description": "This module shows the power of rounding by using it to design a near-optimal solution to another basic problem: the Knapsack problem.", "video": ["Lecture: Definition", "Slides", "Quiz 1", "Lecture: Greedy algorithm", "Slides", "Quiz 2", "Lecture: Special dynamic program", "Slides", "Quiz 3", "Lecture: General dynamic program", "Slides", "Quiz 4", "Lecture: algorithm", "Slides", "Quiz 5", "Lecture: analysis", "Slides", "Quiz 6", "Lecture: approximation scheme", "Slides", "Quiz 7", "Practise Exercises", "All slides together in one file", "Peer Assignment Knapsack"], "title": "Knapsack and Rounding"}, {"description": "This module shows the sophistication of rounding by using a clever variant for another basic problem: bin packing. (This is a more advanced module.)", "video": ["Lecture: Next Fit", "Slides (with typo corrected)", "Quiz 1", "Lecture: a linear program", "Slides", "Quiz 2", "Lecture: small items", "Slides", "Quiz 3", "Lecture: large items, few sizes", "Slides", "Quiz 4", "Slides", "Quiz 5", "Large items, many sizes", "Lecture: large items analysis", "Slides", "Quiz 6", "Lecture: general algorithm", "Slides", "Quiz 7", "Lecture: conclusion", "Slides", "Practice Exercises", "All slides together in one file", "Peer Assignment: Bin-Packing"], "title": "Bin Packing, Linear Programming and Rounding"}, {"description": "This module introduces a simple and powerful variant of rounding, based on probability: randomized rounding. Its power is applied to another basic problem, the Set Cover problem.", "video": ["Lecture: definition", "Slides", "Quiz 1", "Lecture: randomized rounding", "Slides", "Quiz 2", "Lecture: cost analysis", "Slides", "Quiz 3", "Lecture: coverage analysis", "Slides", "Quiz 4", "Lecture: iterated algorithm", "Slides", "Quiz 5", "Lecture: stopping time algorithm", "Slides", "Quiz 6", "Lecture: stopping time analysis", "Slides", "Quiz 7", "Lecture:final remarks", "Slides", "Quiz 8", "A reference on this stopping time analysis", "Practise Exercise", "All slides together in one file", "Peer Assig Set Cover"], "title": "Set Cover and Randomized Rounding"}, {"description": "This module deepens the understanding of randomized rounding by developing a sophisticated variant and applying it to another basic problem, the Multiway Cut problem. (This is a more advanced module.)", "video": ["Lecture: definition", "Slides", "Quiz 1 : Some context on cuts", "Lecture: linear programming relaxation", "Slides", "Quiz 2", "Lecture: randomized rounding", "Slides", "Quiz 3", "Lecture: analysis", "Slides", "Quiz 4", "Lecture: conclusion", "Slides", "Quiz 5", "Practice exercise", "All Chapter Slides together in one file", "Slides for all chapters of Approx Algs Part 1 together in one file", "Peer-graded assignment 5"], "title": "Multiway Cut and Randomized Rounding"}], "teach_by": [{"department": null, "name": "Claire Mathieu"}], "course_info": "About this course: Approximation algorithms, Part I\n\nHow efficiently can you pack objects into a minimum number of boxes? How well can you cluster nodes so as to cheaply separate a network into components around a few centers? These are examples of NP-hard combinatorial optimization problems. It is most likely impossible to solve such problems efficiently, so our aim is to give an approximate solution that can be computed in polynomial time and that at the same time has provable guarantees on its cost relative to the optimum. \n\nThis course assumes knowledge of a standard undergraduate Algorithms course, and particularly emphasizes algorithms that can be designed using linear programming, a favorite and amazingly successful technique in this area. By taking this course, you will be exposed to a range of problems at the foundations of theoretical computer science, and to powerful design and analysis techniques. Upon completion, you will be able to recognize, when faced with a new combinatorial optimization problem, whether it is close to one of a few known basic problems, and will be able to design linear programming relaxations and use randomized rounding to attempt to solve your own problem. The course content and in particular the homework is of a theoretical nature without any programming assignments.  \n\nThis is the first of a two-part course on Approximation Algorithms.", "level": null, "rating": "4.7", "package_num": null, "target_audience": null, "created_by": "École normale supérieure", "title": "Approximation Algorithms Part I"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "This week, we will explain the importance of searching.  We will also explore various data structures and learn about inheritance.", "video": ["Introduction ", "The Importance of Searching ", "Generators", "Stacks and Queues ", "Inheritance ", "Grid Class", "Grid search", "Mini-project Video", "Mini-project Description", "Assignment Submission History", "Math Notes on Growth Rates of Functions", "Math Notes on Grid Representations", "Math Notes on Breadth-First Search", "Practice Activity - Sorting strings", "Practice Activity - Working with Distance Fields", "CodeSkulptor  (optional video from our previous class)", "Saving in CodeSkulptor  (optional video from our previous class)", "Beyond CodeSkulptor  (optional video from our previous class)", "Homework 1", "Assignment: Zombie Apocalypse"], "title": "Searching and Data Structures"}, {"description": "This week, we will explain the importance of recursion.", "video": ["The Importance of Recursion ", "Recursion ", "Binary Search ", "Visualizing Recursion ", "Recurrences", "Reading Files ", "Mini-project Video", "Mini-project Description", "Math Notes on Recurrence Relations", "Practice Activity -  Recursion", "Practice Activity - Binary representations for numbers", "Practice Activity - Visualizing recurrences", "Homework 2", "Assignment: Word Wrangler"], "title": "Recursion"}, {"description": "This week, we will explain the importance of trees.  We will also explore how to set up game trees so that we can efficiently search them.", "video": ["The Importance of Trees ", "Lambda ", "Trees", "Illustration of Trees ", "Minimax", "Mini-project Video", "Mini-project Description", "TTTBoard Class", "Math Notes on Trees", "Math Notes on Minimax", "Practice Activity - Nim (Tree search)", "Practice Activity - Drawing trees", "Homework 3", "Assignment: Tic-Tac-Toe (Minimax)"], "title": "Trees"}, {"description": "This week, we will explain the importance of modeling.  We will also explore how to use assertions and invariants to ensure that our models are always consistent and correct.", "video": ["The Importance of Modeling ", "Assertions ", "Invariants", "Modeling ", "Software Development ", "The Basics of the Fifteen Puzzle", "Mini-project Video", "Mini-project Description", "Math Notes on Invariants", "Practice Activity - Solitaire Tantrix", "What is Algorithmic Thinking? ", "Homework 4", "Assignment: The Fifteen Puzzle"], "title": "Modeling, Assertions, and Invariants"}], "teach_by": [{"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science", "name": "Joe Warren"}, {"department": "Computer Science; Biochemistry and Cell Biology ", "name": "Luay Nakhleh"}], "course_info": "About this course: This two-part course introduces the basic mathematical and programming principles that underlie much of Computer Science. Understanding these principles is crucial to the process of creating efficient and well-structured solutions for computational problems.  To get hands-on experience working with these concepts, we will use the Python programming language. The main focus of the class will be weekly mini-projects that build upon the mathematical and programming principles that are taught in the class. To keep the class fun and engaging, many of the projects will involve working with strategy-based games.\n\nIn part 2 of this course,  the programming portion of the class will focus on concepts such as recursion, assertions, and invariants. The mathematical portion of the class will focus on searching, sorting, and recursive data structures.  Upon completing this course, you will have a solid foundation in the principles of computation and programming.  This will prepare you for the next course in the specialization, which will begin to introduce a structured approach to developing and analyzing algorithms.  Developing such algorithmic thinking skills will be critical to writing large scale software and solving real world computational problems.", "level": null, "rating": "4.8", "package_num": "4", "target_audience": null, "created_by": "Rice University", "title": "Principles of Computing (Part 2)"}, {"package_name": null, "week_data": [{"description": "The dynamical equations of motion are developed using classical Eulerian and Newtonian mechanics. Emphasis is placed on rigid body angular momentum and kinetic energy expression that are shown in a coordinate frame agnostic manner. The development begins with deformable shapes (continuous systems) which are then frozen into rigid objects, and the associated equations are thus simplified.", "video": ["Kinetics: Course Introduction", "Module 1 Introduction", "Overview of Kinetics", "1: Continuous System Super Particle Theorem", "2: Continuous System Kinetic Energy", "3: Continuous System Linear Momentum", "4: Continuous System Angular Momentum", "Optional Review: Continuous Momentum and Energy Properties", "5: Rigid Body Angular Momentum", "6: Rigid Body Inertia Tensor", "6.1: Rigid Body Inertia about Alternate Points", "6.2: Rigid Body Inertia about Alternate Body Axes", "7: Rigid Body Kinetic Energy", "8: Rigid Body Equations of Motion", "8.1: Integrating Rigid Body Equations of Motion", "8.2 Example: Slender Rod Falling", "(Tips for Solving Spring Particle Systems)", "Optional Review: Rigid Body Properties", "Optional Review: Rigid Body Equations of Motion", "Concept Check 1 - Super Particle Theorem", "Concept Check 2 - Kinetic Energy", "Concept Check 3 - Linear Momentum", "Concept Check 4 - Angular Momentum", "Concept Check 5 - Angular Momentum", "Concept Check 6 - Parallel Axis Theorem", "Concept Check 6.1 - Coordinate Transformation", "Concept Check 7 - Kinetic Energy", "Concept Check 8 - Equations of Motion"], "title": "Continuous Systems and Rigid Bodies"}, {"description": "The motion of a single or dual rigid body system is explored when no external torques are acting on it.  Large scale tumbling motions are studied through polhode plots, while analytical rate solutions are explored for axi-symmetric and general spacecraft shapes.  Finally, the dual-spinner dynamical system illustrates how the associated gyroscopics can be exploited to stabilize any principal axis spin.", "video": ["Module 2 Introduction", "1: Torque Free Motion Polhode Plots", "1.1 Example: Special Polhode Plots", "2: Torque Free Motion Axisymmetric Solution", "3: Torque Free Motion General Inertia Case", "4: Torque Free Motion Integrals of Motion", "5: Torque Free Motion Phase Space Plots", "5 Example: Phase Space Plots for Varying Energy Levels", "6: Torque Free Motion Attitude Precession", "6 Example: Phase Space Plot of Duffing Equation", "Optional Review: Torque Free Motion", "7: Dual Spinner Equations of Motion", "8: Dual Spinner Spin Equilibria", "9: Dual Spinner Linear Stability", "9 Example: Dual Spinner Stability", "9.1: Spin Up Considerations", "Optional Review: Dual Spinner EOM and Equilibria", "Concept Check 1 - Rigid Body Polhode Plots", "Concept Check 2 - Torque Free Motion with Axisymmetric Body", "Concept Check 3 - Torque Free Motion General Inertia", "Concept Check 4 - Torque Free Motion Integrals of Motion", "Concept Check 5 - Torque Free Motion Phase Space Plots", "Concept Check 6 - Torque Free Motion Precession", "Concept Check 7 - Dual Spinner Equations of Motion", "Concept Check 8 - Dual Spinner Equilibria", "Concept Check 9 - Dual Spinner Linear Stability"], "title": "Torque Free Motion"}, {"description": "The differential gravity across a rigid body is approximated to the first order to study how it disturbs both the attitude and orbital motion. The gravity gradient relative equilibria conditions are derived, whose stability is analyzed through linearization.  ", "video": ["Module 3 Introduction", "1: Gravity Gradient Torque Development", "1.1: Gravity Gradient Torque in Body Frame", "1.2: Gravity Gradient Net Spacecraft Force", "2: Gravity Gradient Relative Equilibria Orientations", "3: Gravity Gradient Linear Stability about Equilibria", "Extra Example: Gravity Gradient Polar Pear Mission", "Concept Check 1 - Gravity Gradient Derivation", "Concept Check 2  - Gravity Gradient Equilibria", "Concept Check 3 - Gravity Gradient Linear Stability"], "title": "Gravity Gradients"}, {"description": "The equations of motion of a rigid body are developed with general momentum exchange devices included.  The development begins with looking at variable speed control moment gyros (VSCMG), which are then specialized to classical single-gimbal control moment devices (CMGs) and reaction wheels (RW).", "video": ["Module 4 Introduction", "1: Introduction to Momentum Exchange Devices", "1.2: Overview of Momentum Control Devices", "2: VSCMG Equations of Motion Development", "3: VSCMG Motor Torque Equations", "4: VSCMG EOM Variations", "Optional Review of Momentum Exchange Devices", "Concept Check 1 - Overview of Momentum Exchange Devices", "Concept Check 2 - VSCMG Equations of Motion", "Concept Check 3 - VSCMG  Motor Torque Equations", "Concept Check 4 - VSCMG  EOM Variations", "Kinetics Final Assignment"], "title": "Equations of Motion with Momentum Exchange Devices"}], "teach_by": [{"department": "Department of Aerospace Engineering Sciences", "name": "Hanspeter Schaub"}], "course_info": "About this course: As they tumble through space, objects like spacecraft move in dynamical ways. Understanding and predicting the equations that represent that motion is critical to the safety and efficacy of spacecraft mission development. Kinetics: Modeling the Motions of Spacecraft trains your skills in topics like rigid body angular momentum and kinetic energy expression shown in a coordinate frame agnostic manner, single and dual rigid body systems tumbling without the forces of external torque, how differential gravity across a rigid body is approximated to the first order to study disturbances in both the attitude and orbital motion, and how these systems change when general momentum exchange devices are introduced.\n\nAfter this course, you will be able to...\n\n*Derive from basic angular momentum formulation the rotational equations of motion and predict and determine torque-free motion equilibria and associated stabilities\n* Develop equations of motion for a rigid body with multiple spinning components and derive and apply the gravity gradient torque\n* Apply the static stability conditions of a dual-spinner configuration and predict changes as momentum exchange devices are introduced\n* Derive equations of motion for systems in which various momentum exchange devices are present\n\nPlease note: this is an advanced course, best suited for working engineers or students with college-level knowledge in mathematics and physics.", "level": "Advanced", "rating": "5.0", "package_num": null, "target_audience": "Who is this class for: This class is for working engineering professionals looking to add to their skill sets, graduate students in engineering looking to fill gaps in their knowledge base, and enterprising engineering undergraduates looking to expand their horizons. ", "created_by": "University of Colorado Boulder", "title": "Kinetics: Studying Spacecraft Motion"}, {"package_name": "Introduction to Applied Cryptography Specialization ", "week_data": [{"description": "Building upon the foundation of cryptography, this module focuses on the mathematical foundation including the use of prime numbers, modular arithmetic, understanding multiplicative inverses, and extending the Euclidean Algorithm. After completing this module you will be able to understand some of the fundamental math requirement used in cryptographic algorithms. You will also have a working knowledge of some of their applications.", "video": ["Course Introduction", "Course Introduction", "Divisibility, Primes, GCD", "Lecture Slides - Divisibility, Primes, GCD", "Video - Adam Spencer: Why I fell in love with monster prime numbers", "L16: Additional Reference Material", "Modular Arithmetic", "Lecture Slides - Modular Arithmetic", "L17: Additional Reference Material", "Multiplicative Inverses", "Lecture Slides - Multiplicative Inverses", "L18: Additional Reference Material", "Extended Euclidean Algorithm", "Lecture Slides - Extended Euclidean Algorithm", "L19: Additional Reference Material", "Practice Assessment - Integer Foundation", "What do you think?", "Graded Assessment - Integer Foundation"], "title": "Integer Foundations"}, {"description": "A more in-depth understanding of modular exponentiation is crucial to understanding cryptographic mathematics.  In this module, we will cover the square-and-multiply method, Eulier's Totient Theorem and Function, and demonstrate the use of discrete logarithms. After completing this module you will be able to understand some of the fundamental math requirement for cryptographic algorithms. You will also have a working knowledge of some of their applications.", "video": ["Square-and-Multiply", "Lecture Slides - Square-and-Multiply", "Video - Modular exponentiation made easy", "L20: Additional Reference Material", "Euler's Totient Theorem", "Lecture Slide - Euler's Totient Theorem", "L21: Additional Reference Material", "Eulers Totient Function", "Lecture Slide - Eulers Totient Function", "L22: Additional Reference Material", "Discrete Logarithms", "Lecture Slide - Discrete Logarithms", "L23: Additional Reference Material", "Practice Assessment - Modular Exponentiation", "What do you think?", "Graded Assessment - Modular Exponentiation"], "title": "Modular Exponentiation"}, {"description": "The modules builds upon the prior mathematical foundations to explore the conversion of integers and Chinese Remainder Theorem expression, as well as the capabilities and limitation of these expressions. After completing this module, you will be able to understand the concepts of Chinese Remainder Theorem and its usage in cryptography.", "video": ["CRT Concepts, Integer-to-CRT Conversions", "Lecture Slide - CRT Concepts, Integer-to-CRT Conversions", "L24: Additional Reference Material", "Moduli Restrictions, CRT-to-Integer Conversions", "Lecture Slide - Moduli Restrictions, CRT-to-Integer Conversions", "CRT Capabilities and Limitations", "Lecture Slide - Moduli Restrictions, CRT-to-Integer Conversions", "Video - How they found the World's Biggest Prime Number - Numberphile", "Practice Assessment - Chinese Remainder Theorem", "What do you think?", "Graded Assessment - Chinese Remainder Theorem"], "title": "Chinese Remainder Theorem"}, {"description": "Finally we will close out this course with a module on Trial Division, Fermat Theorem, and the Miller-Rabin Algorithm.  After completing this module, you will understand how to test for an equality or set of equalities that hold true for prime values, then check whether or not they hold for a number that we want to test for primality.", "video": ["Trial Division", "Lecture Slide - Trial Division", "L27: Additional Reference Material", "Fermat's Primality", "Lecture Slide - Fermat's Primality", "L28: Additional Reference Material", "Miller-Rabin", "Lecture Slide - Miller-Rabin", "Video - James Lyne: Cryptography and the power of randomness", "L29: Additional Reference Material", "Practice Assessment - Primality Testing", "What do you think?", "The Science of Encryption", "Graded Assessment - Primality Testing", "Course Project"], "title": "Primality Testing"}], "teach_by": [{"department": "Computer Science", "name": "William Bahn"}, {"department": "Computer Science", "name": "Richard White"}, {"department": "Computer Science", "name": "Sang-Yoon Chang"}], "course_info": "About this course: Welcome to Course 2 of Introduction to Applied Cryptography. In this course, you will be introduced to basic mathematical principles and functions that form the foundation for cryptographic and cryptanalysis methods. These principles and functions will be helpful in understanding symmetric and asymmetric cryptographic methods examined in Course 3 and Course 4. These topics should prove especially useful to you if you are new to cybersecurity. It is recommended that you have a basic knowledge of computer science and basic math skills such as algebra and probability.", "level": "Beginner", "rating": "4.7", "package_num": "2", "target_audience": "Who is this class for: Learners with CS experience or education looking to: \n○\tEnhance/refresh critical skills; \n○\tSeeking to expand their opportunities.\nLearners undecided about pursuing a bachelor’s degree: \n○\tSeeking professional credit that may be applied towards a bachelor’s degree.\n", "created_by": "University of Colorado System", "title": "Mathematical Foundations for Cryptography"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to class!</p><p>This course will focus on two questions at the forefront of modern computational biology, along with the algorithmic approaches we will use to solve them in parentheses:</p><ol><li>Weeks 1-2: How Do We Assemble Genomes? (<i>Graph Algorithms</i>)</li><li>How Do We Sequence Antibiotics? (<i>Brute Force Algorithms</i>)</li></ol><p>Each of the two chapters of content in the class is accompanied by a Bioinformatics Cartoon created by talented San Diego artist Randall Christopher and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. You can find the first chapter's cartoon at the bottom of this message. What does a time machine trip to 1735, a stack of newspapers, a jigsaw puzzle, and a giant ant invading a riverside city have to do with putting together a genome? Start learning today to find out!</p><p><img src=\"https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter4_final_lr.jpg\" title=\"Image: https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter4_final_lr.jpg\" width=\"528\"></p>", "video": ["(Check Out Our Wacky Course Intro Video!)", "Course Details", "Stepik Interactive Text for Week 1", "FIELD TRIP!", "What Is Genome Sequencing?", "Exploding Newspapers", "The String Reconstruction Problem", "String Reconstruction as a Hamiltonian Path Problem", "String Reconstruction as an Eulerian Path Problem", "Similar Problems with Different Fates ", "Week 1 FAQs (Optional)", "Week 1 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Introduction to Genome Sequencing"}, {"description": "<p>Welcome to Week 2 of class!</p>\n\n<p>This week in class, we will see how a 300 year-old mathematical theorem will help us assemble a genome from millions of tiny pieces of DNA.</p>", "video": ["Stepik Interactive Text for Week 2", "De Bruijn Graphs ", "Euler's Theorem ", "Assembling Read-Pairs ", "De Bruijn Graphs Face Harsh Realities of Assembly ", "Returning to Konigsberg ", "Week 2 FAQs (Optional)", "Week 2 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: Applying Euler's Theorem to Assemble Genomes"}, {"description": "<p>Welcome to Week 3 of class!</p>\n\n<p>This week, we begin a new chapter, titled \"How Do We Sequence Antibiotics?\" &nbsp;In this chapter, we will learn&nbsp;how to determine the amino acid sequences making up antibiotics using brute force algorithms.</p>\n\n<p>Below is this week's Bioinformatics Cartoon.</p>\n\n<p><img src=\"https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter2_final.jpg\" title=\"Image: https://d396qusza40orc.cloudfront.net/bioinformatics%2Fimages%2Fchapter2_final.jpg\" width=\"528\"></p>", "video": ["Stepik Interactive Text for Week 3", "The Discovery of Antibiotics ", "How Do Bacteria Make Antibiotics? ", "Sequencing Antibiotics by Shattering Them into Pieces ", "A Brute Force Algorithm for Cyclopeptide Sequencing ", "Cyclopeptide Sequencing with Branch and Bound ", "Week 3 FAQs (Optional)", "Week 3 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 3"], "title": "Week 3: Sequencing Antibiotics"}, {"description": "<p>Welcome to Week 4 of class!</p>\n\n<p>Last week, we discussed how to sequence an antibiotic peptide from an ideal spectrum. This week, we will see how to develop more sophisticated algorithms for antibiotic peptide sequencing that are able to handle spectra with many false and missing masses.</p>", "video": ["Stepik Interactive Text for Week 4", "Adapting Sequencing for Spectra with Errors ", "From 20 to More than 100 Amino Acids ", "The Spectral Convolution Saves the Day ", "The Truth About Spectra ", "Week 4 FAQs (Optional)", "Week 4 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 4"], "title": "Week 4: From Ideal to Real Spectra for Antibiotics Sequencing"}, {"description": "Welcome to Week 5 of class!\n\nThis week, we will see how to apply genome assembly tools to sequencing data from a dangerous pathogenic bacterium.", "video": ["Bioinformatics Application Challenge"], "title": "Week 5: Bioinformatics Application Challenge!"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}], "course_info": "About this course: You may have heard a lot about genome sequencing and its potential to usher in an era of personalized medicine, but what does it mean to sequence a genome?\n\nBiologists still cannot read the nucleotides of an entire genome as you would read a book from beginning to end. However, they can read short pieces of DNA. In this course, we will see how graph theory can be used to assemble genomes from these short pieces. We will further learn about brute force algorithms and apply them to sequencing mini-proteins called antibiotics. \n\nIn the first half of the course, we will see that biologists cannot read the 3 billion nucleotides of a human genome as you would read a book from beginning to end.  However, they can read shorter fragments of DNA. In this course, we will see how graph theory can be used to assemble genomes from these short pieces in what amounts to the largest jigsaw puzzle ever put together.\n\nIn the second half of the course, we will discuss antibiotics, a topic of great relevance as antimicrobial-resistant bacteria like MRSA are on the rise.  You know antibiotics as drugs, but on the molecular level they are short mini-proteins that have been engineered by bacteria to kill their enemies.  Determining the sequence of amino acids making up one of these antibiotics is an important research problem, and one that is similar to that of sequencing a genome by assembling tiny fragments of DNA.  We will see how brute force algorithms that try every possible solution are able to identify naturally occurring antibiotics so that they can be synthesized in a lab.\n\nFinally, you will learn how to apply popular bioinformatics software tools to sequence the genome of a deadly Staphylococcus bacterium that has acquired antibiotics resistance.", "level": "Beginner", "rating": "4.7", "package_num": "2", "target_audience": "Who is this class for: This course is primarily aimed at undergraduate-level learners in computer science, biology, or a related field who are interested in learning about how the intersection of these two disciplines represents an important frontier in modern science. ", "created_by": "University of California, San Diego", "title": "Genome Sequencing (Bioinformatics II)"}, {"package_name": null, "week_data": [{"description": "Discusses stability definitions of nonlinear dynamical systems, and compares to the classical linear stability definitions.  The difference between local and global stability is covered.  ", "video": ["Course Introduction", "Module 1 Introduction", "1: Overview of Nonlinear Control", "1.1: Overview Stability Definition Discussion", "1.2: Nonlinear Equations Representation", "2: Definition: Neighborhood", "3: Definitions: Lagrange Stability", "4: Definitions: Lyapunov Stability", "5: Definitions: Asymptotic Stability", "6: Definitions: Global Stability", "7: Linearizing a Dynamical System", "Optional Review: Stability Definitions", "Concept Check 1 - State Vector Representation", "Concept Check 2 - State Neighborhood", "Concept Check 3 - Lagrange Stability", "Concept Check 4 - Lyapunov Stability", "Concept Check 5 -  Asymptotic Stability", "Concept Check 6 - Global Stability Definitions", "Concept Check 7 - Linearization"], "title": "Nonlinear Stability Definitions"}, {"description": "Lyapunov's direct method is employed to prove these stability properties for a nonlinear system and prove stability and convergence.  The possible function definiteness is introduced which forms the building block of Lyapunov's direct method.  Convenient prototype Lyapunov candidate functions are presented for rate- and state-error measures.", "video": ["Module 2 Introduction", "1: Overview of Definite Function", "2: Lyapunov Function Definition", "2.1: Lyapunov Asymptotic Stability", "3: Lyapunov Stability of Linear System", "4: Global Stability Applications", "Optional Review: Definiteness", "Optional Review: Stability Definitions", "Optional Review: Lyapunov's Direct Method", "5: General Elemental Velocity Lyapunov Function", "5.1 Example: Multi-Link System", "6: Rigid Body Detumble Control", "7: State-Based Lyapunov Functions", "Optional Review: Elemental Lyapunov Functions", "Concept Check 1 - Definite Function", "Concept Check 2 - Lyapunov Functions", "Concept Check 3 - Asymptotic Stability", "Concept Check 4 - Global Stability Applications", "Concept Check 5 - General Elemental Rate", "Concept Check 6 - Rigid Body Elemental Rate Lyapunov Function", "Concept Check 7 - General Elemental State Lyapunov Function"], "title": "Overview of Lyapunov Stability Theory"}, {"description": "A nonlinear 3-axis attitude pointing control law is developed and its stability is analyized using Lyapunov theory.  Convergence is discussed considering both modeled and unmodeled torques.   The control gain selection is presented using the convenient linearized closed loop dynamics.", "video": ["Module 3 Introduction", "1: Nonlinear Rigid Body State and Rate Control", "2: Global Stability of Nonlinear Attitude Control", "2.1 Example: Nonlinear Regulation Control", "2.2: Asymptotic Stability for Nonlinear Attitude Control", "3: Unmodeled Disturbance Torque", "4: Nonlinear Integral Control", "5: Feedback Gain Selection", "Concept Check 1 - General 3-Axis Attitude Control", "Concept Check 2 - Asymptotic Stability", "Concept Check 3 - Unknown External Torques", "Concept Check 4 - Integral Feedback", "Concept Check 5 - Feedback Gain Selection"], "title": "Attitude Control of States and Rates"}, {"description": "Alternate feedback control laws are formulated where actuator saturation is considered.  Further, a control law is presented that perfectly linearizes the closed loop dynamics in terms of quaternions and MRPs.  Finally, the 3-axis Lyapunov attitude control is developed for a spacecraft with a cluster of N reaction wheel control devices.", "video": ["Module 4 Introduction", "1: Lyapunov Optimal Control", "2: Example: Numerical Control Simulation", "2.1: Linear Closed-Loop Dynamics", "3: RW Feedback Control Law", "Optional Review: Unconstrained Attitude Control", "Concept Check 1 - Saturated Control", "Concept Check 2 - Linearized Closed Loop Dynamics", "Concept Check 3 - RW Feedback Control", "Nonlinear Control Final Assignment"], "title": "Alternate Attitude Control Formulations"}], "teach_by": [{"department": "Department of Aerospace Engineering Sciences", "name": "Hanspeter Schaub"}], "course_info": "About this course: This course trains you in the skills needed to program specific orientation and achieve precise aiming goals for spacecraft moving through three dimensional space. First, we cover stability definitions of nonlinear dynamical systems, covering the difference between local and global stability. We then analyze and apply Lyapunov's Direct Method to prove these stability properties, and develop a nonlinear 3-axis attitude pointing control law using Lyapunov theory. Finally, we look at alternate feedback control laws and closed loop dynamics. \n\nAfter this course, you will be able to...\n\n* Differentiate between a range of nonlinear stability concepts\n* Apply Lyapunov’s direct method to argue stability and convergence on a range of dynamical systems\n* Develop rate and attitude error measures for a 3-axis attitude control using Lyapunov theory\n* Analyze rigid body control convergence with unmodeled torque", "level": "Advanced", "rating": "5.0", "package_num": null, "target_audience": "Who is this class for: This class is for working engineering professionals looking to add to their skill sets, graduate students in engineering looking to fill gaps in their knowledge base, and enterprising engineering undergraduates looking to expand their horizons.", "created_by": "University of Colorado Boulder", "title": "Control of Nonlinear Spacecraft Attitude Motion"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to class!</p><p>At the beginning of the class, we will see how algorithms for&nbsp;<strong>clustering&nbsp;</strong>a set of data points&nbsp;will help us determine how yeast became such good wine-makers. At the bottom of this email is the Bioinformatics Cartoon for this chapter, courtesy of <a href=\"http://bearandfox.com\" target=\"_blank\" title=\"Link: http://bearandfox.com\">Randall Christopher</a> and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. How did the monkey lose a wine-drinking contest to a tiny mammal? &nbsp;Why have Pavel and Phillip become cavemen? And will flipping a coin help them escape their eternal boredom until they can return to the present? Start learning to find out!</p><p><img width=\"550\" alt=\"\" src=\"http://bioinformaticsalgorithms.com/images/cover/clustering_cropped.jpg\" title=\"Image: http://bioinformaticsalgorithms.com/images/cover/clustering_cropped.jpg\"></p>", "video": ["(Check Out Our Wacky Course Intro Video!)", "Course Details", "Stepik Interactive Text for Week 1", "Which Yeast Genes are Responsible for Wine Making? ", "Gene Expression Matrices ", "Clustering as an Optimization Problem ", "The Lloyd Algorithm for k-Means Clustering ", "Week 1 FAQs (Optional)", "Week 1 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Introduction to Clustering Algorithms"}, {"description": "<p>Welcome to week 2 of class!</p>\n\n<p>This week, we will see how we can move from a \"hard\" assignment of points to clusters toward a \"soft\" assignment that allows the boundaries of the clusters to blend. We will also see how to adapt the Lloyd algorithm that we encountered in the first week in order to produce an algorithm for soft clustering. We will also see another clustering algorithm called \"hierarchical clustering\" that groups objects into larger and larger clusters.</p>", "video": ["Stepik Interactive Text for Week 2", "From Hard to Soft Clustering ", "From Coin Flipping to k-Means Clustering ", "Expectation Maximization ", "Soft k-Means Clustering ", "Hierarchical Clustering ", "Week 2 FAQs (Optional)", "Week 2 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: Advanced Clustering Techniques"}, {"description": "", "video": ["Statement on This Week's Material", "How Have Humans Populated the Earth?", "Week 3 Quiz"], "title": "Week 3: Introductory Algorithms in Population Genetics"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}], "course_info": "About this course: How do we infer which genes orchestrate various processes in the cell?  How did humans migrate out of Africa and spread around the world? In this class, we will see that these two seemingly different questions can be addressed using similar algorithmic and machine learning techniques arising from the general problem of dividing data points into distinct clusters.\n\nIn the first half of the course, we will introduce algorithms for clustering a group of objects into a collection of clusters based on their similarity, a classic problem in data science, and see how these algorithms can be applied to gene expression data.\n\nIn the second half of the course, we will introduce another classic tool in data science called principal components analysis that can be used to preprocess multidimensional data before clustering in an effort to greatly reduce the number dimensions without losing much of the \"signal\" in the data.\n\nFinally, you will learn how to apply popular bioinformatics software tools to solve a real problem in clustering.", "level": "Beginner", "rating": "4.1", "package_num": "5", "target_audience": "Who is this class for: This course is primarily aimed at undergraduate-level learners in computer science, biology, or a related field who are interested in learning about how the intersection of these two disciplines represents an important frontier in modern science. ", "created_by": "University of California, San Diego", "title": "Genomic Data Science and Clustering (Bioinformatics V)"}, {"package_name": null, "week_data": [{"description": "In this module you will become familiar with the course and our learning environment. The orientation will also help you obtain the technical skills required for the course.", "video": ["Welcome and Introduction", "Syllabus", "Demographics Survey", "Tools For This Course", "Two Tools Tutorial"], "title": "Orientation"}, {"description": "In this second part of our course, we will talk about geometry. We will begin with an overview of the ASIC layout process, and discuss the role of technology libraries, tech mapping (a topic we delay until the following week, to let those who want to do the Placer programming assignment have more time), and placement and routing.  In this set of lectures, we focus on the placement process itself:  you have a million gates from the result of synthesis and map, so, where do they go? This process is called “placement”, and we describe an iterative method, and a mathematical optimization method, that can each do very large placement tasks.", "video": ["Week 1 Overview", "Basics", "Wirelength Estimation", "Simple Iterative Improvement Placement", "Iterative Improvement with Hill Climbing", "Simulated Annealing Placement", "Analytical Placement: Quadratic Wirelength Model", "Analytical Placement: Quadratic Placement", "Analytical Placement: Recursive Partitioning", "Analytical Placement: Recursive Partitioning Example", "Week 1 Assignments"], "title": "ASIC Placement"}, {"description": "Technology Mapping!  We omitted one critical step between logic and layout, the process of translating the output of synthesis -- which is NOT real gates in your technology library -- into real logic gates. The Tech Mapper performs this important step, and it is a surprisingly elegant algorithm involving recursive covering of a tree. Another place where knowing some practical computer science comes to the rescue in VLSI CAD.", "video": ["Week 2 Overview", "Technology Mapping Basics", "Technology Mapping as Tree Covering", "Technology Mapping—Tree-ifying the Netlist", "Technology Mapping—Recursive Matching", "Technology Mapping—Minimum Cost Covering", "Technology Mapping—Detailed Covering Example", "Week 2 Assignments", "Problem Set #1", "Programming Assignment #3: Placer"], "title": "Technology Mapping"}, {"description": "Routing! You put a few million gates on the surface of the chip in some sensible way. What's next? Create the wires to connect them. We focus on Maze Routing, which is a classical and powerful technique with the virtue that one can \"add\" much sophisticated functionality on top of a rather simple core algorithm. This is also the topic for final (optional) programming assignment. Yes, if you choose, you get to route pieces of the industrial benchmarks we had you place in the placer software assignment.", "video": ["Week 3 Overview", "Routing Basics", "Maze Routing: 2-Point Nets in 1 Layer", "Maze Routing: Multi-Point Nets", "Maze Routing: Multi-Layer Routing", "Maze Routing: Non-Uniform Grid Costs", "Implementation Mechanics: How Expansion Works", "Implementation Mechanics: Data Structures & Constraints", "Implementation Mechanics: Depth First Search", "From Detailed Routing to Global Routing", "Week 3 Assignments", "Problem Set #2"], "title": "ASIC Routing"}, {"description": "You synthesized it. You mapped it. You placed it. You routed it. Now what? HOW FAST DOES IT GO? Oh, we need some new models, to talk about how TIMING works. Delay through logic gates and big networks of gates. New numbers to understand: ATs, RATs, SLACKS, etc. And some electrical details (minimal) to figure out how delays happen through the physical geometry of physical routed wires. All together this is the stuff of Static Timing Analysis (STA), which is a huge and important final \"sign off\" step in real ASIC design.", "video": ["Week 4 Overview", "Basics", "Logic-Level Timing: Basic Assumptions & Models", "Logic-Level Timing: STA Delay Graph, ATs, RATs, and Slacks", "Logic-Level Timing: A Detailed Example and the Role of Slack", "Logic-Level Timing: Computing ATs, RATs, Slacks, and Worst Paths", "Interconnect Timing: Electrical Models of Wire Delay", "Interconnect Timing: The Elmore Delay Model", "Interconnect Timing: Elmore Delay Examples", "Week 4 Assignments", "Problem Set #3", "Programming Assignment #4: Router"], "title": "Timing Analysis"}, {"description": "There is no new content this week. Instead, you should focus on finishing the last problem set and completing the Final Exam.", "video": ["End of Course Survey", "Problem Set #4", "Final Exam"], "title": "Final Exam"}], "teach_by": [{"department": "Department of Computer Science", "name": "Rob A. Rutenbar"}], "course_info": "About this course: You should complete the VLSI CAD Part I: Logic course before beginning this course.\n\nA modern VLSI chip is a remarkably complex beast:  billions of transistors, millions of logic gates deployed for computation and control, big blocks of memory, embedded blocks of pre-designed functions designed by third parties (called “intellectual property” or IP blocks).  How do people manage to design these complicated chips?  Answer:  a sequence of computer aided design (CAD) tools takes an abstract description of the chip, and refines it step-wise to a final design. This class focuses on the major design tools used in the creation of an Application Specific Integrated Circuit (ASIC) or System on Chip (SoC) design.  Our focus in this part of the course is on the key logical and geometric representations that make it possible to map from logic to layout, and in particular, to place, route, and evaluate the timing of large logic networks. Our goal is for students to understand how the tools themselves work, at the level of their fundamental algorithms and data structures. Topics covered will include: technology mapping, timing analysis, and ASIC placement and routing.\n\nRecommended Background:\nProgramming experience (C, C++, Java, Python, etc.) and basic knowledge of data structures and algorithms (especially recursive algorithms).  An understanding of basic digital design:  Boolean algebra, Kmaps, gates and flip flops, finite state machine design.  Linear algebra and calculus at the level of a junior or senior in engineering.  Elementary knowledge of RC linear circuits (at the level of an introductory physics class).", "level": "Intermediate", "rating": "4.9", "package_num": null, "target_audience": "Who is this class for: You should be taking this course if (1) you are interested in building VLSI design tools; (2) you are interested in designing VLSI chips, and you want to know why the tools do what they do; (3) you just like cool algorithms, that work on big cool problems that involve bits, and gates, and geometry, and graphs, and matrices, and time, etc.", "created_by": "University of Illinois at Urbana-Champaign", "title": "VLSI CAD Part II: Layout"}, {"package_name": "Advanced Machine Learning Specialization ", "week_data": [], "teach_by": [{"department": "HSE Faculty of Computer Science", "name": "Andrei Ustyuzhanin"}, {"department": "HSE Faculty of Computer Science", "name": "Mikhail Hushchyn"}], "course_info": "About this course: The Large Hadron Collider (LHC) is the largest data generation machine for the time being. It doesn’t produce the big data, the data is gigantic. Just one of the four experiments generates thousands gigabytes per second. The intensity of data flow is only going to be increased over the time. So the data processing techniques have to be quite sophisticated and unique. In this course we’ll introduce students into the main concepts of the Physics behind those data flow so the main puzzles of the Universe Physicists are seeking answers for will be much more transparent. Of course we will scrutinize the major stages of the data processing pipelines, and focus on the role of the Machine Learning techniques for such tasks as track pattern recognition, particle identification, online real-time processing (triggers) and search for very rare decays. The assignments of this course will give you opportunity to apply your skills in the search for the New Physics using advanced data analysis techniques. Upon the completion of the course you will understand both the principles of the Experimental Physics and Machine Learning much better.", "level": "Advanced", "rating": null, "package_num": "7", "target_audience": "Who is this class for: This course is recommended to those who has been introduced to the Machine Learning methods and skills, and who is interested in applying those to practical scientific research challenges. The field of High Energy Physics is just one fascinating example of modern scientific fields that can be greatly advanced by Machine Learning tools. No special Physics background is required to complete the assignments.", "created_by": "National Research University Higher School of Economics", "title": "Addressing Large Hadron Collider Challenges by Machine Learning"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to our class!</p><p>In this class, we will consider the following two central biological&nbsp;questions (the computational approaches needed to solve them are shown in parentheses):</p><ol><li>Weeks 1-3: Which Animal Gave Us SARS? (<i>Evolutionary tree construction</i>)</li><li>Weeks 4-5: Was <em>T. rex</em> Just a Big Chicken?&nbsp;(<em>Combinatorial Algorithms</em>)</li></ol><p>In Week 6, you will complete a Bioinformatics Application Challenge to apply evolutionary tree construction algorithms in order to determine the origin of the recent ebola outbreak in Africa.</p><p>As in previous courses, each of these two chapters is accompanied by a Bioinformatics Cartoon created by talented artist Randall Christopher and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. You can find the first chapter's cartoon at the bottom of this message. What do stick bugs and bats have to do with deadly viruses? And how can bioinformatics be used to stop these viruses in their tracks? Start learning today and find out!</p><p><img src=\"http://bioinformaticsalgorithms.com/images/cover/evolution_cropped.jpg\" title=\"Image: http://bioinformaticsalgorithms.com/images/cover/evolution_cropped.jpg\" width=\"528\"></p>", "video": ["(Check Out Our Wacky Course Intro Video!)", "Course Details", "Stepik Interactive Text for Week 1", "The Fastest Outbreak ", "Transforming Distance Matrices into Evolutionary Trees ", "Toward an Algorithm for Distance-Based Phylogeny Construction ", "Additive Phylogeny ", "Week 1 FAQs (Optional)", "Week 1 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Introduction to Evolutionary Tree Construction"}, {"description": "<p>Welcome to Week 2 of class!</p>\n\n<p>Last week, we started to see how evolutionary trees can be constructed from distance matrices. &nbsp;This week, we will encounter additional algorithms for this purpose, including the neighbor-joining algorithm, which has become one of the top-ten most cited papers in all of science since its introduction three decades ago.</p>", "video": ["Stepik Interactive Text for Week 2", "Using Least Squares to Construct Distance-Based Phylogenies ", "Ultrametric Trees ", "The Neighbor-Joining Algorithm ", "Week 2 FAQs (Optional)", "Week 2 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: More Algorithms for Constructing Trees from Distance Matrices"}, {"description": "<p>Welcome to week 3 of class!</p>\n\n<p>Over the last two weeks, we have seen several different algorithms for constructing evolutionary trees from distance matrices.</p>\n\n<p>This week, we will conclude the current chapter by considering what happens if we use properties called \"characters\" instead of distances. We will also see how to infer the ancestral states of organisms in an evolutionary tree, and consider whether it is possible to define an efficient algorithm for this task.</p>", "video": ["Stepik Interactive Text for Week 3", "Character-Based Tree Reconstruction ", "The Small Parsimony Algorithm ", "The Large Parsimony Algorithm ", "Evolutionary Tree Reconstruction in the Modern Era ", "Week 3 FAQs (Optional)", "Week 3 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 3"], "title": "Week 3: Constructing Evolutionary Trees from Characters"}, {"description": "<p>Welcome to week 4 of the class!</p>\n\n<p>Did birds evolve from dinosaurs? Over the next two weeks, we will see how we could analyze molecular evidence in support of this theory. You can find this week's Bioinformatics Cartoon from Randall Christopher at the bottom of this E-mail. Why does the <em>T. rex&nbsp;</em>look so much like a chicken? And why is the monkey typing frantically? Keep learning to find out!</p>\n\n<p><img src=\"http://bioinformaticsalgorithms.com/images/cover/proteomics_cropped.jpg\" title=\"Image: http://bioinformaticsalgorithms.com/images/cover/proteomics_cropped.jpg\" width=\"528\"></p>", "video": ["Note on This Week's Assignments", "Paleontology Meets Computing ", "Decoding an Ideal Spectrum ", "From Ideal to Real Spectra ", "Peptide Sequencing ", "Week 4 Quiz", "Stepik Code Challenges for Week 4"], "title": "Week 4"}, {"description": "<p>Welcome to week 5 of class!</p>\n\n<p>Last week, we asked whether it is possible for dinosaur peptides to survive locked inside of a fossil for 65 million years. This week, we will see what this question has to do with statistics; in the process, we will see how a monkey typing out symbols on a typewriter can be used to address it.</p>", "video": ["Note on This Week's Content", "Peptide Identification ", "Spectral Dictionaries ", "The Ostrich Hemoglobin Riddle ", "Searching for Post-Translational Modifications ", "Spectral Alignment Algorithm ", "Week 5 Quiz", "Stepik Code Challenges for Week 5"], "title": "Week 5: Resolving the T. rex Peptides Mystery? "}, {"description": "<p>Welcome to the sixth and final week of the course!</p>\n\n<p>In this week's Bioinformatics Application Challenge, we will use reconstruct an evolutionary tree of ebolaviruses and use it to determine the origin of the pathogen that caused the recent outbreak in Africa.</p>", "video": ["Bioinformatics Application Challenge"], "title": "Week 6: Bioinformatics Application Challenge"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}], "course_info": "About this course: In the previous course in the Specialization, we learned how to compare genes, proteins, and genomes.  One way we can use these methods is in order to construct a \"Tree of Life\" showing how a large collection of related organisms have evolved over time.\n\nIn the first half of the course, we will discuss approaches for evolutionary tree construction that have been the subject of some of the most cited scientific papers of all time, and show how they can resolve quandaries from finding the origin of a deadly virus to locating the birthplace of modern humans.\n\nIn the second half of the course, we will shift gears and examine the old claim that birds evolved from dinosaurs.  How can we prove this?  In particular, we will examine a result that claimed that peptides harvested from a T. rex fossil closely matched peptides found in chickens. In particular, we will use methods from computational proteomics to ask how we could assess whether this result is valid or due to some form of contamination.\n\nFinally, you will learn how to apply popular bioinformatics software tools to reconstruct an evolutionary tree of ebolaviruses and identify the source of the recent Ebola epidemic that caused global headlines.", "level": "Beginner", "rating": "4.5", "package_num": "4", "target_audience": "Who is this class for: This course is primarily aimed at undergraduate-level learners in computer science, biology, or a related field who are interested in learning about how the intersection of these two disciplines represents an important frontier in modern science. ", "created_by": "University of California, San Diego", "title": "Molecular Evolution (Bioinformatics IV)"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to class!</p><p>If you joined us in the previous course in this Specialization, then you became an expert at <em>assembling</em> genomes and sequencing antibiotics. The next natural question to ask is how to compare DNA and amino acid sequences. This question will motivate this week's discussion of <strong>sequence alignment</strong>, which is the first of two questions that we will ask in this class (the algorithmic methods used to answer them are shown in parentheses):</p><ol><li>How Do We Compare DNA Sequences? (<em>Dynamic Programming</em>)</li><li>Are There Fragile Regions in the Human Genome? (<em>Combinatorial Algorithms</em>)</li></ol><p>As in previous courses, each of these two chapters is accompanied by a Bioinformatics Cartoon created by talented artist Randall Christopher and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. You can find the first chapter's cartoon at the bottom of this message. Why have taxis suddenly become free of charge in Manhattan? Where did Pavel get so much spare change?  And how should you get dressed in the morning so that you aren't late to your job as a crime-stopping superhero? Answers to these questions, and many more, in this week's installment of the course.</p><p><img src=\"http://bioinformaticsalgorithms.com/images/cover/alignment_cropped.jpg\" width=\"528\"></p>", "video": ["(Check Out Our Wacky Course Intro Video!)", "Course Details", "Stepik Interactive Text for Week 1", "From Sequence Comparison to Biological Insights ", "The Alignment Game and the Longest Common Subsequence Problem ", "The Manhattan Tourist Problem ", "The Change Problem ", "Dynamic Programming and Backtracking Pointers ", "From Manhattan to the Alignment Graph ", "Week 1 FAQs (Optional)", "Week 1 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Introduction to Sequence Alignment"}, {"description": "<p>Welcome to Week 2 of the class!</p>\n\n<p>Last week, we saw how touring around Manhattan and making change in a Roman shop help us find a longest common subsequence of two DNA or protein strings.</p>\n\n<p>This week, we will study how to find a highest scoring alignment of two strings. We will see that regardless of the underlying assumptions that we make regarding how the strings should be aligned, we will be able to phrase our alignment problem as an instance of finding the longest path in a directed acyclic graph.</p>", "video": ["Stepik Interactive Text for Week 2", "From Global to Local Alignment ", "Week 2 FAQs (Optional)", "Week 2 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: From Finding a Longest Path to Aligning DNA Strings"}, {"description": "<p>Welcome to Week 3 of the class!</p>\n\n<p>Last week, we saw how a variety of different applications of sequence alignment can all be reduced to finding the longest path in a Manhattan-like graph.</p>\n\n<p>This week, we will conclude the current chapter by considering a few advanced topics in sequence alignment. For example, if we need to align long strings, our current algorithm will consume a huge amount of memory. Can we find a more memory-efficient approach? And what should we do when we move from aligning just two strings at a time to aligning many strings?</p>", "video": ["Stepik Interactive Text for Week 3", "Penalizing Insertions and Deletions in Sequence Alignment ", "Space-Efficient Sequence Alignment ", "Multiple Sequence Alignment ", "Week 3 FAQs (Optional)", "Week 3 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 3"], "title": "Week 3: Advanced Topics in Sequence Alignment"}, {"description": "<p>Welcome to Week 4 of the class!</p>\n\n<p>You now know how to compare two DNA (or protein) strings. &nbsp;But what if we wanted to compare entire genomes? When we \"zoom out\" to the genome level, we find that substitutions, insertions, and deletions don't tell the whole story of evolution: we need to model more dramatic evolutionary events known as <strong>genome rearrangements</strong>, which wrench apart chromosomes and put them back together in a new order. A natural question to ask is whether there are \"fragile regions\" hidden in your genome where chromosome breakage has occurred more often over millions of years. This week, we will begin addressing this question by asking how we can compute the number of rearrangements on the evolutionary path connecting two species.</p>\n\n<p>You can find this week's Bioinformatics Cartoon from Randall Christopher at the bottom of this E-mail. What do earthquakes and a stack of pancakes have to do with species evolution? Keep learning to find out!</p>\n\n<p><img width=\"528\" src=\"http://bioinformaticsalgorithms.com/images/cover/rearrangements_cropped.jpg\"></p>", "video": ["Stepik Interactive Text for Week 4", "Transforming Men Into Mice ", "Sorting by Reversals ", "Breakpoint Theorem ", "Rearrangements in Tumor Genomes ", "2-Breaks ", "Week 4 FAQs (Optional)", "Week 4 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 4"], "title": "Week 4: Genome Rearrangements and Fragility"}, {"description": "<p>Last week, we asked whether there are fragile regions in the human genome. Then, we took a lengthy detour to see how to compute a distance between species genomes, a discussion that we will continue this week.</p>\n\n<p>It is probably unclear how computing the&nbsp;<em>distance</em> between two genomes can help us understand whether <em>fragile regions</em> exist. If so, please stay tuned -- we will see that the connection between these two concepts will yield a surprising conclusion to the class.</p>", "video": ["Stepik Interactive Text for Week 5", "Breakpoint Graphs ", "2-Break Distance Theorem ", "Rearrangement Hotspots in the Human Genome ", "Synteny Block Construction ", "Week 5 FAQs (Optional)", "Week 5 Quiz", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 5"], "title": "Week 5: Applying Genome Rearrangement Analysis to Find Genome Fragility"}, {"description": "In the sixth and final week of the course, we will apply sequence alignment algorithms to infer the non-ribosomal code.", "video": ["Bioinformatics Application Challenge"], "title": "Week 6: Bioinformatics Application Challenge"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}, {"department": "Department of Computer Science and Engineering", "name": "Nikolay Vyahhi"}], "course_info": "About this course: Once we have sequenced genomes in the previous course, we would like to compare them to determine how species have evolved and what makes them different.\n\nIn the first half of the course, we will compare two short biological sequences, such as genes (i.e., short sequences of DNA) or proteins.  We will encounter a powerful algorithmic tool called dynamic programming that will help us determine the number of mutations that have separated the two genes/proteins.\n\nIn the second half of the course, we will \"zoom out\" to compare entire genomes, where we see large scale mutations called genome rearrangements, seismic events that have heaved around large blocks of DNA over millions of years of evolution.  Looking at the human and mouse genomes, we will ask ourselves: just as earthquakes are much more likely to occur along fault lines, are there locations in our genome that are \"fragile\" and more susceptible to be broken as part of genome rearrangements?  We will see how combinatorial algorithms will help us answer this question.\n\nFinally, you will learn how to apply popular bioinformatics software tools to solve problems in sequence alignment, including BLAST.", "level": "Beginner", "rating": "4.7", "package_num": "3", "target_audience": "Who is this class for: This course is primarily aimed at undergraduate-level learners in computer science, biology, or a related field who are interested in learning about how the intersection of these two disciplines represents an important frontier in modern science. ", "created_by": "University of California, San Diego", "title": "Comparing Genes, Proteins, and Genomes (Bioinformatics III)"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "<p>Welcome to our class! We are glad that you decided to join us.</p><p>In this class, we will consider the following two central biological&nbsp;questions (the computational approaches needed to solve them are shown in parentheses):</p><ol><li>How Do We Locate Disease-Causing Mutations? (<em>Combinatorial Pattern Matching</em>)</li><li>Why Have Biologists Still Not Developed an HIV Vaccine?&nbsp;(<em>Hidden Markov Models</em>)</li></ol><p>As in previous courses, each of these two chapters is accompanied by a Bioinformatics Cartoon created by talented artist Randall Christopher and serving as a chapter header in the Specialization's bestselling <a href=\"http://bioinformaticsalgorithms.com\" target=\"_blank\">print companion</a>. You can find the first chapter's cartoon at the bottom of this message. </p><p><img src=\"https://stepic.org/media/attachments/lessons/292/chapter7_cropped.jpg\" title=\"Image: https://stepic.org/media/attachments/lessons/292/chapter7_cropped.jpg\" width=\"528\"></p>", "video": ["(Check Out Our Wacky Course Intro Video!)", "Course Details", "Stepik Interactive Text for Week 1", "Why Do We Map Reads? ", "Using the Trie ", "From a Trie to a Suffix Tree ", "Week 1 FAQs (Optional)", "How Do We Find Disease-Causing Mutations? (Week 1)", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 1"], "title": "Week 1: Introduction to Read Mapping"}, {"description": "<p>Welcome to week 2 of the class!</p>\n\n<p>This week, we will introduce a paradigm called the Burrows-Wheeler transform; after seeing how it can be used in string compression, we will demonstrate that it is also the foundation of modern read-mapping algorithms.</p>", "video": ["Stepik Interactive Text for Week 2", "String Compression and the Burrows-Wheeler Transform ", "Inverting Burrows-Wheeler ", "Using Burrows-Wheeler for Pattern Matching ", "Week 2 FAQs (Optional)", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 2"], "title": "Week 2: The Burrows-Wheeler Transform"}, {"description": "<p>Welcome to week 3 of class!</p>\n\n<p>Last week, we saw how the Burrows-Wheeler transform could be applied to multiple pattern matching.  This week, we will speed up our algorithm and generalize it to the case that patterns have errors, which models the biological problem of mapping reads with errors to a reference genome.</p>", "video": ["Stepik Interactive Text for Week 3", "Finding the Matched Patterns ", "Setting Up Checkpoints ", "Inexact Matching ", "Further Applications of Read Mapping ", "Week 3 FAQs (Optional)", "How Do We Find Disease-Causing Mutations? (Weeks 2-3)", "Open in order to Sync Your Progress: Stepik Interactive Text for Week 3"], "title": "Week 3: Speeding Up Burrows-Wheeler Read Mapping"}, {"description": "<p>Welcome to week 4 of class!</p>\n\n<p>This week, we will start examining the case of aligning sequences with many mutations -- such as related genes from different HIV strains -- and see that our problem formulation for sequence alignment is not adequate for highly diverged sequences.</p>\n\n<p>To improve our algorithms, we will introduce a machine-learning paradigm called a hidden Markov model and see how dynamic programming helps us answer questions about these models.</p>", "video": ["Note on This Week's Content", "Classifying HIV Phenotypes ", "Gambling with Yakuza ", "From a Crooked Casino to a Hidden Markov Model ", "The Decoding Problem ", "The Viterbi Algorithm ", "Stepik Code Challenges for Week 4"], "title": "Week 4: Introduction to Hidden Markov Models "}, {"description": "<p>Welcome to week 5 of class!</p>\n\n<p>Last week, we introduced hidden Markov models.  This week, we will see how hidden Markov models can be applied to sequence alignment with a profile HMM.  We will then consider some advanced topics in this area, which are related to advanced methods that we considered in a previous course for clustering.</p>", "video": ["Note on This Week's Content", "Profile HMMs for Sequence Alignment ", "Classifying Proteins with Profile HMMs ", "Viterbi Learning ", "Soft Decoding Problem ", "Baum-Welch Learning ", "Week 5 FAQs (Optional)", "Why Have Biologists Still Not Developed an HIV Vaccine? (Weeks 4-5)", "Stepik Code Challenges for Week 5"], "title": "Week 5: Profile HMMs for Sequence Alignment"}, {"description": "<p>Welcome to the sixth and final week of class!</p>\n\n<p>This week brings our Application Challenge, in which we apply the HMM sequence alignment algorithms that we have developed.</p>", "video": ["Bioinformatics Application Challenge"], "title": "Week 6: Bioinformatics Application Challenge"}], "teach_by": [{"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}], "course_info": "About this course: In previous courses in the Specialization, we have discussed how to sequence and compare genomes. This course will cover advanced topics in finding mutations lurking within DNA and proteins.\n\nIn the first half of the course, we would like to ask how an individual's genome differs from the \"reference genome\" of the species. Our goal is to take small fragments of DNA from the individual and \"map\" them to the reference genome.  We will see that the combinatorial pattern matching algorithms solving this problem are elegant and extremely efficient, requiring a surprisingly small amount of runtime and memory.\n\nIn the second half of the course, we will learn how to identify the function of a protein even if it has been bombarded by so many mutations compared to similar proteins with known functions that it has become barely recognizable.  This is the case, for example, in HIV studies, since the virus often mutates so quickly that researchers can struggle to study it.  The approach we will use is based on a powerful machine learning tool called a hidden Markov model.\n\nFinally, you will learn how to apply popular bioinformatics software tools applying hidden Markov models to compare a protein against a related family of proteins.", "level": "Beginner", "rating": "4.5", "package_num": "6", "target_audience": null, "created_by": "University of California, San Diego", "title": "Finding Mutations in DNA and Proteins (Bioinformatics VI)"}, {"package_name": null, "week_data": [{"description": "介绍贯穿于课程始终的基本概念：系统、模型、方法学、方法、语言等，回顾软件开发方法学的历史、现状，并展望未来。", "video": ["1.第二次MOOC开课引言", "2.系统的概念", "3.结构的概念", "4.模型与科学模型", "5.工程模型", "6.软件模型", "7.方法学、方法、语言与图", "8.软件方法学的历史", "9.软件方法学的现状", "10.UML扩展的必要性", "11.UML扩展的机制", "12.meta、元与元模型", "13.元模型与实例", "14.软件方法的未来发展", "15.模型驱动的双向工程案例", "16.小结", "补充1.软件工程的作用与本课程的价值", "补充2.模型驱动的双向工程案例（高清）", "下节介绍", "第1节测试"], "title": "第1节：绪论-软件开发方法的演化与最新趋势 "}, {"description": "", "video": ["1.本课程的方法中应用的概念与原则（邵维忠教授主讲 11：10）", "2.本课程的方法中用到的模型与规约（邵维忠教授主讲 9：29）", "3.本课程中方法中的建模过程（邵维忠教授主讲 4：57）", "4.本课程中OOA和OOD的关系（邵维忠教授主讲 9：29 ）", "5.引例概述与需求描述（8：10）", "6.引例需求分析（16：41）", "7.引例系统分析—类图（14：16）", "8.引例系统分析—顺序图（13：54）", "9.引例系统设计—总述（9：37）", "10.引例系统设计—问题域设计与人机交互设计（17：12）", "11.引例系统设计—控制驱动设计与数据管理设计（28：16）", "12.引例系统实现与演示（8：58）", "第2节测试"], "title": "第2节：本课程方法概要与完整的引例及项目作业说明"}, {"description": "", "video": ["1.哲学中的对象", "2.对象与结构", "3.软件中的对象与面向对象方法学中的原则", "4.面向对象与基于对象", "5.封装与信息隐藏", "6.实例化", "7.消息传递", "8.消息的编译原理与消息传递的意义", "9.泛化与多态", "10.多态的编程实例", "11.覆盖、重载、基调与原型", "12.多态的实现原理", "13.关联与聚合", "第3节测试"], "title": "第3节：面向对象方法学概述"}, {"description": "", "video": ["1.几种不同的分析设计方法", "2.OOA与OOD", "3.面向对象方法的主要优点", "4.不同流派的OO方法：Booch方法", "5.不同流派的OO方法：Coad-Yourdon方法", "6.不同流派的OO方法：Jacobson方法", "7.不同流派的OO方法：Rumbaugh方法", "8.UML的产生背景与发展历史", "9.UML是什么不是什么", "10.UML的四层模型结构", "11.UML中的抽象元类和具体元类", "12.UML1中的模型图与扩展机制", "13.UML2概况", "14.UML的贡献与存在问题", "15.举例：UML体系结构中的问题", "16.学习UML的建议", "第4节测试"], "title": "第4节：面向对象方法与UML的历史与发展"}, {"description": "", "video": ["1.usecase图的历史与黑盒视角", "2.参与者的概念、分类与关系", "3.识别参与者的策略与技巧", "4.用况与简单案例", "5.用况与参与者及用况之间的关系与案例", "6.不同学者对包含关系与扩展关系的区别", "7.用况之间的泛化关系、用况的详细描述、识别策略与注意问题", "8.用况图的应用场合、复杂案例与建模要点", "9.用况驱动的方法研究，及用况与用户故事、场景、业务用况的比较研究", "10.使用Eclipse GMF自制usecase图建模工具的过程演示", "第5节测试", "作业：用况图建模作业"], "title": "第5节：需求分析——usecase图"}, {"description": "", "video": ["1.类图引言", "2.识别类与对象的方法", "3.识别属性与服务", "4.识别关系—泛化关系", "5.泛化关系的识别策略、关联关系", "6.关联关系的分类与识别策略", "7.分析模式简介", "8.聚合与组合关系", "9.依赖与实现关系", "10.建立类图实例", "第6节测试", "作业：建立类图"], "title": "第6节：系统分析—类图"}, {"description": "", "video": ["1.交互图引言", "2.简单顺序图、同步消息和异步消息", "3.顺序系统和并发系统与同步消息和异步消息的关系", "4.简单顺序图实例", "5.复杂顺序图", "6.其他交互图、综合案例（用况、类图、顺序图）", "第7节测试", "作业：建立顺序图"], "title": "第7节：系统分析—交互图"}, {"description": "", "video": ["1.状态图引言与基本概念", "2.状态的表示、内部转换、延迟事件、伪状态与最终状态", "3.状态图中的动作、活动与转换", "4.结合点与选择点", "5.简单状态图的建模实例", "6.将简单状态图转换为C++代码的方法", "7.复杂的状态图、历史状态", "8.并发状态与正交区", "9.复杂状态图的建模实例", "第8节测试", "作业：建立状态图"], "title": "第8节：系统分析—状态图"}, {"description": "", "video": ["1.设计概述、问题域部分设计概述", "2.基于复用和为了复用的设计", "3.泛化与聚合的互换", "4.泛化需要注意的其他问题", "5.一题多解案例", "6.设计模式简介", "第9节测试"], "title": "第9节：系统设计—问题域部分的设计"}, {"description": "", "video": ["1.人机交互部分设计简介", "2.控制驱动设计部分—概述与相关概念", "3.控制驱动设计引例", "4.控制驱动设计的步骤及分布式体系结构分类", "5.识别控制流的策略", "6.例1：多线程动画", "7.例1：实现与展示", "8.例2：电梯模拟控制器", "9.例2：电梯模拟控制器展示", "10.线程模式简介", "第10节测试"], "title": "第10节：系统设计—人机交互部分设计与控制驱动部分的设计"}, {"description": "", "video": ["1.数据管理部分设计概述", "2.数据管理中数据存储方案与接口的设计", "3.根据类图设计关系型数据表结构", "4.关联关系、泛化关系的到数据表的映射", "5.构件与部署设计概述", "6.活动图简介", "7.活动图的语法语义", "8.活动图表示UML的制定过程", "9.面向对象的系统实现概述", "第11节测试"], "title": "第11节：系统设计—数据管理设计、构件部署设计、活动图&系统实现"}, {"description": "", "video": ["1.网上书店的需求描述", "2.网上书店的需求分析", "3.网上书店的系统分析", "4.网上书店的系统设计：问题域部分", "5.网上书店的系统设计：人机交互部分", "6.网上书店的系统设计：数据管理部分", "7.网上书店的系统展示", "8.立体五子棋的需求描述与需求分析", "9.立体五子棋的系统分析", "10立体五子棋的系统设计", "11.立体五子棋的系统展示"], "title": "第12节：综合案例"}, {"description": "", "video": ["期末考试"], "title": "期末考试"}], "teach_by": [{"department": "软件与微电子学院", "name": "蒋 严冰"}, {"department": "北京大学信息科学技术学院", "name": "邵 维忠"}], "course_info": "About this course: 如果将软件开发人员看作行走江湖的武侠，那么各种软件开发技术就是武侠赖以傍身的武术秘籍。有的秘籍以易学灵巧见长，练习者很快掌握，并有立竿见影的功效，但失之厚重持久；有的秘籍初学乍练顿显困难，虽冥思苦解仍不得要领，需坚持不断的内功修炼方成正果，却是成为武林大侠必备的至宝。本课程有些类似于后者。\n\n《面向对象技术高级课程》深入、系统、完整地讲解当今主流的面向对象软件开发方法的分析、设计、实现及重构方法，深入讲解UML语言的高级技术细节，以及近年来面向对象方法最新的发展趋势。课程集百家之所言，并结合主讲者最新的研究成果，并通过大量、丰富、完整、不同领域、应用不同技术的案例将其中的关键知识点串联起来，便于理解和应用。\n\n本课程并不拘限于某一特定的面向对象的编程语言的编程技巧，但却包含了基于当前主流的面向对象编程语言的多项完整案例。本课程引导选课同学从更为抽象和共性的模型角度描述现实世界和软件世界,即构建分析与设计模型，之后再将其落实到软件编程实现。这种工程化的理念对于开发大型、复杂、困难、攸关软件系统是非常必要的，也是作为高级程序员、系统分析师、软件架构师等高级软件技术职位所必需具有的素质。\n\n作为一门面向广大受众的中文MOOC课程，本次课程力求向不同需求和背景的朋友呈现中华文化氛围、生动有趣的案例、跨专业的广阔的视野、以及深入实用的技术综合。\n\n同时作为一门传授软件专门知识的MOOC课程，本次课程将为具有编程能力的同学带来有趣的软件开发项目作业，在实际的软件开发中感受学以致用的快乐，体会面向对象方法学的深刻内涵。\n\n本次课程仍将邀请面向对象领域著名学者北京大学信息科学技术学院邵维忠教授和麻志毅副教授讲解某些章节，并对面向对象方法学中的某些关键问题进行讨论。", "level": "Beginner", "rating": "4.1", "package_num": null, "target_audience": "Who is this class for: 面向广大软件开发爱好者，并不局限专业与学历层次。最佳选课者为计算机科学和软件工程专业的大学生和硕士研究生。选课者最好具有一门面向对象的编程语言的基本知识和软件工程的基本知识。", "created_by": "Peking University", "title": "面向对象技术高级课程（The Advanced Object-Oriented Technology）"}, {"package_name": null, "week_data": [{"description": "This class is intended to complement a Coursera class called Global Warming I: The Science and Modeling of Climate Change, which presents much of the background to the material here.  In this class you'll be using spreadsheets (maybe) and Python (definitely) to do some simple numerical calculations on topics in Earth System Science.  The model you'll be working on this week is based on material from Unit 3 of that class, called First Climate Model.  ", "video": ["Welcome", "Scripting and Spreadsheets", "Tips for Using Spreadsheets for Numerical Simulation", "Tips for Getting Started Coding", "How the Model Works", "Model Formulation", "How to Solve Using a Spreadsheet", "How to Encode into Python or Fortran", "Code Check", "Code Review", "Code Tricks: Heat Capacity, Time Steps, and Equilibration Time"], "title": "Time-Dependent Energy Balance Model"}, {"description": "The ideas behind this model were explained in Unit 7, Feedbacks, in Part I of this class. First we get to generate simple linear \"parameterization\" functions of planetary albedo and the latitude to which ice forms (colder = lower latitude ice).  Second, for any given value of the solar constant, L, we'll use iteration to find consistent values of albedo and T, to show the effect of the ice albedo feedback on Earth's temperature, running away to fall into the dreaded \"snowball Earth\".  ", "video": ["How the Model Works", "Parameterized Relationship Between T, Ice Latitude, and Albedo", "Spreadsheet Instructions", "Coding Instructions", "Code Check", "Code Review", "Code Trick: Hysteresis Into and Out Of the Snowball"], "title": "Iterative Runaway Ice-Albedo Feedback Model"}, {"description": "Ice flows like extra-thick molasses, downhill.  The shape of the ice sheet (altitude versus distance across) is determined by the relationship between ice surface slope and the flow rate of the ice.  ", "video": ["How the Model Works", "Model Formulation", "Spreadsheet Tips", "Coding", "Code Check", "Code Review", "Code Tricks: Time Steps, Snowfall, and Elevation"], "title": "Ice Sheet Dynamics"}, {"description": "Planetary rotation and fluid flow were explained in Part I of this class, Unit 6, on Weather and Climate.  ", "video": ["How the Model Works", "Model Description", "Optional Code Check, Simple Rotation Scheme", "Optional Code Check, Interpolated Rotation ", "Code Check", "Code Review", "Code Trick: Geostrophic Flow and a Drifting Rossby Wave", "Code Trick: Gyre Circulation with Westward Intensification"], "title": "Pressure, Rotation, and Fluid Flow"}, {"description": "Background for this model was presented in Part I of this class, Unit 9, The Perturbed Carbon Cycle. ", "video": ["How the Model Works", "Description of the Model Formulation", "Tips for Solving in a Spreadsheet", "Tips for Encoding", "Code Check", "Code Review", "Code Trick: Aerosol Masking and Our Future"], "title": "A Model of Climate Changes Today"}], "teach_by": [{"department": "Geophysical Sciences", "name": "David Archer"}], "course_info": "About this course: This class provides a series of Python programming exercises intended to explore the use of numerical modeling in the Earth system and climate sciences.  The scientific background for these models is presented in a companion class, Global Warming I: The Science and Modeling of Climate Change.  This class assumes that you are new to Python programming (and this is indeed a great way to learn Python!), but that you will be able to pick up an elementary knowledge of Python syntax from another class or from on-line tutorials.", "level": null, "rating": "4.2", "package_num": null, "target_audience": null, "created_by": "The University of Chicago", "title": "Global Warming II: Create Your Own Models in Python"}, {"package_name": null, "week_data": [{"description": "This module does not study any specific combinatorial optimization problem. Instead, it introduces a central feature of linear programming, duality.", "video": ["Linear programming duality - example", "Slides", "Quiz 1", "Comment", "Properties of LP duality", "Slides", "Quiz 2", "Geometry of LP duality", "Slides", "Quiz 3", "Slides", "Quiz 4", "Proof of weak duality theorem", "Slides", "Quiz 5", "Changing the form of the LP", "Slides", "Complementary slackness", "Quiz 6", "Primal-dual algorithms", "Slides", "Quiz 7", "Slides", "Quiz 8", "Vertex cover by primal-dual", "Slides", "Conclusion", "Slides-all", "Assignment 1"], "title": "Linear Programming Duality"}, {"description": "This module uses linear programming duality to design an algorithm for another basic problem, the Steiner forest problem.", "video": ["Slides", "Quiz 1", "Problem definition", "Slides", "Quiz 2", "A special case: Steiner tree", "Slides", "Quiz 3", "LP relaxation for Steiner forest", "Slides", "Quiz 4", "... and its dual", "Slides", "Quiz 5", "Primal-dual algorithm, Part1", "Slides", "Quiz 6", "Primal-dual algorithm,Part 2", "Slides", "Quiz 7", "Analysis", "Slides", "Quiz 8", "Proof of the main lemma", "Slides-all", "Assignment 2"], "title": "Steiner Forest and Primal-Dual Approximation Algorithms"}, {"description": "This module continues teaching algorithmic applications of linear programming duality by applying it to another basic problem, the facility location problem.", "video": ["Slides", "Quiz 1", "Problem definition", "Slides", "Quiz 2", "A linear programming relaxation", "Slides", "Quiz 3", "...and its dual", "Slides", "Quiz 4", "A primal-dual algorithm", "Slides", "Quiz 5", "Analyzing the service cost", "Slides", "Quiz 6", "Analyzing the facility opening cost", "Slides", "Quiz 7", "A better algorithm", "Slides", "Quiz 8", "Analysis", "Slides", "Conclusion", "Slides-all", "Assignment 3"], "title": "Facility Location and Primal-Dual Approximation Algorithms"}, {"description": "We introduce a generalization of linear programming, semi-definite programming.This module uses semi-definite programming to design an approximation algorithm for another basic problem, the maximum cut problem.", "video": ["Definition", "Slides", "Quiz 1", "A 2-approximation", "Slides", "Quiz 2", "A linear programming relaxation...", "Slides", "Quiz 3", "Slides", "Quiz 4", "...with an integrality gap of almost 2", "Slides", "Quiz 5", "Proof of Lemma", "A quadratic programming relaxation", "Slides", "Quiz 6", "Slides", "General facts about semidefinite programming", "Quiz 7", "Slides", "A rounding algorithm", "Quiz 8", "Sldies", "Analysis", "Quiz 9", "General facts about MaxCut", "Slides", "Slides-all", "Assignment 4", "The end!", "Comment"], "title": "Maximum Cut and Semi-Definite Programming"}], "teach_by": [{"department": null, "name": "Claire Mathieu"}], "course_info": "About this course: Approximation algorithms, Part 2\n\nThis is the continuation of Approximation algorithms, Part 1. Here you will learn linear programming duality applied to the design of some approximation algorithms, and semidefinite programming applied to Maxcut.\n\nBy taking the two parts of this course, you will be exposed to a range of problems at the foundations of theoretical computer science, and to powerful design and analysis techniques. Upon completion, you will be able to recognize, when faced with a new combinatorial optimization problem, whether it is close to one of a few known basic problems, and will be able to design linear programming relaxations and use randomized rounding to attempt to solve your own problem. The course content and in particular the homework is of a theoretical nature without any programming assignments.  \n\nThis is the second of a two-part course on Approximation Algorithms.", "level": null, "rating": "4.8", "package_num": null, "target_audience": null, "created_by": "École normale supérieure", "title": "Approximation Algorithms Part II"}, {"package_name": "Data Structures and Algorithms Specialization ", "week_data": [{"description": "In April 2011, hundreds of people in Germany were hospitalized with a deadly disease that often started as food poisoning with bloody diarrhea. It was the beginning of the deadliest outbreak in recent history, caused by a mysterious bacterial strain that we will refer to as E. coli X. Within a few months, the outbreak had infected thousands and killed 53 people. To prevent the further spread of the outbreak, computational biologists all over the world had to answer the question “What is the genome sequence of E. coli X?” in order to figure out what new genes it acquired to become pathogenic. \nThe 2011 German outbreak represented an early example of epidemiologists collaborating with computational biologists to stop an outbreak. In this Genome Assembly Programming Challenge, you will follow in the footsteps of the bioinformaticians investigating the outbreak by developing a program to assemble the genome of the deadly E. coli X strain. However, before you embark on building a program for assembling the E. coli X strain, we have to explain some genomic concepts and warm you up by having you solve a simpler problem of assembling a small virus.", "video": ["2011 European E. coli outbreak", "Assembling phage genome", "Project Description", "What does it mean to assemble a genome?", "What does it mean to assemble a genome from error-prone-reads?", "Programming Assignment 1: Assembling the phi 174X Genome Using Overlap Graphs"], "title": "The 2011 European E. coli Outbreak"}, {"description": "DNA sequencing approach that led to assembly of a small virus in 1977 went through a series of transformations that contributed to the emergence of personalized medicine a few years ago. By the late 1980s, biologists were routinely sequencing viral genomes containing hundreds of thousands of nucleotides, but the idea of sequencing a bacterial (let alone the human) genome containing millions (or even billions) of nucleotides remained preposterous and would cost billions of dollars.\nIn 1988, three biologists (independently and simultaneously!) came up with an idea to reduce sequencing cost and proposed the futuristic and at the time completely implausible method of DNA arrays. None of these three biologists could have possibly imagined that the implications of his own experimental research would eventually bring him face-to-face with challenging algorithmic problems. In this module you will learn about the algorithmic challenge of DNA sequencing using information about short k-mers provided by DNA arrays. You will also travel to the 18the century to learn about the Bridges of Konigsberg and solve a related problem of assembling a jigsaw puzzle!", "video": ["DNA arrays", "Assembling genomes from k-mers", "De Bruijn graphs", "Bridges of Königsberg and universal strings", "Euler theorem", "Programming Assignment 2: Assembling the phi 174X Genome Using De Bruijn Graphs"], "title": "Assembling Genomes Using de Bruijn Graphs"}, {"description": "Our discussion of genome assembly has thus far relied upon various assumptions. In this module, we will face practical challenges introduced by quirks in modern sequencing technologies and discuss some algorithmic techniques that have been devised to address these challenges. Afterwards, you will assemble the smallest bacterial genome that lives symbiotically inside leafhoppers. Its sheltered life has allowed it to reduce its genome to only about 112,091 nucleotides and 137 genes. And afterwards, you will be ready to assemble the E. coli X genome!", "video": ["Splitting the genome into contigs", "From reads to read-pairs", "Genome assembly faces real sequencing data", "Programming Assignment 3: Genome Assembly Faces Real Sequencing Data"], "title": "Genome Assembly Faces Real Sequencing Data"}], "teach_by": [{"department": "Department of Computer Science and Engineering", "name": "Alexander S. Kulikov"}, {"department": "Computer Science", "name": "Michael Levin"}, {"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}, {"department": "Computer Science and Engineering", "name": "Neil Rhodes"}], "course_info": "About this course: In Spring 2011, thousands of people in Germany were hospitalized with a deadly disease that started as food poisoning with bloody diarrhea and often led to kidney failure. It was the beginning of the deadliest outbreak in recent history, caused by a mysterious bacterial strain that we will refer to as E. coli X. Soon, German officials linked the outbreak to a restaurant in Lübeck, where nearly 20% of the patrons had developed bloody diarrhea in a single week. At this point, biologists knew that they were facing a previously unknown pathogen and that traditional methods would not suffice – computational biologists would be needed to assemble and analyze the genome of the newly emerged pathogen.\n\nTo investigate the evolutionary origin and pathogenic potential of the outbreak strain, researchers started a crowdsourced research program. They released bacterial DNA sequencing data from one of a patient, which elicited a burst of analyses carried out by computational biologists on four continents. They even used GitHub for the project: https://github.com/ehec-outbreak-crowdsourced/BGI-data-analysis/wiki\n\nThe 2011 German outbreak represented an early example of epidemiologists collaborating with computational biologists to stop an outbreak. In this Genome Assembly Programming Challenge, you will follow in the footsteps of the bioinformaticians investigating the outbreak by developing a program to assemble the genome of the E. coli X from millions of overlapping substrings of the E.coli X genome.", "level": "Advanced", "rating": "4.3", "package_num": "6", "target_audience": null, "created_by": "University of California, San Diego, National Research University Higher School of Economics", "title": "Genome Assembly Programming Challenge"}, {"package_name": "Fundamentals of Computing Specialization ", "week_data": [{"description": "Complete a 25 question exam to demonstrate your mastery of the material in the Specialization", "video": ["Class Overview", "Exam Preparation", "Frequently Asked Questions", "Honor Code (IMPORTANT)", "Class Wrap Up", "Capstone Exam"], "title": "Fundamentals of Computing Capstone Exam"}], "teach_by": [{"department": "Computer Science", "name": "Joe Warren"}, {"department": "Computer Science", "name": "Scott Rixner"}, {"department": "Computer Science; Biochemistry and Cell Biology ", "name": "Luay Nakhleh"}], "course_info": "About this course: While most specializations on Coursera conclude with a project-based course, students in the \"Fundamentals of Computing\" specialization have completed more than 20+ projects during the first six courses of the specialization. Given that much of the material in these courses is reused from session to session, our goal in this capstone class is to provide a conclusion to the specialization that allows each student an opportunity to demonstrate their individual mastery of the material in the specialization.\n\nWith this objective in mind, the focus in this Capstone class will be an exam whose questions are updated periodically. This approach is designed to help insure that each student is solving the exam problems on his/her own without outside help. For students that have done their own work, we do not anticipate that the exam will be particularly hard. However, those students who have relied too heavily on outside help in previous classes may have a difficult time. We believe that this approach will increase the value of the Certificate for this specialization.", "level": "Intermediate", "rating": "4.8", "package_num": "7", "target_audience": null, "created_by": "Rice University", "title": "The Fundamentals of Computing Capstone Exam"}, {"package_name": "Bioinformatics Specialization ", "week_data": [{"description": "This week, we will apply genome sequencing algorithms to identify the bacterium causing a deadly food poisoning outbreak.", "video": ["Welcome to Class!", "Special Thanks", "Introduction", "Databases and Tools", "Application Challenge 1"], "title": "Week 1: Identifying the Culprit in a Food Poisoning Outbreak"}, {"description": "In this week's Application Challenge, we will learn how RNA-Sequencing can be applied to perform tissue-level gene expression analysis. In particular, which is more similar on a gene expression level: different tissues from the same organism, or analogous tissues from related species?  This question was the subject of recent debate and a Twitter controversy -- read more to find out!", "video": ["Introduction", "Databases and Tools", "Application Challenge 2"], "title": "Week 2: Comparing Gene Expression in Tissue Samples with RNA-Seq"}, {"description": "Comparing the differences between sequencing an entire human genome and sequencing only the exome, or the DNA that is eventually translated into protein.  Can we obtain a complete picture of someone's genetic disease predispositions from only the exome, or is there information lurking in introns that can provide doctors with vital information? How do we weigh the trade-offs when considering genome and exome sequencing?", "video": ["Introduction", "Databases and Tools", "Walkthroughs", "Reading: Part 3 FAQs", "Application Challenge 3"], "title": "Week 3: Weighing the Pros and Cons of Whole Genome and Whole Exome Sequencing on a Human Sample"}], "teach_by": [{"department": "Department of Computer Science & Engineering", "name": "Phillip Compeau"}, {"department": "Department of Computer Science and Engineering ", "name": "Pavel  Pevzner"}], "course_info": "About this course: In this course, you will learn how to use the BaseSpace cloud platform developed by Illumina (our industry partner) to apply several standard bioinformatics software approaches to real biological data.\n\nIn particular, in a series of Application Challenges will see how genome assembly can be used to track the source of a food poisoning outbreak, how RNA-Sequencing can help us analyze gene expression data on the tissue level, and compare the pros and cons of whole genome vs. whole exome sequencing for finding potentially harmful mutations in a human sample.\n\nPlus, hacker track students will have the option to build their own genome assembler and apply it to real data!", "level": "Beginner", "rating": "4.5", "package_num": "7", "target_audience": "Who is this class for: This course is aimed at technically-minded students who have completed the first six courses in the Bioinformatics Specialization.", "created_by": "University of California, San Diego", "title": "Bioinformatics Capstone: Big Data in Biology"}, {"package_name": null, "week_data": [{"description": "", "video": ["Welcome to the DSP course", "Introduction to Module 1", "Introduction to Lecture 1.1", "1.1.a Introduction to digital signal processing", "Introduction to Lecture 1.2", "1.2.a Discrete-time signals", "Introduction to Lecture 1.3", "1.3.a How your PC plays discrete-time sounds", "1.3.b The Karplus-Strong algorithm", "Signal of the Day: Goethe's temperature measurement", "Introduction to Lecture 1.4", "1.4.a Complex exponentials", "Notes and external resources", "Transoceanic Signal Transmission", "The Karplus-Strong Algorithm", "Practice homework for Module 1", "Homework for Module 1"], "title": "Module 1: Basics of Digital Signal Processing"}, {"description": "", "video": ["Introduction to Module 2", "Introduction to Lecture 2.1", "2.1.a Signal processing and vector spaces", "Signal of the Day: Exoplanet hunting", "Introduction to Lesson 2.2", "2.2.a Vector space", "2.2.b Signal spaces", "Introduction to Lecture 2.3", "2.3.a Bases", "Introduction to Lecture 2.4", "2.4.a Subspace-based approximations", "Notes and external resources", "Haar Bases for Image Compression", "Practice homework for Module 2", "Homework for Module 2"], "title": "Module 2: Vector Spaces"}, {"description": "", "video": ["Introduction to Module 3", "Introduction to Lesson 3.1", "3.1.a The frequency domain", "3.1.b The DFT as a change of basis", "Summary of Lesson 3.1", "Introduction to Lesson 3.2", "3.2.a DFT definition", "3.2.b Examples of DFT calculation", "3.2.c Interpreting a DFT plot", "Summary of Lesson 3.2", "Introduction to Lesson 3.3", "3.3.a DFT analysis", "3.3.b DFT example - analysis of musical instruments", "3.3.c DFT synthesis", "3.3.d DFT example - tide prediction in Venice", "3.3.e DFT example - MP3 compression", "Signal of the Day: The first man-made signal from outer space", "Summary of Lesson 3.3", "Real-valued Transforms", "Introduction to Lesson 3.4", "3.4.a The short-time Fourier transform", "3.4.b The spectrogram", "3.4.c Time-frequency tiling", "Summary of Lesson 3.4", "How to Plot the DFT", "DFT and Numerical Precision", "Dial Tones", "Practice homework for Module 3 Part 1", "Homework for Module 3 Part 1"], "title": "Module 3: Part 1 - Basics of Fourier Analysis"}, {"description": "", "video": ["Introduction to Lesson 3.5", "3.5.a Discrete Fourier series", "3.5.b Karplus-Strong revisited and DFS", "Summary of Lesson 3.5", "Introduction to Lesson 3.6", "3.6.a Karplus-Strong revisited and the DTFT", "3.6.b Existence and properties of the DTFT", "3.6.c The DTFT as a change of basis", "Summary of Lesson 3.6", "Introduction to Lesson 3.7", "3.7.a Sinusoidal modulation", "3.7.b Tuning a guitar", "Signal of the Day: Tristan Chord", "Notes and external ressources", "3.8* Relationship between transforms", "3.9* The fast Fourier transform", "Can You Hear the Phase of a Sound?", "Audio Frequency Beatings", "Practice homework for Module 3 Part 2", "Homework for Module 3 Part 2"], "title": "Module 3: Part 2 - Advanced Fourier Analysis"}, {"description": "", "video": ["Introduction to Module 4", "Introduction to Lesson 4.1", "4.1.a Linear time-invariant filters", "4.1.b Convolution", "SOTD: Can one hear the shape of a room?", "Summary of Lesson 4.1", "Introduction to Lesson 4.2", "4.2.a The moving average filter", "4.2.b The leaky integrator", "Summary of Lesson 4.2", "Introduction to Lesson 4.3", "4.3.a Filter classification in the time domain", "4.3.b Filter stability", "Summary of Lesson 4.3", "Introduction to Lesson 4.4", "4.4.a The convolution theorem", "4.4.b Examples of frequency response", "Summary of Lesson 4.4", "Introduction to Lesson 4.5", "4.5.a Filter classification in the frequency domain", "4.5.b The ideal lowpass filter", "4.5.c Ideal filters derived from the ideal lowpass filter", "4.5.d Demodulation revisited", "Summary to Lesson 4.5", "Practice homework for Module 4 Part 1", "MP3 Encoder", "MP3 encoder - Spectrum estimation", "Homework for Module 4 Part 1"], "title": " Module 4: Part 1 Introduction to Filtering"}, {"description": "", "video": ["Introduction to Lesson 4.6", "4.6.a Impulse truncation and Gibbs phenomenon", "4.6.b Window method", "4.6.c Frequency sampling", "Signal of the Day: Resolution and Space Exploration", "Summary of Lesson 4.6", "Introduction to Lesson 4.7", "4.7.a The z-transform", "4.7.b Region of convergence and stability", "Summary of Lesson 4.7", "Introduction to Lesson 4.8", "4.8.a Intuitive IIR designs", "Summary of Lesson 4.8", "Introduction to Lesson 4.9", "4.9.a Filter specifications", "4.9.b IIR design", "4.9.c FIR design", "Summary of Lesson 4.9", "Module 4: Notes and external ressources", "4.8.b* Fractional delay and Hilbert filter", "4.10* Implementation of digital filters", "4.11* Real-time processing", "4.12* Dereverberation and echo cancellation", "Filtering Music", "FIR Implementation", "Parks-McClellan FIR Design Algorithm", "A Taste of Nonlinear Processing (courtesy of the Beatles)", "Practice homework for Module 4 Part 2", "MP3 encoder - Prototype filter design", "Homework for Module 4 Part 2"], "title": "Module 4: Part 2 Filter Design"}, {"description": "", "video": ["Introduction to Module 5", "Introduction to Lesson 5.1", "5.1.a The continuous-time paradigm", "5.1.b Continuous-time signal processing", "Summary of Lesson 5.1", "Introduction to Lesson 5.2", "5.2.a Polynomial interpolation", "5.2.b Local interpolation", "Signal of the Day: Fukushima", "Summary of Lesson 5.2", "Introduction to Lesson 5.3", "5.3.a The spectrum of interpolated signals", "5.3.b The space of bandlimited functions", "5.3.c The sampling theorem", "Summary of Lesson 5.3", "Introduction to Lesson 5.4", "5.4.a Raw sampling", "5.4.b Sinusoidal aliasing", "5.4.c Aliasing for arbitrary spectra", "5.4.d Sampling strategies", "Summary of Lesson 5.4", "Introduction to Lesson 5.5", "5.5.a Stochastic signal processing", "5.5.b Quantization", "Signal of the Day: Lehman Brothers", "Summary of Lesson 5.5", "Module 5: Notes and external ressources", "5.5.c* Clipping, saturation and conpanding", "5.6* Practical sampling and interpolation", "5.7* Bandpass sampling", "5.8* Multirate signal processing", "5.9* FIR-based sampling rate conversion", "5.10* Analog-to-digital and digital-to-analog converters", "5.11* Oversampling", "One-Bit Music", "The Fukushima Disaster and Banlimited Interpolation", "Practice homework for Module 5", "MP3 encoder - Subband filtering", "Homework for Module 5"], "title": "Module 5: Sampling and Quantization"}, {"description": "", "video": ["Introduction to Module 6", "Introduction to Lesson 6.1", "6.1.a The success factors for digital communications", "6.1.b The analog channel constraints", "6.1.c The design problem", "Signal of the Day: Moire Patterns", "Summary of Lesson 6.1", "Introduction to Lesson 6.2", "6.2.a Upsampling", "6.2.b Fitting the transmitter spectrum", "Summary of Lesson 6.2", "Introduction to Lesson 6.3", "6.3.a Noise and probability of error", "6.3.b PAM and QAM", "Summary of Lesson 6.3", "Introduction to Lesson 6.4", "6.4.a Modulation and demodulation", "6.4.b Design example", "Summary of Lesson 6.4", "Introduction to Lesson 6.5", "6.5.a Receiver design", "6.5.b Delay compensation", "6.5.c Adaptive equalization", "Summary of Lesson 6.5", "Introduction to Lesson 6.6", "6.6.a ADSL design", "6.6.b Discrete multitone modulation", "Summary of Lesson 6.6", "Module 6: Notes and external ressources", "The Telephone Channel", "Simple Data Transmission", "Practice homework for Module 6", "MP3 encoder - Quantization", "7.1* Introduction to image processing", "7.2* Image manipulations", "7.3* Frequency analysis", "7.4* Image filtering", "7.5* Image compression", "7.6* The JPEG compression algorithm", "Homework for Module 6"], "title": "Module 6: Digital Communication Systems - Module 7:  Image Processing"}], "teach_by": [{"department": "School of Computer and Communication Science", "name": "Paolo Prandoni"}, {"department": "School of Computer and Communication Sciences", "name": "Martin Vetterli"}], "course_info": "About this course: Digital Signal Processing is the branch of engineering that, in the space of just a few decades, has enabled unprecedented levels of interpersonal communication and of on-demand entertainment. By reworking the principles of electronics, telecommunication and computer science into a unifying paradigm, DSP is a the heart of the digital revolution that brought us CDs, DVDs, MP3 players, mobile phones and countless other devices. \n\nThe goal, for students of this course, will be to learn the fundamentals of Digital Signal Processing from the ground up. Starting from the basic definition of a discrete-time signal, we will work our way through Fourier analysis, filter design, sampling, interpolation and quantization to build a DSP toolset complete enough to analyze a practical communication system in detail. Hands-on examples and demonstration will be routinely used to close the gap between theory and practice.\n\nTo make the best of this class, it is recommended that you are proficient in basic calculus and linear algebra; several programming examples will be provided in the form of Python notebooks but you can use your favorite programming language to test the algorithms described in the course.", "level": "Intermediate", "rating": "4.7", "package_num": null, "target_audience": "Who is this class for: This course is primarily designed for STEM undergraduates who have already completed classes in calculus and linear algebra. It is also ideal as a Digital Signal Processing primer for students interested in a mathematically solid introduction to the subject. Note that this class is NOT a hands-on, applied DSP course. While many programming examples are provided, the focus is on the theory and not on the implementation.", "created_by": "École Polytechnique Fédérale de Lausanne", "title": "Digital Signal Processing"}, {"package_name": null, "week_data": [{"description": "In Week One, you will be watching an introductory lecture that covers the motivation for NLP, examples of difficult cases, as well as the first part of the Introduction to Linguistics needed for this class. ", "video": ["Course Details", "Help us learn more about you!", "Credits", "Preview: Python dependencies for HW1", "Miscellaneous Notes", "01.01 - Introduction (8:38)", "01.02 - Examples of Text (7:51)", "01.03 - Funny Sentences (6:32) - optional", "01.04 - Administrative (8:06)", "01.05 - Why is NLP hard? (25:55)", "01.06 - Background (16:54)", "01.07 - Linguistics (21:27)", "Quiz 1"], "title": "Week One: Introduction 1/2"}, {"description": "Week Two will cover Parts of Speech, Morphology, Text Similarity, and Text Preprocessing. I will also introduce NACLO, the North American Computational Linguistics Olympiad (www.nacloweb.org), a competition for high school students interested in NLP and Linguistics.", "video": ["Welcome to Week Two", "02.01 - Parts of speech (15:49)", "02.02 - Morphology and the Lexicon (20:20)", "02.03 - Text Similarity: Introduction (7:26)", "02.04 - Morphological Similarity: Stemming (14:54)", "02.05 - Spelling Similarity: Edit Distance (20:53)", "02.06 - NACLO (3:46)", "02.07 - Preprocessing (11:30)", "Quiz 2 (note that this quiz refers to some material taught in Week Three)"], "title": "Week Two: Introduction 2/2"}, {"description": "Week Three will cover Vector Semantics, Text Similarity, and Dimensionality Reduction. I will also go through a long list of sample NLP tasks (e.g., Information Extraction, Text Summarization, and Semantic Role Labeling) and introduce each of them briefly. ", "video": ["Welcome to Week Three", "03.01 - Semantic Similarity: Synonymy and other Semantic Relations (14:16)", "03.02 - Thesaurus-based Word Similarity Methods (7:38)", "03.03 - The Vector Space Model (9:20)", "03.04 - Dimensionality Reduction (23:09)", "03.05 - NLP Tasks 1/3 (14:32)", "03.06 - NLP Tasks 2/3 (15:21)", "03.07 - NLP Tasks 3/3 (16:21)", "Quiz 3"], "title": "Week Three: NLP Tasks and Text Similarity"}, {"description": "Week Four will cover the basics of Syntax and Parsing, including CKY parsing and the Earley parser.", "video": ["Welcome to Week Four", "04.01 - Syntax (31:02)", "04.02 - Parsing (17:12)", "04.03 - Classic Parsing Methods (25:02)", "04.04 - Earley Parser (16:24)", "04.05 - The Penn Treebank (17:39)", "Quiz 4"], "title": "Week Four: Syntax and Parsing, Part 1"}, {"description": "Week Five will continue with topics related to parsing, including Statistical, Lexicalized, and Dependency Parsing as well as Noun Sequence Parsing, Prepositional Phrase Attachment, and Alternative Grammatical Formalisms.", "video": ["Welcome to Week Five", "05.01 - Parsing Introduction and recap/Parsing noun sequences (15:16)", "05.02 - Prepositional phrase attachment 1/3 (14:42) - optional", "05.03 - Prepositional phrase attachment 2/3 (16:44) - optional", "05.04 - Prepositional phrase attachment 3/3 (12:34) - optional", "05.05 - Statistical Parsing (12:44)", "05.06 - Lexicalized Parsing (8:59)", "05.07 - Dependency Parsing (18:57)", "05.08 - Alternative Parsing Formalisms (9:58)", "Quiz 5", "Dependency Parsing - you can start this assignment now"], "title": "Week Five: Syntax and Parsing, Part 2"}, {"description": "Week Six will cover Probabilities, Language Modeling, and Word Sense Disambiguation (WSD). The first two, along with some material coming up in Week Seven, will be the basis for Assignment 2. The WSD unit will be needed later for Assignment 3.", "video": ["Welcome to Week Six", "06.01 - Probabilities (21:11)", "06.02 - Bayes Theorem (10:48)", "06.03 - Language Modeling 1/3 (19:21)", "06.04 - Language Modeling 1/3 (cont'd) (3:05)", "06.05 - Language Modeling 2/3 (10:56)", "06.06 - Language Modeling 3/3 (15:06)", "06.07 - Word Sense Disambiguation (20:06)", "Quiz 6", "Language Modeling and Part of Speech Tagging - you can start this assignment now"], "title": "Week Six: Language Modeling"}, {"description": "Week Seven includes the Noisy Channel Model, Hidden Markov Models, Part of Speech Tagging (all needed for the second programming assignment) and a short introduction to Information Extraction.", "video": ["Welcome to Week Seven", "07.01 - Noisy Channel Model (8:33)", "07.02 - Part of Speech Tagging (17:57)", "07.03 - Hidden Markov Models 1/2 (24:41)", "07.04 - Hidden Markov Models 2/2 (5:28)", "07.05 - Statistical POS Tagging (9:20)", "07.06 - Information Extraction (5:34)", "07.07 - Relation Extraction (21:11)", "Quiz 7", "Word Sense Disambiguation - you can start this assignment now"], "title": "Week Seven: Part of Speech Tagging and Information Extraction"}, {"description": "Week Eight covers different topics related to Question Answering, including Question Type Classification and Evaluation of Question Answering Systems.", "video": ["Welcome to Week Eight", "08.01 - Question Answering (21:20)", "08.02 - Evaluation of QA , System Architecture (21:40)", "08.03 - QA System Architecture (7:56)", "08.04 - Question Answering Systems 1/2 (14:07)", "08.05 - Question Answering Systems 2/2 (10:39)", "Quiz 8"], "title": "Week Eight: Question Answering"}, {"description": "Week Nine covers Text Summarization and related topics such as Sentence Compression.", "video": ["Welcome to Week Nine", "09.01 - Summarization (11:37)", "09.02 - Summarization Techniques 1/3 (19:21)", "09.03 - Summarization Techniques 2/3 (20:12)", "09.04 - Summarization Techniques 3/3 (10:10)", "09.05 - Summarization Evaluation (25:18)", "09.06 - Sentence Simplification (5:18) - optional", "Quiz 9"], "title": "Week Nine: Text Summarization"}, {"description": "Week Ten covers Information Retrieval (including Document Indexing, Ranking, Evaluation), Text Classification and Text Clustering, as well as a short lecture on Collocations.", "video": ["Welcome to Week Ten", "10.01 - Collocations (11:33) - optional", "10.02 - Information Retrieval (21:10)", "10.03 - Evaluation of IR (11:09)", "10.04 - Text Classification (26:07)", "10.05 - Text Clustering (15:19)", "10.06 - Information Retrieval Toolkits (2:23)", "Quiz 10"], "title": "  Week Ten: Collocations and Information Retrieval"}, {"description": "Week Eleven covers Semantics and related topics such as Sentiment Analysis, Semantic Parsing, and Knowledge Representation.", "video": ["Welcome to Week Eleven", "11.01 - Sentiment Analysis (8:43)", "11.02 - Sentiment Lexicons (7:47)", "11.03 - Semantics (6:55)", "11.04 - Representing and Understanding Meaning (9:16)", "11.05 - First Order Logic (7:31)", "11.06 - Knowledge Representation (12:00)", "11.07 - Inference (6:36)", "11.08 - Semantic Parsing (9:17)"], "title": "Week Eleven: Sentiment Analysis and Semantics"}, {"description": "Week Twelve briefly covers Discourse Analysis, Dialogue, Machine Translation, and Text Generation.", "video": ["Welcome to Week Twelve", "12.01 - Discourse Analysis (14:56)", "12.02 - Coherence (16:39)", "12.03 - Dialogue Systems (9:22) - optional", "12.04 - Machine Translation (10:55)", "12.05 - Machine Translation Basic Techniques (11:48)", "12.06 -  Machine Translation Noisy Channel Methods (11:53)", "12.07 - Machine Translation Advanced Methods (9:36)", "12.08 - Text Generation (5:49) - optional", "Post-course Survey", "Final Exam"], "title": " Week Twelve: Discourse, Machine Translation, and Generation (Includes Final Exam)"}], "teach_by": [{"department": "College of Engineering, School of Information, School of Literature, Science and the Arts", "name": "Dragomir R. Radev, Ph.D."}], "course_info": "About this course: This course provides an introduction to the field of Natural Language Processing. It includes relevant background material in Linguistics, Mathematics, Probabilities, and Computer Science. Some of the topics covered in the class are Text Similarity, Part of Speech Tagging, Parsing, Semantics, Question Answering, Sentiment Analysis, and Text Summarization.\nThe course includes quizzes, programming assignments in Python, and a final exam.\n\nCourse Syllabus\n\nWeek One (Introduction 1/2) (1:35:31)\nWeek Two (Introduction 2/2) (1:36:26)\nWeek Three (NLP Tasks and Text Similarity) (1:42:52)\nWeek Four (Syntax and Parsing, Part 1) (1:48:14)\nWeek Five (Syntax and Parsing, Part 2) (1:50:29)\nWeek Six (Language Modeling and Word Sense Disambiguation) (1:40:33)\nWeek Seven (Part of Speech Tagging and Information Extraction) (1:33:21)\nWeek Eight (Question Answering) (1:16:59)\nWeek Nine (Text Summarization) (1:33:55)\nWeek Ten (Collocations and Information Retrieval) (1:29:40)\nWeek Eleven (Sentiment Analysis and Semantics) (1:09:38)\nWeek Twelve (Discourse, Machine Translation, and Generation) (1:30:57)\n\n\nThe course assignments will all be in Python.\n\n\nCourse Format\n\nThe class will consist of lecture videos, which are typically between 10 and 25 minutes in length. The lectures contain 1-2 integrated quiz questions per video. Grading is based on three programming assignments, weekly quizzes, and a final exam.", "level": "Intermediate", "rating": "4.1", "package_num": null, "target_audience": "Who is this class for: This class is for students interested in Computational Linguistics and Natural Language Processing. Some previous experience with probabilities will be helpful. \nPrior or concurrent experience with programming, preferably in Python, is expected.\n", "created_by": "University of Michigan", "title": "Introduction to Natural Language Processing"}]